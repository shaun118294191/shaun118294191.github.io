<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Hazardous | Shaun</title>
<link rel="shortcut icon" href="https://shaun118294191.github.io/favicon.ico?v=1584700105078">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://shaun118294191.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Hazardous | Shaun - Atom Feed" href="https://shaun118294191.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="Viruses are hazardous. Controlling viruses is hard.
In order to prepare for potential virus incoming, Country H need to ..." />
    <meta name="keywords" content="线段树合并" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://shaun118294191.github.io">
  <img class="avatar" src="https://shaun118294191.github.io/images/avatar.png?v=1584700105078" alt="">
  </a>
  <h1 class="site-title">
    Shaun
  </h1>
  <p class="site-description">
    Valar morghulis Valar Dohaeris
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Hazardous
            </h2>
            <div class="post-info">
              <span>
                2020-03-05
              </span>
              <span>
                5 min read
              </span>
              
                <a href="https://shaun118294191.github.io/tag/33IFEVjGU1/" class="post-tag">
                  # 线段树合并
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>Viruses are hazardous. Controlling viruses is hard.</p>
<p>In order to prepare for potential virus incoming, Country H need to investigate the hazard score for every administrative division. Abstractly Country H's hierarchy forms a rooted tree that every vertex is a level<br>
of administration - like province, city, county, town, etc. The root is vertex 1. Every vertex has its color which indicates the living habits of local residents - people are more likely to transport between vertices of the same color.</p>
<p>The hazard score for every vertex is calculated as the sum of distance of all pairs of different vertices in the subtree of the vertex that have the same color. The distance between two vertices is calculated as the minimum number of edges it need to transport between two vertices.</p>
<p>Time is life. You are hired to calculate the hazard score for every vectex in Country H as fast as possible.</p>
<p>Input<br>
The first line contains a integer n(1 ≤ n ≤ 100000) - the number of vertices.<br>
The second line contains n integers, the i-th number ci(1 ≤ ci ≤ n) denotes the color of vertex i.<br>
Each of the next n 1 lines contains 2 integers ui, vi(1 ≤ ui, vi ≤ n) - the ends of the i-th edge.<br>
It's guaranteed that the edges forms a tree containing n vertices.</p>
<p>Output<br>
Output n lines, on the i-th line print a single integer denoting the hazard score for subtree i。</p>
<p>给定n个节点，每个节点有一种颜色。对于每个节i, 求i的子树中所有颜色相同的节点两两距离和。</p>
<p>INPUT<br>
5<br>
1 2 1 1 2<br>
1 2<br>
2 3<br>
2 4<br>
5 1<br>
OUTPUT<br>
8 2 0 0 0<br>
<img src="https://shaun118294191.github.io/post-images/1583408451493.png" alt="" loading="lazy"></p>
<p>采用支持合并的数据结构，下标维护标号，信息维护深度总和与点数，在每个点合并子树信息并维护<br>
答案。合并的两端的某个颜色的信息分别为 (dep1, cnt1),(dep2, cnt2)，当前点深度为 d，则合并时产生贡献dep1 × cnt2 + dep2 × cnt11- 2d × cnt1 × cnt2（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Σ</mi><mrow><mo>(</mo><mi>d</mi><mn>1</mn><mo>−</mo><mi>d</mi><mo>)</mo></mrow><mo>∗</mo><mi>c</mi><mi>n</mi><mi>t</mi><mn>2</mn><mo>+</mo><mi mathvariant="normal">Σ</mi><mrow><mo>(</mo><mi>d</mi><mn>2</mn><mo>−</mo><mi>d</mi><mo>)</mo></mrow><mo>∗</mo><mi>c</mi><mi>n</mi><mi>t</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">\Sigma{(d1 - d)} * cnt2+ \Sigma{(d2 - d)}  * cnt1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Σ</span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">d</span><span class="mclose">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Σ</span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">d</span><span class="mclose">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord">1</span></span></span></span>)。</p>
<p>线段树合并: delta和curdepth为全局变量，dfs后需重新赋值</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
constexpr int MAXN = 1e5 + 5;
constexpr int LOG = 18;
using namespace std;
template &lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1; x = 0; 
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
struct Node {
	Node *lson, *rson;
	long long cnt, depth;
}Tree[MAXN * LOG * 4], *root[MAXN];
#define Lson root-&gt;lson
#define Rson root-&gt;rson
vector&lt;int&gt; G[MAXN];
int tot, n, val[MAXN];
long long delta, curDepth, depth[MAXN], ans[MAXN];
inline Node * newNode(Node * &amp;root) { 
	if (root == NULL) root = &amp;Tree[++tot];
	return root;
}
inline void insert(Node *root, int L, int R, int val) {
	if (L == R) {
		root-&gt;cnt++;
		root-&gt;depth += curDepth;
		return;
	}
	int mid = (L + R) &gt;&gt; 1;
	if (val &lt;= mid) insert(newNode(Lson), L, mid, val);
	else insert(newNode(Rson), mid + 1, R, val);
}
inline void merge(Node *&amp;root, Node *p, int L, int R) {
	if (root == NULL) {root = p; return;}
	if (p == NULL) return;
	if (L == R) {
		delta += root-&gt;depth * p-&gt;cnt + root-&gt;cnt * p-&gt;depth - 2LL * curDepth * (root-&gt;cnt) * (p-&gt;cnt);
		root-&gt;cnt += p-&gt;cnt;
		root-&gt;depth += p-&gt;depth;	
        return;
	}
	int mid = (L + R) &gt;&gt; 1;
	merge(Lson, p-&gt;lson, L, mid);
	merge(Rson, p-&gt;rson, mid + 1, R);
}
inline void dfs(int cur, int fa) {
	depth[cur] = depth[fa] + 1;
	curDepth = depth[cur];
	insert(root[cur], 1, n, val[cur]);
	for (auto to : G[cur]) {
		if (fa == to) continue;
		dfs(to, cur);
		delta = 0, curDepth = depth[cur];
		merge(root[cur], root[to], 1, n);
		ans[cur] += ans[to] + delta;
	}
}
int main(){
	read(n);
	for (int i = 1; i &lt;= n; i++) 
		read(val[i]), newNode(root[i]);
	for (int i = 1, u, v; i &lt; n; i++) {
		read(u), read(v);
		G[u].push_back(v), G[v].push_back(u);
	}
	dfs(1, 0);
	for (int i = 1; i &lt;= n; i++) printf(&quot;%lld &quot;, ans[i]);
	return 0;
}
</code></pre>
<p>Map合并:</p>

              </div>
              <div class="toc-container">
                
              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://shaun118294191.github.io/post/p1944-zui-chang-gua-hao-pi-pei/">
              <h3 class="post-title">
                P1944 最长括号匹配
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://shaun118294191.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
