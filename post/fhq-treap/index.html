<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>fhq-Treap | Shaun</title>
<link rel="shortcut icon" href="https://shaun118294191.github.io/favicon.ico?v=1586521515940">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://shaun118294191.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="fhq-Treap | Shaun - Atom Feed" href="https://shaun118294191.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="无旋Treap核心操作
1.split
将一个平衡树分成两棵树；

split有两种： 一种是按照权值split，一种是按照size来split。
如果按照权值split，那么分出来两棵树的第一棵树上的每一个数的大小都小于（或小于等于，视具..." />
    <meta name="keywords" content="无旋Treap" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://shaun118294191.github.io">
  <img class="avatar" src="https://shaun118294191.github.io/images/avatar.png?v=1586521515940" alt="">
  </a>
  <h1 class="site-title">
    Shaun
  </h1>
  <p class="site-description">
    Valar morghulis Valar Dohaeris
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              fhq-Treap
            </h2>
            <div class="post-info">
              <span>
                2020-03-03
              </span>
              <span>
                5 min read
              </span>
              
                <a href="https://shaun118294191.github.io/tag/tDB4WeDHR/" class="post-tag">
                  # 无旋Treap
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>无旋Treap核心操作</p>
<p><strong>1.split</strong><br>
将一个平衡树分成两棵树；</p>
<ul>
<li>split有两种： 一种是按照权值split，一种是按照size来split。</li>
<li>如果按照权值split，那么分出来两棵树的第一棵树上的每一个数的大小都小于（或小于等于，视具体情况而定）给定的key值;</li>
<li>如果按照size split，那么分出来两棵树的第一棵树恰好有x个节点。</li>
</ul>
<pre><code class="language-cpp">inline void split(Treap *root, Treap *&amp;L, Treap *&amp;R, int key) { //L为分裂后的左树 R为分裂后的右树
    if (root == NULL) {
	L = NULL, R = NULL; //分到底了 返回
	return;
	}
	if (root-&gt;key &lt;= key) L = root, split(Rson, Rson, R, key); //左子树key一定都小于key, 再分裂root右子树给L右子树与R
    /*  int Lsize = Lson ? Lson-&gt;size : 0; 
        if (Lsize + 1 &lt;= size) L = root, split(Rson, Rson, R, size - Lsize - 1;
    */
	else R = root, split(Lson, L, Lson, key); 
	update(root);//更新
}
</code></pre>
<p><strong>2.merge</strong><br>
将两颗分开的树合在一起，维护大根堆或小根堆性质</p>
<pre><code class="language-cpp">inline void merge(Treap *&amp;root, Treap *L, Treap *R) {
	if (L == NULL) {root = R; return;}
	if (R == NULL) {root = L; return;} 
	if (L-&gt;priority &lt; R-&gt;priority) root = L, merge(Rson, Rson, R); //L加到root上，合并右子树
	else root = R, merge(Lson, L, Lson); //R加到root上, 合并左子树
	update(root);
}
</code></pre>
<p>注意: 有merge和split操作时需要引用Treap *&amp;root。</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
constexpr int MAXN = 1e6 + 6;
constexpr int Inf = 2e9;
using namespace std;
template &lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1; x = 0; 
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
struct Treap {
	Treap *lson, *rson;
	int key, priority;
	int size;
}Tree[MAXN], *rt;
int tot, Q, type, x;
#define Lson root-&gt;lson
#define Rson root-&gt;rson
inline void newNode(Treap *&amp;root, int key) {
	root = &amp;Tree[++tot], root-&gt;size = 1;
	root-&gt;key = key, root-&gt;priority = rand();
}
inline void update(Treap *root) {
	int Lsize = Lson ? Lson-&gt;size : 0, Rsize = Rson ? Rson-&gt;size : 0;
	root-&gt;size = Lsize + Rsize + 1;
}
inline void split(Treap *root, Treap *&amp;L, Treap *&amp;R, int key) {
	if (root == NULL) {
		L = NULL, R = NULL;
		return;
	}
	if (root-&gt;key &lt;= key) L = root, split(Rson, Rson, R, key);
	else R = root, split(Lson, L, Lson, key);
	update(root);
}
inline void merge(Treap *&amp;root, Treap *L, Treap *R) {
	if (L == NULL) {root = R; return;}
	if (R == NULL) {root = L; return;}
	if (L-&gt;priority &lt; R-&gt;priority) root = L, merge(Rson, Rson, R);
	else root = R, merge(Lson, L, Lson);
	update(root);
}
inline void insert(Treap *&amp;root, int key) {
	Treap *L = NULL, *R = NULL, *tmp = NULL;
	newNode(tmp, key); //新建节点
	split(root, L, R, key); //按key分裂
	merge(L, L, tmp), merge(root, L, R); //tmp与L合并，L与R合并
}
inline void remove(Treap *&amp;root, int key) {
	Treap *L = NULL, *R = NULL, *tmp = NULL;
	split(root, L, R, key);
	split(L, L, tmp, key - 1); //按key - 1分裂 tmp的值都&gt;= key
	merge(tmp, tmp-&gt;lson, tmp-&gt;rson); //合并lson rson，从而减去一个key值
	merge(L, L, tmp), merge(root, L, R); //合并回root
}
inline int getVal(Treap *root, int rank) {//排名为rank的值
	while (true) {
		if (root == NULL) return 0;
		int Lsize = Lson ? Lson-&gt;size : 0;
		if (Lsize + 1 == rank) return root-&gt;key;
		if (Lsize &gt;= rank) root = Lson;
		else rank -= Lsize + 1, root = Rson;
	}
}
inline int getRank(Treap *&amp;root, int key) { 
	Treap *L = NULL, *R = NULL;
	split(root, L, R, key - 1);
	int res = (L ? L-&gt;size : 0) + 1;
	merge(root, L, R);
	return res;
}
inline int getPre(Treap *&amp;root, int key) {
	Treap *L = NULL, *R = NULL;
	split(root, L, R, key - 1);
	int res = getVal(L, L-&gt;size);
	merge(root, L, R);
	return res;
}
inline int getNext(Treap *&amp;root, int key) {
	Treap *L = NULL, *R = NULL;
	split(root, L, R, key);
	int res = getVal(R, 1);
	merge(root, L, R);
	return res;
}
int main(){
	srand(time(0));
	read(Q);
    while (Q--) {
        read(type), read(x);
        switch (type) {
            case 1:
                insert(rt, x);
                break;
            case 2:
                remove(rt, x);
                break;
            case 3:
                printf(&quot;%d\n&quot;, getRank(rt, x));
                break;
            case 4:
                printf(&quot;%d\n&quot;, getVal(rt, x));
                break;
            case 5:
                printf(&quot;%d\n&quot;, getPre(rt, x));
                break;
            case 6:
                printf(&quot;%d\n&quot;, getNext(rt, x));
                break;
        }
    }
	return 0;
}
</code></pre>

              </div>
              <div class="toc-container">
                
              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://shaun118294191.github.io/post/cf813e-army-creation/">
              <h3 class="post-title">
                CF813E Army Creation
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://shaun118294191.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
