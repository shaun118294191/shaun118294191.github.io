<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://shaun118294191.github.io</id>
    <title>Shaun</title>
    <updated>2020-03-10T02:18:44.801Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://shaun118294191.github.io"/>
    <link rel="self" href="https://shaun118294191.github.io/atom.xml"/>
    <subtitle>Valar morghulis Valar Dohaeris</subtitle>
    <logo>https://shaun118294191.github.io/images/avatar.png</logo>
    <icon>https://shaun118294191.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Shaun</rights>
    <entry>
        <title type="html"><![CDATA[网络流]]></title>
        <id>https://shaun118294191.github.io/post/wang-luo-liu/</id>
        <link href="https://shaun118294191.github.io/post/wang-luo-liu/">
        </link>
        <updated>2020-03-10T02:17:53.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/SYCstudio/p/7260613.html">网络流</a></p>
<p>Edmonds Karp:</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
const int MAXN = 1e4 + 4;
const int MAXM = 1e5 + 5;
const int Inf = 0x3f3f3f3f;
using namespace std;
inline int read(){
	int x = 0, f = 1;
	char ch = getchar();
	while(!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
	while(isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
	return x * f;
}
struct E{
	int to, c, next;
	E(){}
	E(int _to, int _c, int _next){
		to = _to, c = _c, next = _next;
	}
}Edge[MAXM &lt;&lt; 1];
int head[MAXN], incf[MAXN], pre[MAXN], tot, inq[MAXN];
inline void add(int from, int to, int c){
	Edge[tot] = E(to, c, head[from]), head[from] = tot++;
}
inline bool bfs(int s, int t){
	memset(inq, 0, sizeof(inq));
	queue&lt;int&gt;q;
	q.push(s);
	inq[s] = true, incf[s] = Inf;
	while(!q.empty()){
		int cur = q.front();
		q.pop();
		for(int i = head[cur]; ~i; i = Edge[i].next){
			if(!Edge[i].c) continue;
			int to = Edge[i].to;
			if(!inq[to]){
				incf[to] = min(incf[cur], Edge[i].c);
				pre[to] = i, inq[to] = true;
				q.push(to);
				if(to == t) return true;
			}
		}
	}
	return false;
}
inline void update(int s, int t, int &amp;maxFlow){
	int x = t;
	while(x != s){
		int i = pre[x];
		Edge[i].c -= incf[t];
		Edge[i ^ 1].c += incf[t];
		x = Edge[i ^ 1].to;
	}
	maxFlow += incf[t];
}
int n, m, s, t, maxFlow;
int main(){
	n = read(), m = read(), s = read(), t = read();
	memset(head, -1, sizeof(head));
	for(int i = 1; i &lt;= m; i++){
		int u, v, c;
		u = read(), v = read(), c = read();
		add(u, v, c), add(v, u, 0);
	}
	while(bfs(s, t)) update(s, t, maxFlow);
	cout &lt;&lt; maxFlow &lt;&lt; endl;
	return 0;
}
</code></pre>
<p>Dinic:</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
//https://www.luogu.com.cn/problem/P2740
const int MAXN = 1e4 + 4;
const int MAXM = 1e5 + 5;
const int Inf = 0x3f3f3f3f;
using namespace std;
inline int read(){
	int x = 0, f = 1;
	char ch = getchar();
	while(!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
	while(isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
	return x * f;
}
struct E{
	int to, c, next;
	E(){}
	E(int _to, int _c, int _next){
		to = _to, c = _c, next = _next;
	}
}Edge[MAXM &lt;&lt; 1];
int head[MAXN &lt;&lt; 1], curv[MAXN &lt;&lt; 1], tot;
int n, m, maxFlow, s, t;
int incf[MAXN &lt;&lt; 1], pre[MAXN &lt;&lt; 1], depth[MAXN &lt;&lt; 1];
inline void add(int from, int to, int c){
	Edge[tot] = E(to, c, head[from]), head[from] = tot++;
}
inline bool bfs(){
	memset(depth, 0, sizeof(depth));
	memcpy(curv, head, sizeof(head));
	queue&lt;int&gt;q;
	q.push(s), depth[s] = 1;
	while(!q.empty()){
		int cur = q.front();
		q.pop();
		for(int i = head[cur]; ~i; i = Edge[i].next){
			int to = Edge[i].to;
			if(!Edge[i].c || depth[to]) continue;
			depth[to] = depth[cur] + 1;
			q.push(to);
			if(t == to) return true;
		}
	}
	return false;
}
int dinic(int cur, int limit){
	if(cur == t) return limit;
	int flow = 0;
	for(int i = curv[cur]; ~i; i = Edge[i].next){
		curv[cur] = i;
		int to = Edge[i].to;
		if(Edge[i].c &amp;&amp; depth[to] == depth[cur] + 1){
			int k = dinic(to, min(Edge[i].c, limit));
			if(k == 0) continue;
			Edge[i].c -= k;
			Edge[i ^ 1].c += k;
			limit -= k, flow += k;
		}
	}
	if(flow == 0) depth[cur] = 0;
	return flow;
}
int main(){
	n = read(), m = read(), s = read(), t = read();
	memset(head, -1, sizeof(head));
	for(int i = 1; i &lt;= m; i++){
		int u, v, c;
		u = read(), v = read(), c = read();
		add(u, v, c), add(v, u, 0);
	}
	while(bfs()) maxFlow += dinic(s, Inf);
	cout &lt;&lt; maxFlow &lt;&lt; endl;
	return 0;
}
</code></pre>
<p>最小割：</p>
<p><a href="https://www.luogu.com.cn/problem/SP300">Cable TV Network</a>:</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
//https://www.luogu.com.cn/problem/P2740
const int MAXN = 55;
const int MAXM = 1e4 + 4;
const int Inf = 0x3f3f3f3f;
using namespace std;
inline int read(){
	int x = 0, f = 1;
	char ch = getchar();
	while(!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
	while(isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
	return x * f;
}
struct E{
	int to, c, next;
	E(){}
	E(int _to, int _c, int _next){
		to = _to, c = _c, next = _next;
	}
}Edge[MAXM &lt;&lt; 1];
int head[MAXN &lt;&lt; 1], tot(1);
int n, m, maxFlow, s, t;
int depth[MAXN &lt;&lt; 1], curv[MAXN &lt;&lt; 1];
inline void add(int from, int to, int c){
	Edge[++tot] = E(to, c, head[from]), head[from] = tot;
}
inline bool bfs(){
	memset(depth, 0, sizeof(depth));
	memcpy(curv, head, sizeof(head));
	queue&lt;int&gt;q;
	q.push(s), depth[s] = 1;
	while(!q.empty()){
		int cur = q.front();
		q.pop();
		for(int i = head[cur]; i; i = Edge[i].next){
			int to = Edge[i].to;
			if(!Edge[i].c || depth[to]) continue;
			depth[to] = depth[cur] + 1;
			q.push(to);
			if(to == t) return true;
		}
	}
	return false;
}
int dinic(int cur, int limit){
	if(cur == t) return limit;
	int flow = 0;
	for(int i = curv[cur]; ~i; i = Edge[i].next){
		curv[cur] = i;
		int to = Edge[i].to;
		if(Edge[i].c &amp;&amp; depth[to] == depth[cur] + 1){
			int k = dinic(to, min(Edge[i].c, limit));
			if(k == 0) continue;
			Edge[i].c -= k;
			Edge[i ^ 1].c += k;
			limit -= k, flow += k;
		}
	}
	if(flow == 0) depth[cur] = 0;
	return flow;
}
int u[MAXM], v[MAXM], f, testCase;
int main(){
	cin &gt;&gt; testCase;
	while(testCase--){
		cin &gt;&gt; n &gt;&gt; m;
		f = Inf;
		for(int i = 1; i &lt;= m; i++)	u[i] = read(), v[i] = read();
		for(s = 0; s &lt; n; s++)
			for(t = 0; t &lt; n; t++){
				if(s == t) continue;
				memset(head, 0, sizeof(head));
				tot = 1, maxFlow = 0;
				for(int i = 0; i &lt; n; i++)
					if(i == s || i == t) add(i, i + n, Inf), add(i + n, i, 0);
					else add(i, i + n, 1), add(i + n, i, 0);
				for(int i = 1; i &lt;= m; i++)
					add(u[i] + n, v[i], Inf), add(v[i], u[i] + n, 0),
					add(v[i] + n, u[i], Inf), add(u[i], v[i] + n, 0);
				while(bfs()) maxFlow += dinic(s, Inf);
				f = min(f, maxFlow);
			}
		if(n &lt;= 1 || f == Inf) f = n;
		cout &lt;&lt; f &lt;&lt; endl; 
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF1320B Navigation System]]></title>
        <id>https://shaun118294191.github.io/post/cf1320b-navigation-system/</id>
        <link href="https://shaun118294191.github.io/post/cf1320b-navigation-system/">
        </link>
        <updated>2020-03-09T13:29:48.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1320B">题目链接</a><br>
Rebuild 最少：若有多条最短路，让每次导航恰好取和工作路径部分重合或完全重合的最短路。如果当前节点经工作路径到终点的距离大于到该点的最短路，且最短路不和工作路径有交集，一定会 Rebuild，有交集就不 Rebuild; 如果工作路径和最短路完全重合，则不会再 Rebuild，beak即可。</p>
<p>Rebuild 最多：若有多条最短路，让每次导航优尽量取在工作路径外的最短路。 如果当前节点经工作路径到终点的距离大于到该点的最短路，且存在一最短路不和工作路径有交集，一定 Rebuild ; 若当前节点经工作路径到终点的距离等于到该点的最短路，且有多条最短路优先取工作路径以外的, 若仅有一条最短路，即只能取在工作路径上的，则不会再 Rebuild，beak即可。</p>
<p>预处理：dfs求工作路径上每个点到终点距离，求最短路时顺便记录这条最短路和工作路径是否有交集。</p>
<p>Code:</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 2e5 + 5;
int n, m, k, a[maxn], vis[maxn], p[maxn], t, u, v;
int mi_dis[maxn], chain_dis[maxn];
bool on_chain[maxn], out_chain[maxn];
int mi, mx;
#ifndef onlinejudge
map&lt;int, int&gt; id;
#else
unordered_map&lt;int, int&gt; id;
#endif
inline int read() {
    char ch = getchar();
    int x = 0, f = 1;
    while (ch &lt; '0' || ch &gt; '9') f = (ch == '-' ? -1 : 1), ch = getchar();
    while (ch &gt;= '0' &amp;&amp; ch &lt;= '9')
        x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - 48, ch = getchar();
    return x * f;
}
struct edge {
    int nxt, to;
    int mi_dis;
} e[maxn * 2];
void add(int from, int to, int dis) {
    e[t].to = to, e[t].mi_dis = dis, e[t].nxt = p[from], p[from] = t++;
}
void spfa(int st) {
    for (int i = 1; i &lt;= n; i++) mi_dis[i] = 1e9;
    deque&lt;int&gt; q;
    q.push_back(st), vis[st] = 1, mi_dis[st] = 0;
    while (!q.empty()) {
        int now = q.front();
        q.pop_front(), vis[now] = 0;
        for (int i = p[now]; i != -1; i = e[i].nxt) {
            int to = e[i].to;
            if (mi_dis[to] &gt; mi_dis[now] + e[i].mi_dis) {
                out_chain[to] = 0, on_chain[to] = 0;
                mi_dis[to] = mi_dis[now] + e[i].mi_dis;
                if (id[to]) {
                    if (id[now] &amp;&amp; id[now] - 1 == id[to])
                        on_chain[to] = 1;
                    else
                        out_chain[to] = 1;
                }
                if (!vis[to]) {
                    if (q.empty() || mi_dis[to] &gt; mi_dis[q.front()])
                        q.push_back(to);
                    else
                        q.push_front(to);
                    vis[to] = 1;
                }
            } else if (mi_dis[to] == mi_dis[now] + e[i].mi_dis) {
                if (id[to]) {
                    if (id[now] &amp;&amp; id[now] - 1 == id[to])
                        on_chain[to] = 1;
                    else
                        out_chain[to] = 1;
                }
            }
        }
    }
}
void dfs(int now, int x, int d) {
    chain_dis[now] = d;
    if (x == 0) return;
    for (int i = p[now]; i + 1; i = e[i].nxt) {
        int to = e[i].to;
        if (to == a[x]) dfs(to, x - 1, d + e[i].mi_dis);
    }
}
int main() {
    memset(p, -1, sizeof(p));
    n = read(), m = read();
    for (int i = 1; i &lt;= m; i++) {
        u = read(), v = read();
        add(v, u, 1);
    }
    k = read();
    for (int i = 1; i &lt;= k; i++) a[i] = read(), id[a[i]] = i;
    spfa(a[k]);
    dfs(a[k], k - 1, 0);
    int mi = 0, mx = 0;
    for (int i = 1; i &lt;= k - 1; i++) {
        if (chain_dis[a[i]] &gt; mi_dis[a[i]]) {
            if (!on_chain[a[i]]) mi++;
        } else break;
    }
    for (int i = 1; i &lt;= k - 1; i++) {
        if (chain_dis[a[i]] &gt; mi_dis[a[i]]) {
            if (out_chain[a[i]]) mx++;
        } else {
            if (out_chain[a[i]]) mx++;
            if (!out_chain[a[i]]) break;
        }
    }
    cout &lt;&lt; mi &lt;&lt; &quot; &quot; &lt;&lt; mx;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[NOI2004]郁闷的出纳员]]></title>
        <id>https://shaun118294191.github.io/post/noi2004yu-men-de-chu-na-yuan/</id>
        <link href="https://shaun118294191.github.io/post/noi2004yu-men-de-chu-na-yuan/">
        </link>
        <updated>2020-03-09T13:17:48.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1486">题目链接</a><br>
n 表示有多少条命令，min 表示工资下界。<br>
I k 新建一个工资档案，初始工资为 k。如果某员工的初始工资低于工资下界，他将立刻离开公司(不计入答案)。</p>
<p>A k 把每位员工的工资加上 k 。</p>
<p>S k 把每位员工的工资扣除 k(所有工资低于min的员工会立刻离开公司)。</p>
<p>F k 查询第 k 多的工资</p>
<p>fhq-Treap维护区间信息即可。</p>
<p>命令I :</p>
<pre><code class="language-cpp">inline void insert(Node &amp;root, LL key) {
    if (key &lt; Min) return;
    Node L = NULL, R = NULL, tmp = NULL;
    newNode(tmp, key);
    split(root, L, R, key);
    merge(L, L, tmp), merge(root, L, R);
}
</code></pre>
<p>命令A(给root打上标记) :</p>
<pre><code class="language-cpp">root-&gt;key += k, root-&gt;tag += k;
</code></pre>
<p>命令S :</p>
<pre><code class="language-cpp">root-&gt;key -= k, root-&gt;tag -= k;
remove(root, Min);
</code></pre>
<p>remove函数把key &lt; min的节点分到左二子，令root = R即可</p>
<pre><code class="language-cpp">inline void remove(Node &amp;root, LL key) {
    Node L = NULL, R = NULL, tmp = NULL;
    split(root, L, R, key - 1);
    leave += L ? L-&gt;size : 0;
    merge(root, tmp, R);
}
</code></pre>
<p>命令F (第k大 根据右儿子大小判断):</p>
<pre><code class="language-cpp">inline LL getKth(Node root, int rank) {
    if (root == NULL) return -1;
    pushTag(root);
    int Rsize = Rson ? Rson-&gt;size : 0;
    if (Rsize &gt;= rank) return getKth(Rson, rank);
    if (Rsize + 1 == rank) return root-&gt;key; 
    return getKth(Lson, rank - Rsize - 1);
}
</code></pre>
<p>Code:</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
constexpr int MAXN = 2e5 + 5;
using namespace std;
using LL = long long;
template &lt;typename T&gt;
inline void read(T &amp;x) {
    int f = 1; x = 0;
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
struct Treap {
    Treap *lson, *rson;
    LL key; 
    int size, priority, tag;
}Tree[MAXN], *root;
using Node = Treap*;
#define Lson root-&gt;lson
#define Rson root-&gt;rson
int n, tot, leave, Min;
inline void newNode(Node &amp;root, int key) {
    root = &amp;Tree[++tot], root-&gt;size = 1;
    root-&gt;key = key, root-&gt;priority = rand();
}
inline void update(Node root) {
    int Lsize = Lson ? Lson-&gt;size : 0, Rsize = Rson ? Rson-&gt;size : 0;
    root-&gt;size = Lsize + Rsize + 1;
}
inline void pushTag(Node root) {
    if (!root-&gt;tag) return;
    if (Lson) Lson-&gt;tag += root-&gt;tag, Lson-&gt;key += root-&gt;tag;
    if (Rson) Rson-&gt;tag += root-&gt;tag, Rson-&gt;key += root-&gt;tag;
    root-&gt;tag = 0;
}
inline void split(Node root, Node &amp;L, Node &amp;R, LL key) {
    if (root == NULL) {
        L = R = NULL;
        return;
    }
    pushTag(root);
    if (root-&gt;key &lt;= key) L = root, split(Rson, Rson, R, key);
    else R = root, split(Lson, L, Lson, key);
    update(root);
}
inline void merge(Node &amp;root, Node L, Node R) {
    if (L == NULL) {root = R; return;}
    if (R == NULL) {root = L; return;}
    if (L-&gt;priority &lt; R-&gt;priority) pushTag(root = L), merge(Rson, Rson, R);
    else pushTag(root = R), merge(Lson, L, Lson);
    update(root);
}
inline LL getKth(Node root, int rank) {
    if (root == NULL) return -1;
    pushTag(root);
    int Rsize = Rson ? Rson-&gt;size : 0;
    if (Rsize &gt;= rank) return getKth(Rson, rank);
    if (Rsize + 1 == rank) return root-&gt;key; 
    return getKth(Lson, rank - Rsize - 1);
}
inline void insert(Node &amp;root, LL key) {
    if (key &lt; Min) return;
    Node L = NULL, R = NULL, tmp = NULL;
    newNode(tmp, key);
    split(root, L, R, key);
    merge(L, L, tmp), merge(root, L, R);
}
inline void remove(Node &amp;root, LL key) {
    Node L = NULL, R = NULL, tmp = NULL;
    split(root, L, R, key - 1);
    leave += L ? L-&gt;size : 0;
    merge(root, tmp, R);
}
int main() {
    read(n), read(Min);
    for (int i = 1; i &lt;= n; i++) {
        char s; int k;
        cin &gt;&gt; s; read(k);
        if (s == 'I') insert(root, k); 
        else if (s == 'A') root-&gt;key += k, root-&gt;tag += k;
        else if (s == 'S') {
            root-&gt;key -= k, root-&gt;tag -= k;
            remove(root, Min);
        }
        else printf(&quot;%lld\n&quot;, getKth(root, k));
    }
    printf(&quot;%d\n&quot;, leave);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF609E Minimum spanning tree for each edge]]></title>
        <id>https://shaun118294191.github.io/post/cf609e-minimum-spanning-tree-for-each-edge/</id>
        <link href="https://shaun118294191.github.io/post/cf609e-minimum-spanning-tree-for-each-edge/">
        </link>
        <updated>2020-03-06T11:00:25.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF609E">题目链接</a><br>
Connected undirected weighted graph without self-loops and multiple edges is given. Graph contains n vertices and m edges.</p>
<p>For each edge <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(u,v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span> find the minimal possible weight of the spanning tree that contains the edge <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(u,v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span> .</p>
<p>The weight of the spanning tree is the sum of weights of all edges included in spanning tree.</p>
<ul>
<li>
<p>先求出最小生成树, 记录边长和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span></span></span></span></p>
</li>
<li>
<p>对于每条边<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(u, v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>，若在最小生成树上则生成树大小为sum</p>
</li>
<li>
<p>若不在最小生成树上，将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(u, v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>添加至生成树则形成一个环，删去环上的最大树边,  即得到含<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(u, v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>的最小生成树。</p>
</li>
</ul>
<p>Code:</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
constexpr int MAXN = 2e5 + 5;
constexpr int LOG = 19;
using namespace std;
using LL = long long;
template &lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1; x = 0; 
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
int n, m, fa[MAXN], u[MAXN], v[MAXN], w[MAXN];
LL sum;

inline int find(int x) {
	return fa[x] == x ? x : fa[x] = find(fa[x]);
}
inline void Union(int a, int b) {
	int r1 = find(a), r2 = find(b);
	if (r1 != r2) fa[r1] = r2;
}

vector&lt; pair&lt;int, int&gt; &gt; G[MAXN];
vector&lt; pair&lt;int, pair&lt;int, int&gt; &gt; &gt; E;

inline void kruskal() {
	sort(E.begin(), E.end());
	int cnt = 0;
	for (auto e : E) {
		int w = e.first, from = e.second.first, to = e.second.second;
		if (find(from) != find(to)) {
			Union(from, to);
			cnt++, sum += w;
			G[from].emplace_back(make_pair(to, w)), G[to].emplace_back(make_pair(from, w));
		}
		if (cnt == n - 1) break;
	}
}
int f[MAXN][LOG], val[MAXN][LOG], depth[MAXN];
inline void dfs(int cur, int fa, int w) {
	depth[cur] = depth[fa] + 1;
	f[cur][0] = fa, val[cur][0] = w;
	for (int i = 1; i &lt; LOG; i++) 
		f[cur][i] = f[f[cur][i - 1]][i - 1], 
		val[cur][i] = max(val[cur][i - 1], val[f[cur][i - 1]][i - 1]);
	for (auto e : G[cur]) {
		int to = e.first, w = e.second;
		if (to == fa) continue;
		dfs(to, cur, w);
	}
}
inline int LCA(int u, int v, int Max) {
	if (depth[u] &lt; depth[v]) swap(u, v);
	for (int i = LOG - 1; i &gt;= 0; i--)
		if (depth[f[u][i]] &gt;= depth[v]) {
			Max = max(Max, val[u][i]);
			u = f[u][i];
		}
	if (u == v) return Max;
	for (int i = LOG - 1; i &gt;= 0; i--) 
		if (f[u][i] != f[v][i]) {
			Max = max(Max, max(val[u][i], val[v][i]));
			u = f[u][i], v = f[v][i];
		}
	return max(Max, max(val[u][0], val[v][0]));
}
int main(){
	read(n), read(m);
	for (int i = 1; i &lt;= n; i++) fa[i] = i;
	for (int i = 1; i &lt;= m; i++) {
		read(u[i]), read(v[i]), read(w[i]);
		E.emplace_back(make_pair(w[i], make_pair(u[i], v[i])));
	}
	kruskal();
	dfs(1, 0, 0);
	for (int i = 1; i &lt;= m; i++) {
		int lca = LCA(u[i], v[i], 0);
		printf(&quot;%lld\n&quot;, sum - lca + w[i]);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P2893 [USACO08FEB]Making the Grade G]]></title>
        <id>https://shaun118294191.github.io/post/p2893-usaco08febmaking-the-grade-g/</id>
        <link href="https://shaun118294191.github.io/post/p2893-usaco08febmaking-the-grade-g/">
        </link>
        <updated>2020-03-06T06:33:43.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2893">题目链接</a><br>
农夫约翰想改造一条路，原来的路的每一段海拔是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，修理后是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">B_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，花费|<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> – <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">B_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>|。要求修好的路是单调不升或者单调不降的。求最小花费。</p>
<p>数学归纳分类讨论可得选择的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">B_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>一定在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>中出现。</p>
<p>于是可将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>离散化，用dp[i][j]表示修改第i条路，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mi>a</mi><mi>p</mi><mo>[</mo><msub><mi>B</mi><mi>i</mi></msub><mo>]</mo><mo>=</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">Map[B_i] = j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>的最小值。</p>
<pre><code class="language-cpp">	for (int i = 1; i &lt;= n; i++) 
		for (int j = 1; j &lt;= cnt; j++)
			for (int k = 1; k &lt;= j; k++) 
				dp[i][j] = min(dp[i][j], dp[i - 1][k] + abs(a[i] - cpy[j]);
</code></pre>
<p>可以发现对于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i, j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>，决策集合只增不少, 不需要每次都求dp[i - 1][k]，可在j++时保存下来。</p>
<pre><code class="language-cpp">	for (int i = 1; i &lt;= n; i++) {
		int val = 0x3f3f3f3f3f3f3f3f;
		for (int j = 1; j &lt;= cnt; j++) {
			val = min(val, dp[i - 1][j]);
			dp[i][j] = val + abs(a[i] - cpy[j]);	
		}
	}	
</code></pre>
<p>Code(没求递减序列但是过了?):</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
constexpr int MAXN = 2e3 + 3;
constexpr int Inf = 2e9;
using namespace std;
template &lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1; x = 0; 
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
unordered_map&lt;int, int&gt;Map;
int n, a[MAXN], cpy[MAXN], cnt, dp[MAXN][MAXN];
inline void discretizaton() {
	sort(cpy + 1, cpy + n + 1);
	cnt = unique(cpy + 1, cpy + n + 1) - cpy - 1;
	for (int i = 1; i &lt;= cnt; i++) Map[cpy[i]] = i;
}
signed main(){
	read(n);
	for (int i = 1; i &lt;= n; i++) read(a[i]), cpy[i] = a[i];
	discretizaton();
	memset(dp, 0x3f, sizeof(dp));
	for (int i = 1; i &lt;= cnt; i++) dp[0][i] = 0;
	// for (int i = 1; i &lt;= n; i++) 
	// 	for (int j = 1; j &lt;= cnt; j++)
	// 		for (int k = 1; k &lt;= j; k++) {
	// 			dp[i][j] = min(dp[i][j], dp[i - 1][k] + abs(a[i] - cpy[j]));
	// 		}
	for (int i = 1; i &lt;= n; i++) {
		int val = 0x3f3f3f3f3f3f3f3f;
		for (int j = 1; j &lt;= cnt; j++) {
			val = min(val, dp[i - 1][j]);
			dp[i][j] = val + abs(a[i] - cpy[j]);	
		}
	}	
	cout &lt;&lt; *min_element(dp[n] + 1, dp[n] + cnt + 1) &lt;&lt; endl;
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hazardous(map)]]></title>
        <id>https://shaun118294191.github.io/post/hazardousmap/</id>
        <link href="https://shaun118294191.github.io/post/hazardousmap/">
        </link>
        <updated>2020-03-05T11:50:57.000Z</updated>
        <content type="html"><![CDATA[<p>给定n个节点，每个节点有一种颜色。对于每个节i, 求i的子树中所有颜色相同的节点两两距离和。</p>
<p>采用支持合并的数据结构，下标维护标号，信息维护深度总和与点数，在每个点合并子树信息并维护<br>
答案。合并的两端的某个颜色的信息分别为 (dep1, cnt1),(dep2, cnt2)，当前点深度为 d，则合并时产生贡献dep1 × cnt2 + dep2 × cnt11- 2d × cnt1 × cnt2（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Σ</mi><mrow><mo>(</mo><mi>d</mi><mn>1</mn><mo>−</mo><mi>d</mi><mo>)</mo></mrow><mo>∗</mo><mi>c</mi><mi>n</mi><mi>t</mi><mn>2</mn><mo>+</mo><mi mathvariant="normal">Σ</mi><mrow><mo>(</mo><mi>d</mi><mn>2</mn><mo>−</mo><mi>d</mi><mo>)</mo></mrow><mo>∗</mo><mi>c</mi><mi>n</mi><mi>t</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">\Sigma{(d1 - d)} * cnt2+ \Sigma{(d2 - d)}  * cnt1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Σ</span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">d</span><span class="mclose">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Σ</span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">d</span><span class="mclose">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord">1</span></span></span></span>)。</p>
<p>Map合并:</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
typedef pair&lt;int, int&gt; pii;

#define N 101111

int n;
int color[N], dep[N];

typedef map &lt;int, pair&lt;long long, int&gt;&gt; Map;
Map root[N];
vector &lt;int&gt; G[N];
LL sc[N], delta;
int curdep;

void merge(Map &amp;root, Map &amp;p) {
	if (root.size() &lt; p.size()) swap(root, p);
	for (auto&amp; v : p) {
		int color = v.first;
		auto it = root.find(color);
		if (it != root.end()) {
			LL d1 = it-&gt;second.first, c1 = it-&gt;second.second;
			LL d2 = v.second.first, c2 = v.second.second;
			delta += d1 * c2 + d2 * c1 - 2ll * curdep * c1 * c2;
			it-&gt;second.first += d2;
			it-&gt;second.second += int(c2);
		}
		else root.insert(v);
	}
}

void init(Map&amp; root, int color) {
	root[color] = {curdep, 1};
}

void dfs(int x, int fa) {
	curdep = dep[x];
	init(root[x], color[x]);
	for (auto to : G[x]) if (to != fa){
		dep[to] = dep[x] + 1;
		dfs(to, x);
		sc[x] += sc[to];
		delta = 0;
		curdep = dep[x];
		merge(root[x], root[to]);
		sc[x] += delta;
	}
}

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, color + i);
	for (int i = 1; i &lt; n; i++) {
		int u, v;
		scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
		G[u].push_back(v);
		G[v].push_back(u);
	}
	dfs(1, -1);
	for (int i = 1; i &lt;= n; i++) printf(&quot;%lld &quot;, sc[i]);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hazardous]]></title>
        <id>https://shaun118294191.github.io/post/hazardous/</id>
        <link href="https://shaun118294191.github.io/post/hazardous/">
        </link>
        <updated>2020-03-05T11:34:37.000Z</updated>
        <content type="html"><![CDATA[<p>Viruses are hazardous. Controlling viruses is hard.</p>
<p>In order to prepare for potential virus incoming, Country H need to investigate the hazard score for every administrative division. Abstractly Country H's hierarchy forms a rooted tree that every vertex is a level<br>
of administration - like province, city, county, town, etc. The root is vertex 1. Every vertex has its color which indicates the living habits of local residents - people are more likely to transport between vertices of the same color.</p>
<p>The hazard score for every vertex is calculated as the sum of distance of all pairs of different vertices in the subtree of the vertex that have the same color. The distance between two vertices is calculated as the minimum number of edges it need to transport between two vertices.</p>
<p>Time is life. You are hired to calculate the hazard score for every vectex in Country H as fast as possible.</p>
<p>Input<br>
The first line contains a integer n(1 ≤ n ≤ 100000) - the number of vertices.<br>
The second line contains n integers, the i-th number ci(1 ≤ ci ≤ n) denotes the color of vertex i.<br>
Each of the next n 1 lines contains 2 integers ui, vi(1 ≤ ui, vi ≤ n) - the ends of the i-th edge.<br>
It's guaranteed that the edges forms a tree containing n vertices.</p>
<p>Output<br>
Output n lines, on the i-th line print a single integer denoting the hazard score for subtree i。</p>
<p>给定n个节点，每个节点有一种颜色。对于每个节i, 求i的子树中所有颜色相同的节点两两距离和。</p>
<p>INPUT<br>
5<br>
1 2 1 1 2<br>
1 2<br>
2 3<br>
2 4<br>
5 1<br>
OUTPUT<br>
8 2 0 0 0<br>
<img src="https://shaun118294191.github.io/post-images/1583408451493.png" alt="" loading="lazy"></p>
<p>采用支持合并的数据结构，下标维护标号，信息维护深度总和与点数，在每个点合并子树信息并维护<br>
答案。合并的两端的某个颜色的信息分别为 (dep1, cnt1),(dep2, cnt2)，当前点深度为 d，则合并时产生贡献dep1 × cnt2 + dep2 × cnt11- 2d × cnt1 × cnt2（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Σ</mi><mrow><mo>(</mo><mi>d</mi><mn>1</mn><mo>−</mo><mi>d</mi><mo>)</mo></mrow><mo>∗</mo><mi>c</mi><mi>n</mi><mi>t</mi><mn>2</mn><mo>+</mo><mi mathvariant="normal">Σ</mi><mrow><mo>(</mo><mi>d</mi><mn>2</mn><mo>−</mo><mi>d</mi><mo>)</mo></mrow><mo>∗</mo><mi>c</mi><mi>n</mi><mi>t</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">\Sigma{(d1 - d)} * cnt2+ \Sigma{(d2 - d)}  * cnt1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Σ</span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">d</span><span class="mclose">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Σ</span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">d</span><span class="mclose">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord">1</span></span></span></span>)。</p>
<p>线段树合并: delta和curdepth为全局变量，dfs后需重新赋值</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
constexpr int MAXN = 1e5 + 5;
constexpr int LOG = 18;
using namespace std;
template &lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1; x = 0; 
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
struct Node {
	Node *lson, *rson;
	long long cnt, depth;
}Tree[MAXN * LOG * 4], *root[MAXN];
#define Lson root-&gt;lson
#define Rson root-&gt;rson
vector&lt;int&gt; G[MAXN];
int tot, n, val[MAXN];
long long delta, curDepth, depth[MAXN], ans[MAXN];
inline Node * newNode(Node * &amp;root) { 
	if (root == NULL) root = &amp;Tree[++tot];
	return root;
}
inline void insert(Node *root, int L, int R, int val) {
	if (L == R) {
		root-&gt;cnt++;
		root-&gt;depth += curDepth;
		return;
	}
	int mid = (L + R) &gt;&gt; 1;
	if (val &lt;= mid) insert(newNode(Lson), L, mid, val);
	else insert(newNode(Rson), mid + 1, R, val);
}
inline void merge(Node *&amp;root, Node *p, int L, int R) {
	if (root == NULL) {root = p; return;}
	if (p == NULL) return;
	if (L == R) {
		delta += root-&gt;depth * p-&gt;cnt + root-&gt;cnt * p-&gt;depth - 2LL * curDepth * (root-&gt;cnt) * (p-&gt;cnt);
		root-&gt;cnt += p-&gt;cnt;
		root-&gt;depth += p-&gt;depth;	
        return;
	}
	int mid = (L + R) &gt;&gt; 1;
	merge(Lson, p-&gt;lson, L, mid);
	merge(Rson, p-&gt;rson, mid + 1, R);
}
inline void dfs(int cur, int fa) {
	depth[cur] = depth[fa] + 1;
	curDepth = depth[cur];
	insert(root[cur], 1, n, val[cur]);
	for (auto to : G[cur]) {
		if (fa == to) continue;
		dfs(to, cur);
		delta = 0, curDepth = depth[cur];
		merge(root[cur], root[to], 1, n);
		ans[cur] += ans[to] + delta;
	}
}
int main(){
	read(n);
	for (int i = 1; i &lt;= n; i++) 
		read(val[i]), newNode(root[i]);
	for (int i = 1, u, v; i &lt; n; i++) {
		read(u), read(v);
		G[u].push_back(v), G[v].push_back(u);
	}
	dfs(1, 0);
	for (int i = 1; i &lt;= n; i++) printf(&quot;%lld &quot;, ans[i]);
	return 0;
}
</code></pre>
<p>Map合并:</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P1944 最长括号匹配]]></title>
        <id>https://shaun118294191.github.io/post/p1944-zui-chang-gua-hao-pi-pei/</id>
        <link href="https://shaun118294191.github.io/post/p1944-zui-chang-gua-hao-pi-pei/">
        </link>
        <updated>2020-03-05T11:21:27.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1944">题目链接</a></p>
<p>求最长括号序列, 若有相同长度的括号序列，则输出最靠前的。</p>
<p>合法括号序列: [], (), [()], [()], <a href="">()()</a>[]</p>
<ul>
<li>用栈来维护下标, 用C[i]表示i处最长括号序列长度。</li>
<li>读入'(' 或 '['就压入栈, 否则判断当前字符是否与栈顶元素匹配。</li>
<li>如果匹配，则有C[i] = i - Stack[top] + 1 + C[Stack[top] - 1]，并弹出栈顶元素。示例 <a href="">()</a></li>
<li>若不匹配，则清空栈。示例[)]，不清空则会出错。</li>
</ul>
<pre><code class="language-cpp">    for (int i = 1; i &lt; s.size(); i++) {
        if (s[i] == '(' || s[i] == '[') Stack[++top] = i;
        else if (top) {
            if ((s[i] == ']' &amp;&amp; s[Stack[top]] == '[') ||
                (s[i] == ')' &amp;&amp; s[Stack[top]] == '(')) {
                C[i] = i - Stack[top] + 1 + C[Stack[top] - 1];
                maxL = max(maxL, C[i]);
                top--;
            } else while(top) top--;
        }
    }
</code></pre>
<p>最后遍历字符串找到第一个C[i] = maxLen的位置，输出即可。</p>
<p>Code:</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
constexpr int MAXN = 1e6 + 6;
constexpr int MAXM = 1e4 + 4;
using namespace std;
template &lt;typename T&gt;

inline void read(T &amp;x) {
    int f = 1;
    x = 0;
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}

string s, cur, ans;
int Stack[MAXN], top, C[MAXN], maxL(-1);

int main() {
    std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
    cin &gt;&gt; s, s = &quot; &quot; + s;
    for (int i = 1; i &lt; s.size(); i++) {
        if (s[i] == '(' || s[i] == '[') Stack[++top] = i;
        else if (top) {
            if ((s[i] == ']' &amp;&amp; s[Stack[top]] == '[') ||
                (s[i] == ')' &amp;&amp; s[Stack[top]] == '(')) {
                C[i] = i - Stack[top] + 1 + C[Stack[top] - 1];
                maxL = max(maxL, C[i]);
                top--;
            } else while(top) top--;
        }
    }
    for (int i = 1; i &lt; s.size(); i++) {
        if (C[i] == maxL) {
            for (int j = i - maxL + 1; j &lt;= i; j++)cout &lt;&lt; s[j];
            return 0;
        }
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[文艺平衡树]]></title>
        <id>https://shaun118294191.github.io/post/wen-yi-ping-heng-shu/</id>
        <link href="https://shaun118294191.github.io/post/wen-yi-ping-heng-shu/">
        </link>
        <updated>2020-03-04T10:13:27.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3391">题目链接</a><br>
您需要写一种数据结构（可参考题目标题），来维护一个有序数列。</p>
<p>其中需要提供以下操作：翻转一个区间，例如原有序序列是5 4 3 2 1，翻转区间是 [2,4]的话，结果是 5 2 3 4 1。</p>
<p>无旋Treap：<br>
初始化：直接将1~i merge到root即可。</p>
<pre><code class="language-cpp">for (int i = 1; i &lt;= n; i++) 
		newNode(tmp, i), merge(root, root, tmp); //直接merge
</code></pre>
<p>区间反转需按子树size分裂将整棵树分裂为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mi>l</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[1, l - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l, r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[r + 1, n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span>，并将[l, r]对应的root加上标记。</p>
<pre><code class="language-cpp">inline void rev(Node &amp;root, int l, int r) {
   Node L = NULL, mid = NULL, R = NULL;
   split(root, L, R, r), split(L, L, mid, l - 1); //分出[l, r]的部分
   mid-&gt;tag ^= 1;
   merge(L, L, mid), merge(root, L, R);
}
</code></pre>
<p>区间反转交换无旋Treap的左右儿子并下放标记(split和merge都要pushdown)。</p>
<pre><code class="language-cpp">inline void pushTag(Node root) {
	if (root-&gt;tag == 0) return;
	swap(Lson, Rson); //区间反转 交换左右儿子再打上标记即可
	if (Lson) Lson-&gt;tag ^= 1; if (Rson) Rson-&gt;tag ^= 1;
	root-&gt;tag = 0;
}
</code></pre>
<p>Code:</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
const int MAXN = 1e5 + 5;
using namespace std;
template &lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1; x = 0; 
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
struct Treap {
	Treap * lson, *rson;
	int size, priority;
	int key, tag;
}Tree[MAXN &lt;&lt; 1], *root, *tmp;
typedef Treap * Node;
#define Lson root-&gt;lson
#define Rson root-&gt;rson
int n, m, tot, l, r;
inline void newNode(Node &amp;root, int key) {
	root = &amp;Tree[++tot], root-&gt;size = 1;
	root-&gt;key = key, root-&gt;priority = rand();
}
inline void update(Node root) {
	int Lsize = Lson ? Lson-&gt;size : 0, Rsize = Rson ? Rson-&gt;size : 0;
	root-&gt;size = Lsize + Rsize + 1;
}
inline void pushTag(Node root) {
	if (root-&gt;tag == 0) return;
	swap(Lson, Rson); //区间反转 交换左右儿子再打上标记即可
	if (Lson) Lson-&gt;tag ^= 1; if (Rson) Rson-&gt;tag ^= 1;
	root-&gt;tag = 0;
}
inline void split(Node root, Node &amp;L, Node &amp;R, int size) {
	if (root == NULL) {
		L = R = NULL;
		return;
	}
	pushTag(root); //分裂前下放标记到左右子树
	int Lsize = Lson ? Lson-&gt;size : 0;
	if (Lsize + 1 &lt;= size) L = root, split(Rson, Rson, R, size - Lsize - 1);
	else R = root, split(Lson, L, Lson, size);
	update(root);
}
inline void merge(Node &amp;root, Node L, Node R) {
	if (L == NULL) {root = R; return;}
	if (R == NULL) {root = L; return;}
	if (L-&gt;priority &lt; R-&gt;priority) pushTag(root = L), merge(Rson, Rson, R);
	else pushTag(root = R), merge(Lson, L, Lson);
	update(root);
}
inline void rev(Node &amp;root, int l, int r) {
	Node L = NULL, mid = NULL, R = NULL;
	split(root, L, R, r), split(L, L, mid, l - 1); //分出[l, r]的部分
	mid-&gt;tag ^= 1;
	merge(L, L, mid), merge(root, L, R);
}
inline void print(Node root) { //中序遍历输出
	if (root == NULL) return;
	pushTag(root);
	print(Lson), printf(&quot;%d &quot;, root-&gt;key), print(Rson);
}
int main() {
	srand(time(0));
	read(n), read(m);
	for (int i = 1; i &lt;= n; i++) 
		newNode(tmp, i), merge(root, root, tmp); //直接merge
	while (m--) read(l), read(r), rev(root, l, r);
	print(root);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[fhq-Treap]]></title>
        <id>https://shaun118294191.github.io/post/fhq-treap/</id>
        <link href="https://shaun118294191.github.io/post/fhq-treap/">
        </link>
        <updated>2020-03-03T13:49:12.000Z</updated>
        <content type="html"><![CDATA[<p>无旋Treap核心操作</p>
<p><strong>1.split</strong><br>
将一个平衡树分成两棵树；</p>
<ul>
<li>split有两种： 一种是按照权值split，一种是按照size来split。</li>
<li>如果按照权值split，那么分出来两棵树的第一棵树上的每一个数的大小都小于（或小于等于，视具体情况而定）给定的key值;</li>
<li>如果按照size split，那么分出来两棵树的第一棵树恰好有x个节点。</li>
</ul>
<pre><code class="language-cpp">inline void split(Treap *root, Treap *&amp;L, Treap *&amp;R, int key) { //L为分裂后的左树 R为分裂后的右树
    if (root == NULL) {
	L = NULL, R = NULL; //分到底了 返回
	return;
	}
	if (root-&gt;key &lt;= key) L = root, split(Rson, Rson, R, key); //左子树key一定都小于key, 再分裂root右子树给L右子树与R
    /*  int Lsize = Lson ? Lson-&gt;size : 0; 
        if (Lsize + 1 &lt;= size) L = root, split(Rson, Rson, R, size - Lsize - 1;
    */
	else R = root, split(Lson, L, Lson, key); 
	update(root);//更新
}
</code></pre>
<p><strong>2.merge</strong><br>
将两颗分开的树合在一起，维护大根堆或小根堆性质</p>
<pre><code class="language-cpp">inline void merge(Treap *&amp;root, Treap *L, Treap *R) {
	if (L == NULL) {root = R; return;}
	if (R == NULL) {root = L; return;} 
	if (L-&gt;priority &lt; R-&gt;priority) root = L, merge(Rson, Rson, R); //L加到root上，合并右子树
	else root = R, merge(Lson, L, Lson); //R加到root上, 合并左子树
	update(root);
}
</code></pre>
<p>注意: 有merge和split操作时需要引用Treap *&amp;root。</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
constexpr int MAXN = 1e6 + 6;
constexpr int Inf = 2e9;
using namespace std;
template &lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1; x = 0; 
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
struct Treap {
	Treap *lson, *rson;
	int key, priority;
	int size;
}Tree[MAXN], *rt;
int tot, Q, type, x;
#define Lson root-&gt;lson
#define Rson root-&gt;rson
inline void newNode(Treap *&amp;root, int key) {
	root = &amp;Tree[++tot], root-&gt;size = 1;
	root-&gt;key = key, root-&gt;priority = rand();
}
inline void update(Treap *root) {
	int Lsize = Lson ? Lson-&gt;size : 0, Rsize = Rson ? Rson-&gt;size : 0;
	root-&gt;size = Lsize + Rsize + 1;
}
inline void split(Treap *root, Treap *&amp;L, Treap *&amp;R, int key) {
	if (root == NULL) {
		L = NULL, R = NULL;
		return;
	}
	if (root-&gt;key &lt;= key) L = root, split(Rson, Rson, R, key);
	else R = root, split(Lson, L, Lson, key);
	update(root);
}
inline void merge(Treap *&amp;root, Treap *L, Treap *R) {
	if (L == NULL) {root = R; return;}
	if (R == NULL) {root = L; return;}
	if (L-&gt;priority &lt; R-&gt;priority) root = L, merge(Rson, Rson, R);
	else root = R, merge(Lson, L, Lson);
	update(root);
}
inline void insert(Treap *&amp;root, int key) {
	Treap *L = NULL, *R = NULL, *tmp = NULL;
	newNode(tmp, key); //新建节点
	split(root, L, R, key); //按key分裂
	merge(L, L, tmp), merge(root, L, R); //tmp与L合并，L与R合并
}
inline void remove(Treap *&amp;root, int key) {
	Treap *L = NULL, *R = NULL, *tmp = NULL;
	split(root, L, R, key);
	split(L, L, tmp, key - 1); //按key - 1分裂 tmp的值都&gt;= key
	merge(tmp, tmp-&gt;lson, tmp-&gt;rson); //合并lson rson，从而减去一个key值
	merge(L, L, tmp), merge(root, L, R); //合并回root
}
inline int getVal(Treap *root, int rank) {//排名为rank的值
	while (true) {
		if (root == NULL) return 0;
		int Lsize = Lson ? Lson-&gt;size : 0;
		if (Lsize + 1 == rank) return root-&gt;key;
		if (Lsize &gt;= rank) root = Lson;
		else rank -= Lsize + 1, root = Rson;
	}
}
inline int getRank(Treap *&amp;root, int key) { 
	Treap *L = NULL, *R = NULL;
	split(root, L, R, key - 1);
	int res = (L ? L-&gt;size : 0) + 1;
	merge(root, L, R);
	return res;
}
inline int getPre(Treap *&amp;root, int key) {
	Treap *L = NULL, *R = NULL;
	split(root, L, R, key - 1);
	int res = getVal(L, L-&gt;size);
	merge(root, L, R);
	return res;
}
inline int getNext(Treap *&amp;root, int key) {
	Treap *L = NULL, *R = NULL;
	split(root, L, R, key);
	int res = getVal(R, 1);
	merge(root, L, R);
	return res;
}
int main(){
	srand(time(0));
	read(Q);
    while (Q--) {
        read(type), read(x);
        switch (type) {
            case 1:
                insert(rt, x);
                break;
            case 2:
                remove(rt, x);
                break;
            case 3:
                printf(&quot;%d\n&quot;, getRank(rt, x));
                break;
            case 4:
                printf(&quot;%d\n&quot;, getVal(rt, x));
                break;
            case 5:
                printf(&quot;%d\n&quot;, getPre(rt, x));
                break;
            case 6:
                printf(&quot;%d\n&quot;, getNext(rt, x));
                break;
        }
    }
	return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>