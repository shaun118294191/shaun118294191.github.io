<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://shaun118294191.github.io</id>
    <title>Shaun</title>
    <updated>2020-03-20T13:44:29.870Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://shaun118294191.github.io"/>
    <link rel="self" href="https://shaun118294191.github.io/atom.xml"/>
    <subtitle>Valar morghulis Valar Dohaeris</subtitle>
    <logo>https://shaun118294191.github.io/images/avatar.png</logo>
    <icon>https://shaun118294191.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Shaun</rights>
    <entry>
        <title type="html"><![CDATA[SP2059 CERC07S - Robotic Sort]]></title>
        <id>https://shaun118294191.github.io/post/sp2059-cerc07s-robotic-sort/</id>
        <link href="https://shaun118294191.github.io/post/sp2059-cerc07s-robotic-sort/">
        </link>
        <updated>2020-03-20T13:41:21.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/SP2059">题目链接</a><br>
跟新中<br>
Code:</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
constexpr int MAXN = 1e5 + 5;
constexpr int Inf = 1e9;
using namespace std;
template &lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1;
    x = 0;
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
struct Treap {
    Treap *lson, *rson;
    int size, priority;
    int key, tag, min;
} Tree[MAXN], *root, *tmp;
#define Lson root-&gt;lson
#define Rson root-&gt;rson
using Node = Treap *;
int tot, n, cnt;
inline void newNode(Node &amp;root, int key) {
    root = &amp;Tree[tot++], root-&gt;min = key;
    root-&gt;key = key, root-&gt;priority = rand(), root-&gt;size = 1;
}
inline void update(Node root) {
    int Lsize = Lson ? Lson-&gt;size : 0, Rsize = Rson ? Rson-&gt;size : 0;
    int Lmin = Lson ? Lson-&gt;min : Inf, Rmin = Rson ? Rson-&gt;min : Inf;
    root-&gt;size = Lsize + Rsize + 1;
    root-&gt;min = min(root-&gt;key, min(Lmin, Rmin));
}
inline void pushTag(Node root) {
    if (!root-&gt;tag) return;
    swap(Lson, Rson);
    if (Lson) Lson-&gt;tag ^= 1;
    if (Rson) Rson-&gt;tag ^= 1;
    root-&gt;tag = 0;
}
inline int getPos(Node root, int key) {
    if (root == NULL) return 0;
    pushTag(root);
    int Lsize = Lson ? Lson-&gt;size : 0;
    int Lmin = Lson ? Lson-&gt;min : Inf, Rmin = Rson ? Rson-&gt;min : Inf;
    if (root-&gt;key == key &amp;&amp; Lmin &gt; key)
        return Lsize + 1;
    else if (Lmin == key)
        return getPos(Lson, key);
    else
        return Lsize + 1 + getPos(Rson, key);
}
inline void split(Node root, Node &amp;L, Node &amp;R, int size) {
    if (root == NULL) {
        L = R = NULL;
        return;
    }
    pushTag(root);  //分裂前下放标记到左右子树
    int Lsize = Lson ? Lson-&gt;size : 0;
    if (Lsize + 1 &lt;= size)
        L = root, split(Rson, Rson, R, size - Lsize - 1);
    else
        R = root, split(Lson, L, Lson, size);
    update(root);
}
inline void merge(Node &amp;root, Node L, Node R) {
    if (L == NULL) { root = R; return;}
    if (R == NULL) { root = L; return;}
    if (L-&gt;priority &lt; R-&gt;priority)
        pushTag(root = L), merge(Rson, Rson, R);
    else
        pushTag(root = R), merge(Lson, L, Lson);
    update(root);
}
pair&lt;int, int&gt; vec[MAXN];
int main() {
    //freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);
    srand(time(0));
    while (cin &gt;&gt; n &amp;&amp; n) {
        tot = 0, root = NULL;
        memset(Tree, 0, sizeof(Tree));
        for (int i = 1, val; i &lt;= n; i++) 
            read(val), vec[i] = make_pair(val, i);
        sort(vec + 1, vec + n + 1);
        for (int i = 1; i &lt;= n; i++) vec[vec[i].second].first = i;
        for (int i = 1; i &lt;= n; i++)
            newNode(tmp, vec[i].first), merge(root, root, tmp);
        for (int i = 1; i &lt;= n; i++) {
            Node L = NULL, tmp = NULL, R = NULL;
            int pos = getPos(root, root-&gt;min);
            i == n ? printf(&quot;%d\n&quot;, pos + i - 1) : printf(&quot;%d &quot;, pos + i - 1);
            split(root, L, R, pos - 1), split(R, tmp, R, 1);
            if (L) L-&gt;tag ^= 1;
            merge(root, L, R);
        }
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P2680 运输计划]]></title>
        <id>https://shaun118294191.github.io/post/p2680-yun-shu-ji-hua/</id>
        <link href="https://shaun118294191.github.io/post/p2680-yun-shu-ji-hua/">
        </link>
        <updated>2020-03-20T10:25:11.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2680">题目链接</a><br>
将图转化为一颗有根树，求出给节点到根的距离。对于运输计划 (u，v) ，不考虑其经过虫洞，则有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mrow><mo>(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo>)</mo></mrow></msub><mo>=</mo><mi>d</mi><mi>i</mi><mi>s</mi><mo>[</mo><mi>u</mi><mo>]</mo><mo>+</mo><mi>d</mi><mi>i</mi><mi>s</mi><mo>[</mo><mi>v</mi><mo>]</mo><mo>−</mo><mn>2</mn><mo>∗</mo><mi>d</mi><mi>i</mi><mi>s</mi><mo>[</mo><mi>L</mi><mi>C</mi><msub><mi>A</mi><mrow><mi>u</mi><mo separator="true">,</mo><mi>v</mi></mrow></msub><mo>]</mo></mrow><annotation encoding="application/x-tex">T_{(u, v)} = dis[u] + dis[v] - 2 * dis[LCA_{u, v}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">u</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">u</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>。</p>
<p>二分最长运输时间 mid ，若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mrow><mi>u</mi><mo separator="true">,</mo><mi>v</mi></mrow></msub><mo>&lt;</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">T_{u, v} &lt;= mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">u</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span></span></span> , 则符合条件；否则记录不符合条件的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mrow><mi>u</mi><mo separator="true">,</mo><mi>v</mi></mrow></msub></mrow><annotation encoding="application/x-tex">T_{u, v}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">u</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>数目cnt，和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mrow><mi>u</mi><mo separator="true">,</mo><mi>v</mi></mrow></msub><mo>−</mo><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">T_{u, v} - mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">u</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span></span></span> 的最大值max , 并将 (u， v) 的路径覆盖(树上差分实现)。</p>
<p>根据差分数组，树上dfs求出边被覆盖的次数。</p>
<p>若某一条边的权值 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mo>≥</mo><mi>m</mi><mi>a</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">w \ge max</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span></span></span></span> 并且其被覆盖的次数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≥</mo><mi>c</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">\ge cnt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span>, 则说明所有运输计划都能在mid内完成；否则一定不能完成。(一条比当前边权值小的边即使覆盖次数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≥</mo><mi>c</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">\ge cnt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span>, 当前边所在的计划也不能完成)</p>
<p>Code: 3e5以上的数据最好别用vector的emplace_back or push_back添加元素。</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
constexpr int MAXN = 3e5 + 5;
constexpr int LOG = 20;
using namespace std;
using A = int [MAXN];
template &lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1; x = 0;
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
int n, m, f[MAXN][LOG], tot;
int need, provide, cnt;
A depth, delta, dis, head;
struct node {
    int to, w, next;
    node(){}
    node(int _to, int _w, int _next) : to(_to), w(_w), next(_next){}
}Edge[MAXN &lt;&lt; 1];
inline void add(int from, int to, int w) {
    Edge[tot] = node(to, w, head[from]), head[from] = tot++;
    Edge[tot] = node(from, w, head[to]), head[to] = tot++;
}
pair&lt;pair&lt;int, int&gt;, int&gt; vec[MAXN];
inline void dfs(int cur, int fa) {
    depth[cur] = depth[fa] + 1, f[cur][0] = fa;
    for (int i = 1; i &lt; LOG; i++)
        f[cur][i] = f[f[cur][i - 1]][i - 1];
    for (int i = head[cur]; ~i; i = Edge[i].next) {
        int to = Edge[i].to, w = Edge[i].w;
        if (to == fa) continue;
        dis[to] = dis[cur] + w;
        dfs(to, cur);
    }
}
inline int LCA(int u, int v) {
    if (depth[u] &lt; depth[v]) swap(u, v);
    for (int i = LOG - 1; i &gt;= 0; i--)
        if (depth[f[u][i]] &gt;= depth[v])
            u = f[u][i];
    if (u == v) return u;
    for (int i = LOG - 1; i &gt;= 0; i--)
        if (f[u][i] != f[v][i])
            u = f[u][i], v = f[v][i];
    return f[u][0];
}
inline void getCnt(int cur, int fa, int w) { //w与父亲之间的距离
    for (int i = head[cur]; ~i; i = Edge[i].next) {
        int to = Edge[i].to, w = Edge[i].w;
        if (to == fa) continue;
        getCnt(to, cur, w);
        delta[cur] += delta[to];
    }
    if (w &gt;= need) provide = max(provide, delta[cur]);
}
inline bool check(int mid) {
    need = 0, provide = 0, cnt = 0;
    memset(delta, 0, sizeof(delta));
    for (int i = 1; i &lt;= m; i++) {
        int u = vec[i].first.first, v = vec[i].first.second, lca = vec[i].second;
        int d = dis[u] + dis[v] - 2 * dis[lca];
        if (d &gt; mid) {
            delta[u]++, delta[v]++, delta[lca] -= 2;
            cnt++, need = max(need, d - mid);
        }
    }
    getCnt(1, 0, 0);
    return provide &gt;= cnt;
}
int main() {
    read(n), read(m);
    memset(head, -1, sizeof(head));
    for (int i = 1, u, v, t; i &lt; n; i++) {
        read(u), read(v), read(t);
        add(u, v, t);
    }
    dfs(1, 0);
    for (int i = 1, u, v, lca; i &lt;= m; i++) {
        read(u), read(v), lca = LCA(u, v);
        vec[i] = make_pair(make_pair(u, v), lca);
    }
    int l = 0, r = 3e8, ans = 0;
    while (l &lt;= r) {
        int mid = (l + r) &gt;&gt; 1;
        if (check(mid)) ans = mid, r = mid - 1;
        else l = mid + 1;
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P3629 [APIO2010]巡逻]]></title>
        <id>https://shaun118294191.github.io/post/p3629-apio2010xun-luo/</id>
        <link href="https://shaun118294191.github.io/post/p3629-apio2010xun-luo/">
        </link>
        <updated>2020-03-19T10:59:38.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3629">题目链接</a><br>
树的直径,又称树的最长链,定义为一棵树上最远的两个节点的路径,即树上一条不重复经过某一条边的最长的路径。</p>
<p>树形DP求树的直径(可处理负边权):</p>
<pre><code class="language-cpp">inline void DP(int cur, int fa) {
    for (int i = head[cur]; ~i; i = Edge[i].next) {
        int to = Edge[i].to, w = Edge[i].w;
        if (to == fa) continue;
        DP(to, cur);
        L2 = max(L2, dp[cur] + dp[to] + w);
        dp[cur] = max(dp[cur], dp[to] + w);
    }
}
</code></pre>
<p>二次BFS / DFS求树的直径(可记录前驱求出路径，但无法处理负边权的情况)：</p>
<ul>
<li>从任意一个节点出发对树执行一次深度/广度优先遍历，求出与起始点最远的节点st。</li>
<li>从st出发执行一次深度/广度优先遍历，求出与st最远的节点ed。</li>
<li>从st到ed的路径即为树的直径(st一定时直径的一端，否则一定能找到一条更长的链）。</li>
</ul>
<pre><code class="language-cpp">L1 = -Inf, dfs(1, 0);
dis[ed] = 0, pre[ed] = -1, L1 = -Inf;
dfs(ed, 0);
inline void dfs(int cur, int fa) {
    for (int i = head[cur]; ~i; i = Edge[i].next) {
        int to = Edge[i].to, w = Edge[i].w;
        if (to == fa) continue;
        dis[to] = dis[cur] + 1, pre[to] = i;
        if (dis[to] &gt; L1) L1 = dis[to], ed = to;
        dfs(to, cur);
    }
}
</code></pre>
<p>二次BFS / DFS求树的直径清空。</p>
<p>本题 k = 1时求树的直径L1，将起点与终点连接即可让巡逻路径最短, res = 2 * (n - 1) - (L1 - 1)。</p>
<p>k = 2时，建立第二条道路 (u, v) 后又会形成一个环。若两条路径不重叠，答案继续减小；否则将两个环结合，则重叠的路径一正一反巡逻一次，相当于可以不经过重叠路径。</p>
<p>为将重叠的部分抵消，并使结果最小，将直径L1上的边权取反，再次求树的直径L2，res = 2 * (n - 1) - (L1 - 1) - (L2 - 1)。<br>
Code:</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
constexpr int MAXN = 1e5 + 5;
constexpr int Inf = 1e9;
using namespace std;
using A = int [MAXN];
template &lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1; x = 0;
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
int n, k, L1, L2, tot, ed;
A pre, dis, head, dp;
struct node {
    int to, next, w;
    node (){}
    node (int _to, int _w, int _next) : to(_to), next(_next), w(_w){}
}Edge[MAXN &lt;&lt; 1];
inline void add(int from, int to) {
    Edge[tot] = node(to, 1, head[from]), head[from] = tot++;
    Edge[tot] = node(from, 1, head[to]), head[to] = tot++;
}
inline void dfs(int cur, int fa) {
    for (int i = head[cur]; ~i; i = Edge[i].next) {
        int to = Edge[i].to, w = Edge[i].w;
        if (to == fa) continue;
        dis[to] = dis[cur] + 1, pre[to] = i;
        if (dis[to] &gt; L1) L1 = dis[to], ed = to;
        dfs(to, cur);
    }
}
inline void DP(int cur, int fa) {
    for (int i = head[cur]; ~i; i = Edge[i].next) {
        int to = Edge[i].to, w = Edge[i].w;
        if (to == fa) continue;
        DP(to, cur);
        L2 = max(L2, dp[cur] + dp[to] + w);
        dp[cur] = max(dp[cur], dp[to] + w);
    }
}
int main() {
    //freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
    read(n), read(k);
    memset(head, -1, sizeof(head));
    for (int i = 1, u, v; i &lt; n; i++)
        read(u), read(v), add(u, v);
    L1 = -Inf, dfs(1, 0);
    dis[ed] = 0, pre[ed] = -1, L1 = -Inf;
    dfs(ed, 0);
    if (k == 1) cout &lt;&lt; 2 * (n - 1) - (L1 - 1) &lt;&lt; endl;
    else {
        while (~pre[ed]) {
            Edge[pre[ed]].w = Edge[pre[ed] ^ 1].w = -1;
            ed = Edge[pre[ed] ^ 1].to;
        }
        DP(1, 0);
        cout &lt;&lt; 2 * (n - 1) - (L1 - 1) - (L2 - 1);
    }
    return 0;
}</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[天天爱跑步]]></title>
        <id>https://shaun118294191.github.io/post/tian-tian-ai-pao-bu/</id>
        <link href="https://shaun118294191.github.io/post/tian-tian-ai-pao-bu/">
        </link>
        <updated>2020-03-17T06:57:32.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1600">题目链接</a></p>
<p>每个玩家的跑步路径可以拆成两段：从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">S_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>c</mi><mi>a</mi><mo>(</mo><msub><mi>S</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>T</mi><mi>i</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">lca(S_i, T_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>c</mi><mi>a</mi><mo>(</mo><msub><mi>S</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>T</mi><mi>i</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">lca(S_i, T_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，其中后者不包括 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>c</mi><mi>a</mi><mo>(</mo><msub><mi>S</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>T</mi><mi>i</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">lca(S_i, T_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 这个端点。</p>
<p>位于节点 x 的观察员能观察到玩家，当且仅当：</p>
<ul>
<li>x 位于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">S_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>c</mi><mi>a</mi><mo>(</mo><msub><mi>S</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>T</mi><mi>i</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">lca(S_i, T_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的路径上，且满足 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi><mo>[</mo><msub><mi>S</mi><mi>i</mi></msub><mo>]</mo><mo>=</mo><mo>=</mo><mi>d</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>+</mo><mi>w</mi><mo>[</mo><mi>x</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">depth[S_i] == d[x] + w[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span>。</li>
<li>x 位于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>c</mi><mi>a</mi><mo>(</mo><msub><mi>S</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>T</mi><mi>i</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">lca(S_i, T_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的路径上，且满足 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi><mo>[</mo><msub><mi>S</mi><mi>i</mi></msub><mo>]</mo><mo>−</mo><mn>2</mn><mo>∗</mo><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi><mo>[</mo><mi>l</mi><mi>c</mi><mi>a</mi><mo>(</mo><msub><mi>S</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>T</mi><mi>i</mi></msub><mo>)</mo><mo>]</mo><mo>=</mo><mi>w</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>−</mo><mi>d</mi><mo>[</mo><mi>x</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">depth[S_i] - 2 * depth[lca(S_i, T_i)] = w[x] - d[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span>。</li>
</ul>
<p>也就相当于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">S_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>c</mi><mi>a</mi><mo>(</mo><msub><mi>S</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>T</mi><mi>i</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">lca(S_i, T_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的路径上每个点增加一个权值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi><mo>[</mo><msub><mi>S</mi><mi>i</mi></msub><mo>]</mo></mrow><annotation encoding="application/x-tex">depth[S_i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>的物品，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>c</mi><mi>a</mi><mo>(</mo><msub><mi>S</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>T</mi><mi>i</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">lca(S_i, T_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的路径(不包括<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>c</mi><mi>a</mi><mo>(</mo><msub><mi>S</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>T</mi><mi>i</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">lca(S_i, T_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>)上每个点增加一个权值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi><mo>[</mo><msub><mi>S</mi><mi>i</mi></msub><mo>]</mo><mo>−</mo><mn>2</mn><mo>∗</mo><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi><mo>[</mo><mi>l</mi><mi>c</mi><mi>a</mi><mo>(</mo><msub><mi>S</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>T</mi><mi>i</mi></msub><mo>)</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">depth[S_i] - 2 * depth[lca(S_i, T_i)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">]</span></span></span></span>的物品。</p>
<p>问题转化为统计 x 的子树中有多少 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>+</mo><mi>w</mi><mo>[</mo><mi>x</mi><mo>]</mo><mi mathvariant="normal">或</mi><mi>w</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>−</mo><mi>d</mi><mo>[</mo><mi>x</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">d[x] + w[x] 或 w[x] - d[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mord cjk_fallback">或</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span>。</p>
<p>可值域线段树统计，也可每个点建立一个vector, 并用cntDepth[]数组统计(两类路径需分开)。</p>
<p>存入vector + 差分：</p>
<pre><code class="language-cpp">    for (int i = 1; i &lt;= m; i++) {
        read(s[i]), read(t[i]);
        int lca = LCA(s[i], t[i]);
        vec1[s[i]].emplace_back(make_pair(depth[s[i]], 1));
        vec1[f[lca][0]].emplace_back(make_pair(depth[s[i]], -1));
        vec2[t[i]].emplace_back(make_pair(depth[s[i]] - 2 * depth[lca], 1));
        vec2[lca].emplace_back(make_pair(depth[s[i]] - 2 * depth[lca], -1));
    }
</code></pre>
<p>dfs求cnt, 注意减去其它子树中的cnt：</p>
<pre><code class="language-cpp">inline void getRes(int cur, int fa) {
    int pre = cnt1[w[cur] + depth[cur] + ADD] + cnt2[w[cur] - depth[cur] + ADD]; 
    //其它子树中的cntDis需减去
    for (auto &amp;to : G[cur]) {
        if (to == fa) continue;
        getRes(to, cur);
    }
    for (auto &amp;i : vec1[cur]) cnt1[i.first + ADD] += i.second; //两类cnt
    for (auto &amp;i : vec2[cur]) cnt2[i.first + ADD] += i.second;
    res[cur] += cnt1[w[cur] + depth[cur] + ADD] + cnt2[w[cur] - depth[cur] + ADD] - pre;
}
</code></pre>
<p>Code:</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
constexpr int MAXN = 3e5 + 5;
constexpr int ADD = 3e5;
constexpr int LOG = 20;
using namespace std;
using A = int [MAXN &lt;&lt; 1];
template &lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1; x = 0;
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
int n, m, f[MAXN][LOG];
A res, depth, w, cnt1, cnt2, s, t;
vector&lt;int&gt; G[MAXN];
vector&lt; pair&lt;int, int&gt; &gt; vec1[MAXN], vec2[MAXN];
inline void dfs(int cur, int fa) {
    f[cur][0] = fa, depth[cur] = depth[fa] + 1;
    for (int i = 1; i &lt; LOG; i++)
        f[cur][i] = f[f[cur][i - 1]][i - 1];
    for (auto &amp;to : G[cur]) {
        if (to == fa) continue;
        dfs(to, cur);
    }
}
inline int LCA(int u, int v) {
    if (depth[u] &lt; depth[v]) swap(u, v);
    for (int i = LOG - 1; i &gt;= 0; i--)
        if (depth[f[u][i]] &gt;= depth[v])
            u = f[u][i];
    if (u == v) return u;
    for (int i = LOG - 1; i &gt;= 0; i--)
        if (f[u][i] != f[v][i])
            u = f[u][i], v = f[v][i];
    return f[u][0];
}
inline void getRes(int cur, int fa) {
    int pre = cnt1[w[cur] + depth[cur] + ADD] + cnt2[w[cur] - depth[cur] + ADD]; 
    //其它子树中的cntDis需减去
    for (auto &amp;to : G[cur]) {
        if (to == fa) continue;
        getRes(to, cur);
    }
    for (auto &amp;i : vec1[cur]) cnt1[i.first + ADD] += i.second; //两类cnt
    for (auto &amp;i : vec2[cur]) cnt2[i.first + ADD] += i.second;
    res[cur] += cnt1[w[cur] + depth[cur] + ADD] + cnt2[w[cur] - depth[cur] + ADD] - pre;
}
int main() {
    read(n), read(m);
    for (int i = 1, u, v; i &lt; n; i++) {
        read(u), read(v);
        G[u].emplace_back(v), G[v].emplace_back(u);
    }
    dfs(1, 0);
    for (int i = 1; i &lt;= n; i++) read(w[i]);
    for (int i = 1; i &lt;= m; i++) {
        read(s[i]), read(t[i]);
        int lca = LCA(s[i], t[i]);
        vec1[s[i]].emplace_back(make_pair(depth[s[i]], 1));
        vec1[f[lca][0]].emplace_back(make_pair(depth[s[i]], -1));
        vec2[t[i]].emplace_back(make_pair(depth[s[i]] - 2 * depth[lca], 1));
        vec2[lca].emplace_back(make_pair(depth[s[i]] - 2 * depth[lca], -1));
    }
    getRes(1, 0);
    for (int i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, res[i]);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF1070C Cloud Computing]]></title>
        <id>https://shaun118294191.github.io/post/cf1070c-cloud-computing/</id>
        <link href="https://shaun118294191.github.io/post/cf1070c-cloud-computing/">
        </link>
        <updated>2020-03-17T06:35:08.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1070C">题目链接</a></p>
<p>Buber公司决定连续 n 天云端租用 CPU ，每天需要 k 个 CPU</p>
<p>云端供应商提供 m 个租用计划，第 i 个计划有如下的特征：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>l</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>r</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">l_i, r_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示第 i 个计划从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>l</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">l_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 天开始到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>r</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">r_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 天结束。</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示第 i 个计划中每天最多租用CPU个数</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">p_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示第i 个计划租用一个CPU的花费。</li>
</ul>
<p>Buber 可以同时使用多个计划，即他可以在第 x 天在每个进行中的计划中租用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>0</mn><mo separator="true">,</mo><msub><mi>c</mi><mi>i</mi></msub><mo>]</mo></mrow><annotation encoding="application/x-tex">[0,c_i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 个 CPU。<br>
求最少花费。</p>
<p>每一天每个计划中CPU个数可以任意选，因此应优先选费用低的计划，经行区间修改。</p>
<pre><code class="language-cpp">struct node {
    int l, r, c, p;
    inline bool operator &lt; (const node &amp;other) const {
        return p &lt; other.p;
    }
}tariff[MAXN];
</code></pre>
<p>用 max 记录节点维护的区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi><mo>−</mo><mo>&gt;</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi><mo>−</mo><mo>&gt;</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[root-&gt;l, root-&gt;r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>中已购买CPU数的最大值，min 记录最小值:</p>
<ul>
<li>若 min &gt;= k，则直接 return。</li>
<li>否则若 max + c &lt;= k, 则区间增值c。</li>
<li>否则若 max == min, 则区间增值min(c, k - max)。</li>
<li>否则递归左右儿子修改。</li>
</ul>
<pre><code class="language-cpp">inline void change(int qL, int qR, int L, int R, Node root) {
    if (qL &lt;= L &amp;&amp; R &lt;= qR) {
        if (root-&gt;min &gt;= k) return;
        if (root-&gt;max + curC &lt;= k) {
            root-&gt;max += curC, root-&gt;min += curC, root-&gt;tag += curC;
            res += curC * curP * (R - L + 1);
            return;
        } else if (root-&gt;max == root-&gt;min){
            LL delta = min(curC, k - root-&gt;max);
            root-&gt;max += delta, root-&gt;min += delta, root-&gt;tag += delta;
            res += delta * curP * (R - L + 1);
            return;
        }
        if (L == R) return;
    }
    pushTag(L, R, root);
    int mid = (L + R) &gt;&gt; 1;
    if (qL &lt;= mid) change(qL, qR, L, mid, Lson);
    if (qR &gt; mid) change(qL, qR, mid + 1, R, Rson);
    update(root);
}
</code></pre>
<p>Code:</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
//cloud computing
constexpr int MAXN = 1e6 + 6;
using namespace std;
template &lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1; x = 0;
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
struct node {
    int l, r, c, p;
    inline bool operator &lt; (const node &amp;other) const {
        return p &lt; other.p;
    }
}tariff[MAXN];
using LL = long long;
struct segTree {
    segTree * lson, *rson;
    LL max, min, tag;
}Tree[MAXN &lt;&lt; 1];
using Node = segTree *;
#define Lson root-&gt;lson
#define Rson root-&gt;rson
int n, m, tot;
LL k, res, curC, curP;
inline void update(Node root) {
    root-&gt;max = max(Lson-&gt;max, Rson-&gt;max);
    root-&gt;min = min(Lson-&gt;min, Rson-&gt;min);
}
inline void build(int L, int R, Node root) {
    if (L == R) return;
    int mid = (L + R) &gt;&gt; 1;
    Lson = &amp;Tree[++tot], Rson = &amp;Tree[++tot];
    build(L, mid, Lson), build(mid + 1 ,R, Rson);
}
inline void pushTag(int L, int R, Node root) {
    if (!root-&gt;tag) return;
    Lson-&gt;tag += root-&gt;tag, Rson-&gt;tag += root-&gt;tag;
    Lson-&gt;max += root-&gt;tag, Rson-&gt;max += root-&gt;tag;
    Lson-&gt;min += root-&gt;tag, Rson-&gt;min += root-&gt;tag;
    root-&gt;tag = 0;
}
inline void change(int qL, int qR, int L, int R, Node root) {
    if (qL &lt;= L &amp;&amp; R &lt;= qR) {
        if (root-&gt;min &gt;= k) return;
        if (root-&gt;max + curC &lt;= k) {
            root-&gt;max += curC, root-&gt;min += curC, root-&gt;tag += curC;
            res += curC * curP * (R - L + 1);
            return;
        } else if (root-&gt;max == root-&gt;min){
            LL delta = min(curC, k - root-&gt;max);
            root-&gt;max += delta, root-&gt;min += delta, root-&gt;tag += delta;
            res += delta * curP * (R - L + 1);
            return;
        }
        if (L == R) return;
    }
    pushTag(L, R, root);
    int mid = (L + R) &gt;&gt; 1;
    if (qL &lt;= mid) change(qL, qR, L, mid, Lson);
    if (qR &gt; mid) change(qL, qR, mid + 1, R, Rson);
    update(root);
}
int main() {
    read(n), read(k), read(m);
    for (int i = 1; i &lt;= m; i++) {
        read(tariff[i].l), read(tariff[i].r);
        read(tariff[i].c), read(tariff[i].p);
    }
    sort(tariff + 1, tariff + m + 1);
    build(1, n, Tree);
    for (int i = 1; i &lt;= m; i++) {
        curC = tariff[i].c, curP = tariff[i].p;
        int l = tariff[i].l, r = tariff[i].r;
        change(l, r, 1, n, Tree);
    }
    cout &lt;&lt; res &lt;&lt; endl;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P4556 [Vani有约会]雨天的尾巴]]></title>
        <id>https://shaun118294191.github.io/post/p4556-vani-you-yue-hui-yu-tian-de-wei-ba/</id>
        <link href="https://shaun118294191.github.io/post/p4556-vani-you-yue-hui-yu-tian-de-wei-ba/">
        </link>
        <updated>2020-03-17T03:21:26.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4556">题目链接</a><br>
树上差分两种形式：</p>
<ul>
<li>
<p>将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(u, v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>间的边覆盖， 将u点的权值加1，v点的权值加1，节点LCA(u, v)的权值减2。对树进行深度优先遍历，求出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">f_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>为根的子树中各节点的权值和。则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">f_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>与其父亲节点间的树边的覆盖次数。</p>
</li>
<li>
<p>将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(u, v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>路径上的点覆盖，将u点的权值加1，v点的权值加1，LCA(u, v)的权值减1，fa[LCA(u, v)]的点权值减1。对树进行深度优先遍历，求出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">f_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>为根的子树中各节点的权值和。</p>
</li>
</ul>
<p>对于本题，节点修改可用树上差分实现。对于出现次数最多的z以及z的数值，可对每个点建立动态开点的权值线段树并在最后深度优先遍历时合并。</p>
<p>时间空间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mo>(</mo><mi>N</mi><mo>+</mo><mi>M</mi><mo>)</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo>(</mo><mi>N</mi><mo>+</mo><mi>M</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">O((N + M)log_2(N + M))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>。</p>
<p>为防止左右儿子为空，可将其指针默认为Tree[0]的地址。最后还是得开<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>∗</mo><mi>L</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo>∗</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">N * LogN * 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>的空间……</p>
<p>动态插入：</p>
<pre><code class="language-cpp">inline Node * newNode(Node * &amp;root) { 
	if (root == NULL || root == Tree) root = &amp;Tree[++tot], Lson = Rson = Tree;
	return root;
}
inline void insert(Node *root, int L, int R, int val, int delta) {
	if (L == R) {
		root-&gt;cnt += delta;
		root-&gt;pos = root-&gt;cnt ? L : 0;
		return;
	}
	int mid = (L + R) &gt;&gt; 1;
	if (val &lt;= mid) insert(newNode(Lson), L, mid, val, delta);
	else insert(newNode(Rson), mid + 1, R, val, delta);
	update(root);
}
</code></pre>
<p>合并：</p>
<pre><code class="language-cpp">inline Node * merge(Node *root, Node *pre, int L, int R) {
	if (root == NULL || root == Tree) return pre;
	if (pre == NULL || pre == Tree) return root;
	if (L == R) {
		root-&gt;cnt += pre-&gt;cnt;
		root-&gt;pos = root-&gt;cnt ? L : 0;
		return root;
	}
	int mid = (L + R) &gt;&gt; 1;
	Lson = merge(Lson, pre-&gt;lson, L, mid);
	Rson = merge(Rson, pre-&gt;rson, mid + 1, R);
	update(root);
	return root;
}
</code></pre>
<p>Code:</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
constexpr int MAXN = 1e5 + 5;
constexpr int LOG = 18;
using namespace std;
template &lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1; x = 0; 
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
struct Node {
	Node *lson, *rson;
	int cnt, pos;
}Tree[MAXN * LOG * 4], *root[MAXN];
#define Lson root-&gt;lson
#define Rson root-&gt;rson
vector&lt;vector&lt;int&gt; &gt; G;
int tot, n, m, f[MAXN][LOG], depth[MAXN], ans[MAXN];
inline Node * newNode(Node * &amp;root) { 
	if (root == NULL || root == Tree) root = &amp;Tree[++tot], Lson = Rson = Tree;
	return root;
}
inline void update(Node *root) {
	root-&gt;cnt = max(Lson-&gt;cnt, Rson-&gt;cnt);
	root-&gt;pos = (Lson-&gt;cnt &gt;= Rson-&gt;cnt) ? Lson-&gt;pos : Rson-&gt;pos;
}
inline void insert(Node *root, int L, int R, int val, int delta) {
	if (L == R) {
		root-&gt;cnt += delta;
		root-&gt;pos = root-&gt;cnt ? L : 0;
		return;
	}
	int mid = (L + R) &gt;&gt; 1;
	if (val &lt;= mid) insert(newNode(Lson), L, mid, val, delta);
	else insert(newNode(Rson), mid + 1, R, val, delta);
	update(root);
}
inline Node * merge(Node *root, Node *pre, int L, int R) {
	if (root == NULL || root == Tree) return pre;
	if (pre == NULL || pre == Tree) return root;
	if (L == R) {
		root-&gt;cnt += pre-&gt;cnt;
		root-&gt;pos = root-&gt;cnt ? L : 0;
		return root;
	}
	int mid = (L + R) &gt;&gt; 1;
	Lson = merge(Lson, pre-&gt;lson, L, mid);
	Rson = merge(Rson, pre-&gt;rson, mid + 1, R);
	update(root);
	return root;
}
inline void dfs(int cur, int fa) {
	depth[cur] = depth[fa] + 1, f[cur][0] = fa;
	for (int i = 1; i &lt; LOG; i++) f[cur][i] = f[f[cur][i - 1]][i - 1];
	for (auto to : G[cur]) {
		if (to == fa) continue;
		dfs(to, cur);
	}
}
inline void dfs2(int cur, int fa) {
	for (auto to : G[cur]) {
		if (to == fa) continue;
		dfs2(to, cur);
		root[cur] = merge(root[cur], root[to], 1, MAXN - 5);
	}
	ans[cur] = root[cur]-&gt;pos;
}
inline int LCA(int u, int v) {
	if (depth[u] &lt; depth[v]) swap(u, v);
	for (int i = LOG - 1; i &gt;= 0; i--)
		if (depth[f[u][i]] &gt;= depth[v]) u = f[u][i];
	if (u == v) return u;
	for (int i = LOG - 1; i &gt;= 0; i--)
		if (f[u][i] != f[v][i]) u = f[u][i], v = f[v][i];
	return f[u][0];
}
int main(){
	read(n), read(m), G.resize(n + 1);
	for (int i = 1, u, v; i &lt; n; i++) {
		read(u), read(v);
		G[u].push_back(v), G[v].push_back(u); 
	}
	for (int i = 0; i &lt;= n; i++) newNode(root[i]);
	dfs(1, 0); //建立有根树，LCA预处理
	for (int i = 1, u, v, z, lca; i &lt;= m; i++) {
		read(u), read(v), read(z), lca = LCA(u, v); //差分操作
		insert(root[u], 1, MAXN - 5, z, 1);
		insert(root[v], 1, MAXN - 5, z, 1);
		insert(root[lca], 1, MAXN - 5, z, -1);
		insert(root[f[lca][0]], 1, MAXN - 5, z, -1);
	}
	dfs2(1, 0); //遍历并合并线段树
	for (int i = 1; i &lt;= n; i++) printf(&quot;%d\n&quot;, ans[i]);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P2634 [国家集训队]聪聪可可]]></title>
        <id>https://shaun118294191.github.io/post/p2634-guo-jia-ji-xun-dui-cong-cong-ke-ke/</id>
        <link href="https://shaun118294191.github.io/post/p2634-guo-jia-ji-xun-dui-cong-cong-ke-ke/">
        </link>
        <updated>2020-03-15T13:34:45.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2634">题目链接</a></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
constexpr int MAXN = 2e4 + 4;
//长度 mod 3 = 0的点对数
using namespace std;
template &lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1; x = 0;
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
using A = int [MAXN];
A dp, sz, cntDis, vis, dis, vec, vecBig;
vector&lt; pair&lt;int, int&gt; &gt; G[MAXN];
int n, root, tot, res, cnt;
inline void getRoot(int cur, int fa) {
    sz[cur] = 1, dp[cur] = 0;
    for (auto &amp;e : G[cur]) {
        int to = e.first;
        if (vis[to] || fa == to) continue;
        getRoot(to, cur);
        sz[cur] += sz[to];
        dp[cur] = max(dp[cur], sz[to]);
    }
    dp[cur] = max(dp[cur], tot - sz[cur]);
    if (dp[cur] &lt; dp[root]) root = cur;
}
inline void getDis(int cur, int fa) {
    vec[cnt++] = dis[cur];
    for (auto &amp;e : G[cur]) {
        int to = e.first, w = e.second;
        if (vis[to] || fa == to) continue;
        dis[to] = (dis[cur] + w) % 3;
        getDis(to, cur);
    }
}
inline void calc(int cur) { //长度 mod 3 = 0的路径数
    int Cnt(0);
    for (auto &amp;e : G[cur]) {
        int to = e.first, w = e.second;
        if (vis[to]) continue;
        cnt = 0, dis[to] = w % 3, getDis(to, cur);
        for (int i = 0; i &lt; cnt; ++i) {
            res += cntDis[(3 - vec[i]) % 3];
            if (vec[i] % 3 == 0) ++res; //根为端点
        }
        for (int i = 0; i &lt; cnt; ++i)
            vecBig[Cnt++] = vec[i], ++cntDis[vec[i]];
    }
    for (int i = 0; i &lt; Cnt; ++i) cntDis[vecBig[i]] = 0;
}
inline void dfs(int cur) {
    vis[cur] = true, calc(cur);
    for (auto &amp;e : G[cur]) {
        int to = e.first;
        if (vis[to]) continue;
        root = cur, tot = dp[root] = sz[to];
        getRoot(to, root), dfs(root);
    }
}
int main() {
    freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
    read(n);
    for (int i = 1, u, v, w; i &lt; n; ++i) {
        read(u), read(v), read(w);
        G[u].emplace_back(make_pair(v, w));
        G[v].emplace_back(make_pair(u, w));
    }
    root = 0, tot = dp[root] = n;
    getRoot(1, root), dfs(root);
    res = res * 2 + n;
    int tmp = __gcd(res, n * n);
    cout &lt;&lt; res / tmp &lt;&lt; &quot;/&quot; &lt;&lt; n * n / tmp&lt;&lt; endl;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Rebuild Teldrassil]]></title>
        <id>https://shaun118294191.github.io/post/rebuild-teldrassil/</id>
        <link href="https://shaun118294191.github.io/post/rebuild-teldrassil/">
        </link>
        <updated>2020-03-15T05:57:49.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/T123576">题目链接(内部题目)</a></p>
<p>题意：有一棵树，每个点有权值，一条路径的中位数大于等于 x 时，认为这条路径是重要的，现在你可以改变一个节点的权值，求改变后最多可以新增加多少重要路径。</p>
<p>将所有小于x的点认为权值是 -1，大于等于x的点权值认为是 1，一条路径的和如果大于等于 0，则这条路径是重要的，修改一个点可以将这个点从 -1 改为 1 ，对于每一个 -1 的点，统计有多少条过该点的权值为 -1 or -2 的路径。</p>
<p>求出长度为 -1 或 -2 的路径数比较容易，但是本题要求经过某一点长度为 -1 或 -2 的路径数，不能简单地在子树中统计。</p>
<p>对于一条经过根的长度为k的路径， 若这条路径在某个子树中的终点为node , 则从node到根的节点都经过这条路径。</p>
<p>于是把以 node 为终点长度为 k 的路径数存在到add[node]数组，并累加到add[father[node]]中。过程如下：</p>
<p>先遍历所有子树求出cntDis[], 记录father (根节点答案需单独处理)。<br>
dfs:</p>
<pre><code class="language-cpp">inline void getDis(int cur, int fa) {
    add[cur] = 0;
    vec[cnt++] = make_pair(dis[cur], cur);
    for (auto &amp;to : G[cur]) {
        if (to == fa || vis[to]) continue;
        dis[to] = dis[cur] + w[to];
        father[to] = cur;
        getDis(to, cur);
    }
}
</code></pre>
<p>calc:</p>
<pre><code class="language-cpp">    for (auto &amp;to : G[cur]) {
        if (vis[to]) continue;
        cnt = 0, dis[to] = w[to], getDis(to, cur);
        for (int i = 0; i &lt; cnt; i++) {
            int d = vec[i].first;
            res[cur] += cntDis[-1 - w[cur] - d + ADD] + cntDis[-2 - w[cur] - d + ADD];
            if (d + w[cur] == -1 || d + w[cur] == -2) res[cur]++; //只经过根节点，不经过另一颗子树
        }
        for (int i = 0; i &lt; cnt; i++)
            vecBig[Cnt++] = vec[i], cntDis[vec[i].first + ADD]++; //保存已访问子树的结果
    }
</code></pre>
<p>再次遍历子树，减去cntDis, 求出add[], 再将cntDis加回。若node到根节点点权和(不过括w[root])为d，则add[node] += cntDis[-1 - d - w[root]] + cntDis[-2 - d - w[root]] + 到根节点距离为-1 or-2的路径数。<br>
calc:</p>
<pre><code class="language-cpp">    for (int i = 0; i &lt; cnt; i++) cntDis[vec[i].first + ADD]--;
    for (int i = cnt - 1; i &gt;= 0; i--) {
            int d = vec[i].first, node = vec[i].second;
            add[node] += cntDis[-1 - w[cur] - d + ADD] + cntDis[-2 - w[cur] - d + ADD];
            if (d + w[cur] == -1 || d + w[cur] == -2) add[node]++; //只经过根节点，不经过另一颗子树
            add[father[node]] += add[node];
            res[node] += add[node];
    }
    for (int i = 0; i &lt; cnt; i++) cntDis[vec[i].first + ADD]++;
</code></pre>
<p>Code(NlogN):</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
constexpr int MAXN = 4e5 + 4;
constexpr int ADD = 3e5 + 3;
using namespace std;
template &lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1; x = 0;
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
vector&lt;int&gt; G[MAXN];
int w[MAXN], dp[MAXN], sz[MAXN], father[MAXN];
long long res[MAXN], add[MAXN];
int vis[MAXN], dis[MAXN];
pair &lt;int, int&gt; vec[MAXN], vecBig[MAXN];
int n, x, tot, cnt, root;
int cntDis[MAXN &lt;&lt; 1], cntDis[MAXN &lt;&lt; 1];
inline void getRoot(int cur, int fa) {
    sz[cur] = 1, dp[cur] = 0;
    for (auto &amp;to : G[cur]) {
        if (to == fa || vis[to]) continue;
        getRoot(to, cur);
        sz[cur] += sz[to];
        dp[cur] = max(dp[cur], sz[to]);
    }
    dp[cur] = max(dp[cur], tot - sz[cur]);
    if (dp[cur] &lt; dp[root]) root = cur;
}
inline void getDis(int cur, int fa) {
    add[cur] = 0;
    vec[cnt++] = make_pair(dis[cur], cur);//, cntDis[dis[cur] + ADD]++;
    for (auto &amp;to : G[cur]) {
        if (to == fa || vis[to]) continue;
        dis[to] = dis[cur] + w[to];
        father[to] = cur;
        getDis(to, cur);
    }
}
inline void calc(int cur) {
    int Cnt(0);
    for (auto &amp;to : G[cur]) {
        if (vis[to]) continue;
        cnt = 0, dis[to] = w[to], getDis(to, cur);
        for (int i = 0; i &lt; cnt; i++) {
            int d = vec[i].first;
            res[cur] += cntDis[-1 - w[cur] - d + ADD] + cntDis[-2 - w[cur] - d + ADD];
            if (d + w[cur] == -1 || d + w[cur] == -2) res[cur]++;
        }
        for (int i = 0; i &lt; cnt; i++)
            vecBig[Cnt++] = vec[i], cntDis[vec[i].first + ADD]++; //保存已访问子树的结果
    }
    for (auto &amp;to : G[cur]) {
        if (vis[to]) continue;
        cnt = 0, dis[to] = w[to], getDis(to, cur);
        for (int i = 0; i &lt; cnt; i++) cntDis[vec[i].first + ADD]--;
        for (int i = cnt - 1; i &gt;= 0; i--) {
            int d = vec[i].first, node = vec[i].second;
            add[node] += cntDis[-1 - w[cur] - d + ADD] + cntDis[-2 - w[cur] - d + ADD];
            if (d + w[cur] == -1 || d + w[cur] == -2) add[node]++;
            add[father[node]] += add[node];
            res[node] += add[node];
        }
        for (int i = 0; i &lt; cnt; i++) cntDis[vec[i].first + ADD]++;
    }
    for (int i = 0; i &lt; Cnt; i++) cntDis[vecBig[i].first + ADD] = 0;
}
inline void dfs(int cur) {
    vis[cur] = true, calc(cur);
    for (auto &amp;to : G[cur]) {
        if (vis[to]) continue;
        root = cur, tot = dp[root] = sz[to];
        getRoot(to, root), dfs(root);
    }
}
int main() {
    read(n), read(x);
    for (int i = 1, u, v; i &lt; n; i++) {
        read(u), read(v);
        G[u].emplace_back(v), G[v].emplace_back(u);
    }
    for (int i = 1, tmp; i &lt;= n; i++)
        read(tmp), w[i] = tmp &gt;= x ? 1 : -1;
    root = 0, tot = dp[root] = n;
    getRoot(1, root), dfs(root);
    long long mx = 0;
    for (int i = 1; i &lt;= n; i++) 
        if (w[i] == -1) mx = max(mx, res[i]);
    cout &lt;&lt; mx &lt;&lt; endl;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF161D Distance in Tree]]></title>
        <id>https://shaun118294191.github.io/post/cf161d-distance-in-tree/</id>
        <link href="https://shaun118294191.github.io/post/cf161d-distance-in-tree/">
        </link>
        <updated>2020-03-13T03:26:15.000Z</updated>
        <content type="html"><![CDATA[<p>求数上长度恰好为 k 的路径数。</p>
<p>点分治即可(k较大或为负数时也可做)：对于当前 root 依次遍历子树，记录子树节点到根的路径长度以及相应的cntDis。访问下一棵子树时用已访问的cntDis更新答案即可。</p>
<pre><code class="language-cpp">inline void calc(int cur) {
    int Cnt(0);
    for (auto &amp;to : G[cur]) {
        if (vis[to]) continue;
        cnt = 0, dis[to] = 1, getDis(to, cur);
        for (int i = 0; i &lt; cnt; i++) {
            res += cntDis[k - vec[i]];
            if (vec[i] == k) res++; //子节点到根的路径
        }
        for (int i = 0; i &lt; cnt; i++)
            vecBig[Cnt++] = vec[i], cntDis[vec[i]]++;
    }
    for (int i = 0; i &lt; Cnt; i++) cntDis[vecBig[i]] = 0;
}
</code></pre>
<p>Code:</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
constexpr int MAXN = 5e4 + 4;
//CF161D Distance in Tree
using namespace std;
template &lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1; x = 0;
    char ch = getchar();
    while (!isdigit(ch)) ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
vector&lt;int&gt; G[MAXN];
int n, k, root, cnt, tot;
long long res;
using A = int [MAXN];
A dp, cntDis, vec, vecBig, sz, dis, vis;
inline void getRoot(int cur, int fa) {
    sz[cur] = 1, dp[cur] = 0;
    for (auto &amp;to : G[cur]) {
        if (vis[to] || fa == to) continue;
        getRoot(to, cur);
        sz[cur] += sz[to];
        dp[cur] = max(dp[cur], sz[to]);
    }
    dp[cur] = max(dp[cur], tot - sz[cur]);
    if (dp[cur] &lt; dp[root]) root = cur;
}
inline void getDis(int cur, int fa) {
    vec[cnt++] = dis[cur];
    for (auto &amp;to :G[cur]) {
        if (vis[to] || to == fa) continue;
        dis[to] = dis[cur] + 1;
        getDis(to, cur);
    }
}
inline void calc(int cur) {
    int Cnt(0);
    for (auto &amp;to : G[cur]) {
        if (vis[to]) continue;
        cnt = 0, dis[to] = 1, getDis(to, cur);
        for (int i = 0; i &lt; cnt; i++) {
            res += cntDis[k - vec[i]];
            if (vec[i] == k) res++; // //子节点到根的路径
        }
        for (int i = 0; i &lt; cnt; i++)
            vecBig[Cnt++] = vec[i], cntDis[vec[i]]++;
    }
    for (int i = 0; i &lt; Cnt; i++) cntDis[vecBig[i]] = 0;
}
inline void dfs(int cur) {
    vis[cur] = true, calc(cur);
    for (auto &amp;to : G[cur]) {
        if (vis[to]) continue;
        root = cur, tot = dp[root] = sz[to];
        getRoot(to, root), dfs(root);
    }
}
int main() {
    read(n), read(k);
    for (int i = 1, u, v; i &lt; n; i++) {
        read(u), read(v);
        G[u].emplace_back(v), G[v].emplace_back(u);
    }
    root = 0, tot = dp[root] = n;
    getRoot(1, root), dfs(root);
    cout &lt;&lt; res &lt;&lt; endl;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P3806 【模板】点分治1]]></title>
        <id>https://shaun118294191.github.io/post/p3806-mo-ban-dian-fen-zhi-1/</id>
        <link href="https://shaun118294191.github.io/post/p3806-mo-ban-dian-fen-zhi-1/">
        </link>
        <updated>2020-03-12T03:59:14.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3806">题目链接</a><br>
给定一棵有 n 个点的树。</p>
<p>询问树上距离为 k 的点对是否存在。</p>
<p>method:<br>
求出以root为根的子树中的cntDis[dis] (dis <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span></span></span></span> 1e7)。</p>
<p>则cntDis[dis] * cnt[k - dis]即为距离为k的点对数<br>
(统计完清0即可，不要memset; 对每个询问都点分治一次要超时; 也可在子树中一一统计)。</p>
<pre><code class="language-cpp">inline void calc(int cur, int w, int type) { //cur为有根树的根节点(重心) type为1表示加
    cnt = 0, dis[cur] = w, getDis(cur, 0);
    for (int j = 1; j &lt;= m; j++)
        for (int i = 0; i &lt; cnt; i++)
            if (vec[i] &lt;= query[j]) res[j] += type * cntDis[vec[i]] * cntDis[query[j] - vec[i]];
    for (int i = 0; i &lt; cnt; i++) cntDis[vec[i]] = false;
}
</code></pre>
<p>不合法的点对数在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>o</mi><msub><mi>n</mi><mrow><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">son_{root}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 中减去即可。<br>
<code>calc(to, w, -1); //容斥 减去儿子中的路径数 注意要加上w</code></p>
<p>Code:</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
constexpr int MAXN = 1e4 + 4;
using namespace std;
template&lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1; x = 0;
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
vector&lt; pair&lt;int, int&gt; &gt; G[MAXN];
int n, m, tot, cnt, root;
int sz[MAXN], dp[MAXN], vis[MAXN];
int query[MAXN], res[MAXN];
int vec[MAXN], dis[MAXN], cntDis[MAXN &lt;&lt; 10];
inline void getRoot(int cur, int fa) { //求树的重心 自上而下
    sz[cur] = 1, dp[cur] = 0;
    for (auto &amp;e : G[cur]) {
        int to = e.first, w = e.second;
        if (to == fa || vis[to]) continue;
        getRoot(to, cur);
        sz[cur] += sz[to];
        dp[cur] = max(dp[cur], sz[to]);
    }
    dp[cur] = max(dp[cur], tot - sz[cur]);
    if (dp[cur] &lt; dp[root]) root = cur;
}
inline void getDis(int cur, int fa) { //求出到根root的距离
    if (dis[cur] &lt;= 1e7) 
        vec[cnt++] = dis[cur], cntDis[dis[cur]]++;
    for (auto &amp;e : G[cur]) {
        int to = e.first, w = e.second;
        if (to == fa || vis[to]) continue;
        dis[to] = dis[cur] + w;
        getDis(to, cur);
    }
}
inline void calc(int cur, int w, int type) { //cur为有根树的根节点(重心) type为1表示加
    cnt = 0, dis[cur] = w, getDis(cur, 0);
    for (int j = 1; j &lt;= m; j++)
        for (int i = 0; i &lt; cnt; i++)
            if (vec[i] &lt;= query[j]) res[j] += type * cntDis[vec[i]] * cntDis[query[j] - vec[i]];
    for (int i = 0; i &lt; cnt; i++) cntDis[vec[i]] = false;
}
inline void dfs(int cur) {
    vis[cur] = true, calc(cur, 0, 1);
    for (auto &amp;e : G[cur]) {
        int to = e.first, w = e.second;
        if (vis[to]) continue;
        calc(to, w, -1); //容斥 减去儿子中的路径数 注意要加上w
        root = cur, tot = dp[root] = sz[to]; //准备重新选择根节点
        getRoot(to, root), dfs(root);
    }
}
int main() {
    read(n), read(m);
    for (int i = 1, u, v, w; i &lt; n; i++) {
        read(u), read(v), read(w);
        G[u].emplace_back(make_pair(v, w)), G[v].emplace_back(make_pair(u, w));
    }
    for (int i = 1; i &lt;= m; i++) read(query[i]);
    root = 0, tot = dp[root] = n;
    getRoot(1, root), dfs(root);
    for (int i = 1; i &lt;= m; i++)
        res[i] &gt; 0 ? puts(&quot;AYE&quot;) : puts(&quot;NAY&quot;);
    return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>