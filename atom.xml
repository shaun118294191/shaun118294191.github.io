<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://shaun118294191.github.io</id>
    <title>Shaun</title>
    <updated>2020-03-03T11:34:17.550Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://shaun118294191.github.io"/>
    <link rel="self" href="https://shaun118294191.github.io/atom.xml"/>
    <subtitle>Valar morghulis Valar Dohaeris</subtitle>
    <logo>https://shaun118294191.github.io/images/avatar.png</logo>
    <icon>https://shaun118294191.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Shaun</rights>
    <entry>
        <title type="html"><![CDATA[P3258 [JLOI2014]æ¾é¼ çš„æ–°å®¶]]></title>
        <id>https://shaun118294191.github.io/post/p3258-jloi2014song-shu-de-xin-jia/</id>
        <link href="https://shaun118294191.github.io/post/p3258-jloi2014song-shu-de-xin-jia/">
        </link>
        <updated>2020-03-03T11:27:21.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3258">é¢˜ç›®é“¾æ¥</a><br>
æœ¬é¢˜æ ‘ä¸Šå·®åˆ†è§£å†³å³å¯ã€‚</p>
<p>å¯¹äºæˆ¿é—´<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>â€¦</mo><msub><mi>a</mi><mrow><mi>n</mi><mo>âˆ’</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_1â€¦a_{n - 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">â€¦</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">âˆ’</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>ï¼Œå°†<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>åˆ°<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_{i + 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>è·¯å¾„ä¸Šçš„ç‚¹è¦†ç›–ã€‚</p>
<p>ç”±äºè¿™æ ·ä¼šä½¿<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>2</mn></msub><mo>â€¦</mo><msub><mi>a</mi><mrow><mi>n</mi><mo>âˆ’</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_2â€¦a_{n - 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">â€¦</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">âˆ’</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>éƒ½è¢«å¤šè¦†ç›–ä¸€æ¬¡ï¼Œè€Œé¢˜ç›®è¯´<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>ä¸éœ€è¦å†åŠ 1ï¼Œæ‰€ä»¥<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>2</mn></msub><mo>â€¦</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_2â€¦a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">â€¦</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>çš„è®¿é—®æ¬¡æ•°å‡1å³å¯ã€‚</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
constexpr int MAXN = 3e5 + 5;
constexpr int LOG = 19;
using namespace std;
template &lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1; x = 0; 
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
vector&lt;int&gt; G[MAXN];
int n, path[MAXN], f[MAXN][LOG], depth[MAXN], delta[MAXN];
inline void dfs(int cur, int fa) {
	depth[cur] = depth[fa] + 1, f[cur][0] = fa;
	for (int i = 1; i &lt; LOG; i++) f[cur][i] = f[f[cur][i - 1]][i - 1];
	for (auto to : G[cur]) {
		if (to == fa) continue;
		dfs(to, cur);
	}
}
inline void getCnt(int cur, int fa) {
	for (auto to : G[cur]) {
		if (to == fa) continue;
		getCnt(to, cur);
		delta[cur] += delta[to];
	}
}
inline int LCA(int u, int v) {
	if (depth[u] &lt; depth[v]) swap(u, v);
	for (int i = LOG - 1; i &gt;= 0; i--) 
		if (depth[f[u][i]] &gt;= depth[v])
			u = f[u][i];
	if (u == v) return u;
	for (int i = LOG - 1; i &gt;= 0; i--) 
		if (f[u][i] != f[v][i])
			u = f[u][i], v = f[v][i];
	return f[u][0];
}
signed main(){
	read(n);
	for (int i = 1; i &lt;= n; i++) read(path[i]);
	for (int i = 1, u, v; i &lt; n; i++) {
		read(u), read(v);
		G[u].emplace_back(v), G[v].push_back(u);
	}
	dfs(1, 0);
	for (int i = 1; i &lt; n; i++) {
		int from = path[i], to = path[i + 1], lca = LCA(to, from);
		delta[from]++, delta[to]++, delta[lca]--, delta[f[lca][0]]--;
	}
	getCnt(1, 0);
	for (int i = 2; i &lt;= n; i++) delta[path[i]]--;
	for (int i = 1; i &lt;= n; i++) printf(&quot;%d\n&quot;, delta[i]);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P3369 ã€æ¨¡æ¿ã€‘æ™®é€šå¹³è¡¡æ ‘(æ•°ç»„)]]></title>
        <id>https://shaun118294191.github.io/post/p3369-mo-ban-pu-tong-ping-heng-shu-shu-zu/</id>
        <link href="https://shaun118294191.github.io/post/p3369-mo-ban-pu-tong-ping-heng-shu-shu-zu/">
        </link>
        <updated>2020-03-02T13:39:48.000Z</updated>
        <content type="html"><![CDATA[<p>æ‚¨éœ€è¦å†™ä¸€ç§æ•°æ®ç»“æ„ï¼Œæ¥ç»´æŠ¤ä¸€äº›æ•°ï¼Œå…¶ä¸­éœ€è¦æä¾›ä»¥ä¸‹æ“ä½œï¼š</p>
<p>1.æ’å…¥ x æ•°</p>
<p>2.åˆ é™¤ x æ•°(è‹¥æœ‰å¤šä¸ªç›¸åŒçš„æ•°ï¼Œå› åªåˆ é™¤ä¸€ä¸ª)</p>
<p>3.æŸ¥è¯¢ x æ•°çš„æ’å(æ’åå®šä¹‰ä¸ºæ¯”å½“å‰æ•°å°çš„æ•°çš„ä¸ªæ•° +1)</p>
<p>4.æŸ¥è¯¢æ’åä¸º x çš„æ•°</p>
<p>5.æ±‚ x çš„å‰é©±(å‰é©±å®šä¹‰ä¸ºå°äº xï¼Œä¸”æœ€å¤§çš„æ•°)</p>
<p>6.æ±‚ x çš„åç»§(åç»§å®šä¹‰ä¸ºå¤§äº xï¼Œä¸”æœ€å°çš„æ•°)</p>
<p>Treap:</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 1e6 + 6;
const int Inf = 1 &lt;&lt; 30;
struct Treap{
    int Lson, Rson;
    int val, dat;
    int cnt, size;
}Tree[MAXN];
#define Lnode Tree[node].Lson
#define Rnode Tree[node].Rson
int tot, root, n;
inline int New(int val){
    Tree[++tot].val = val;
    Tree[tot].dat = rand();
    Tree[tot].cnt = Tree[tot].size = 1; 
    return tot;
}
inline void update(int node){
    Tree[node].size = Tree[Lnode].size + Tree[Rnode].size + Tree[node].cnt;
}
inline void build(){
    New(-Inf), New(Inf);
    root = 1, Tree[root].Rson = 2; 
    update(root);
}
inline int GetRankByVal(int node, int val) {
	if (node == 0) return 0;
	if (val == Tree[node].val) return Tree[Lnode].size + 1;
	if (val &lt; Tree[node].val) return GetRankByVal(Lnode, val);
	return GetRankByVal(Rnode, val) + Tree[Lnode].size + Tree[node].cnt;
}
inline int GetValByRank(int node, int rank) {
	if (node == 0) return Inf;
	if (Tree[Lnode].size &gt;= rank) return GetValByRank(Lnode, rank);
	if (Tree[Lnode].size + Tree[node].cnt &gt;= rank) return Tree[node].val;
	return GetValByRank(Rnode, rank - Tree[Lnode].size - Tree[node].cnt);
}
inline void zig(int &amp;node){
    int p = Lnode;
    Lnode = Tree[p].Rson, Tree[p].Rson = node, node = p; //è¯¥èŠ‚ç‚¹å˜ä¸ºå·¦å„¿å­çš„å³å„¿å­
    update(Rnode), update(node);
}
inline void zag(int &amp;node){
    int p = Rnode;
    Rnode = Tree[p].Lson, Tree[p].Lson = node, node = p; //è¯¥èŠ‚ç‚¹å˜ä¸ºå³å„¿å­çš„å·¦å„¿å­
    update(Lnode), update(node);
}
inline void insert(int &amp;node, int val){
    if(node == 0){
        node = New(val);
        return;
    }
    if(val == Tree[node].val){
        Tree[node].cnt++;
        update(node);  //æ’å…¥åæ›´æ–°
        return;
    }
    if(val &lt; Tree[node].val){
        insert(Lnode, val);
        if(Tree[node].dat &lt; Tree[Lnode].dat) zig(node); // ä¸æ»¡è¶³å †æ€§è´¨ï¼Œå³æ—‹
    }
    else{
        insert(Rnode, val);
        if(Tree[node].dat &lt; Tree[Rnode].dat) zag(node); // ä¸æ»¡è¶³å †æ€§è´¨ï¼Œå·¦æ—‹
    }
    update(node);
}
inline int GetPre(int val){
	int pre = 1; // Tree[1].val == -INF
	int node = root;
	while(node){
		if(val == Tree[node].val){
			if(Lnode &gt; 0){
			    node = Lnode;
				while(Rnode &gt; 0) node = Rnode; // å·¦å­æ ‘ä¸Šä¸€ç›´å‘å³èµ°
				pre = node;
			}
			break;
		}
        //æ¯ç»è¿‡ä¸€ä¸ªç»“ç‚¹ å°è¯•æ›´æ–°å‰é©±
		if(Tree[node].val &lt; val &amp;&amp; Tree[node].val &gt; Tree[pre].val) pre = node;
		node = val &lt; Tree[node].val ? Lnode : Rnode;
	}
	return Tree[pre].val;
}
inline int GetNext(int val){
	int nxt = 2; // Tree[2].val == INF
	int node = root;
	while(node){
		if(val == Tree[node].val){
			if(Rnode &gt; 0){
			    node = Rnode;
				while(Lnode &gt; 0) node = Lnode; // å³å­æ ‘ä¸Šä¸€ç›´å‘å·¦èµ°
				nxt = node;
			}
			break;
		}
        //æ¯ç»è¿‡ä¸€ä¸ªç»“ç‚¹ å°è¯•æ›´æ–°åç»§ 
		if(Tree[node].val &gt; val &amp;&amp; Tree[node].val &lt; Tree[nxt].val) nxt = node;
		node = val &lt; Tree[node].val ? Lnode : Rnode;
	}
	return Tree[nxt].val;
}
inline void Remove(int &amp;node, int val){
	if (node == 0) return;
	if (val == Tree[node].val) { // æ£€ç´¢åˆ°äº†val
		if (Tree[node].cnt &gt; 1) { // æœ‰é‡å¤ï¼Œå‡å°‘å‰¯æœ¬æ•°å³å¯
			Tree[node].cnt--;
            update(node);
			return;
		}
		if(Lnode || Rnode){ // ä¸æ˜¯å¶å­èŠ‚ç‚¹ï¼Œå‘ä¸‹æ—‹è½¬
			if (Rnode == 0 || Tree[Lnode].dat &gt; Tree[Rnode].dat)
				zig(node), Remove(Rnode, val);
			else
				zag(node), Remove(Lnode, val);
			update(node);
		} else node = 0; // å¶å­èŠ‚ç‚¹ï¼Œåˆ é™¤
		return;
	}
	val &lt; Tree[node].val ? Remove(Lnode, val) : Remove(Rnode, val);
	update(node);
}
int main() {
	//srand(time(0));
	build();
	cin &gt;&gt; n;
	while (n--) {
		int opt, x;
		scanf(&quot;%d%d&quot;, &amp;opt, &amp;x);
		switch (opt) {
		case 1:
			insert(root, x);
			break;
		case 2:
			Remove(root, x);
			break;
		case 3:
			printf(&quot;%d\n&quot;, GetRankByVal(root, x) - 1);
			break;
		case 4:
			printf(&quot;%d\n&quot;, GetValByRank(root, x + 1));
			break;
		case 5:
			printf(&quot;%d\n&quot;, GetPre(x));
			break;
		case 6:
			printf(&quot;%d\n&quot;, GetNext(x));
			break;
		}
	}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P3369 ã€æ¨¡æ¿ã€‘æ™®é€šå¹³è¡¡æ ‘(æŒ‡é’ˆå®ç°)]]></title>
        <id>https://shaun118294191.github.io/post/p3369-mo-ban-pu-tong-ping-heng-shu-zhi-zhen-shi-xian/</id>
        <link href="https://shaun118294191.github.io/post/p3369-mo-ban-pu-tong-ping-heng-shu-zhi-zhen-shi-xian/">
        </link>
        <updated>2020-03-02T13:37:45.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3369">é¢˜ç›®é“¾æ¥</a><br>
æ‚¨éœ€è¦å†™ä¸€ç§æ•°æ®ç»“æ„ï¼Œæ¥ç»´æŠ¤ä¸€äº›æ•°ï¼Œå…¶ä¸­éœ€è¦æä¾›ä»¥ä¸‹æ“ä½œï¼š</p>
<p>1.æ’å…¥ x æ•°</p>
<p>2.åˆ é™¤ x æ•°(è‹¥æœ‰å¤šä¸ªç›¸åŒçš„æ•°ï¼Œå› åªåˆ é™¤ä¸€ä¸ª)</p>
<p>3.æŸ¥è¯¢ x æ•°çš„æ’å(æ’åå®šä¹‰ä¸ºæ¯”å½“å‰æ•°å°çš„æ•°çš„ä¸ªæ•° +1)</p>
<p>4.æŸ¥è¯¢æ’åä¸º x çš„æ•°</p>
<p>5.æ±‚ x çš„å‰é©±(å‰é©±å®šä¹‰ä¸ºå°äº xï¼Œä¸”æœ€å¤§çš„æ•°)</p>
<p>6.æ±‚ x çš„åç»§(åç»§å®šä¹‰ä¸ºå¤§äº xï¼Œä¸”æœ€å°çš„æ•°)</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
constexpr int MAXN = 1e5 + 5;
constexpr int Inf = 0x3f3f3f3f;
using namespace std;
template &lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1; x = 0; 
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
struct Treap {
	Treap *lson, *rson;
	int key, priority;
	int cnt, size;
}Tree[MAXN &lt;&lt; 1], *rt;
#define Lson root-&gt;lson
#define Rson root-&gt;rson
int tot, Q, type, x;
inline void newNode(Treap *&amp;root, int key) {
	root = &amp;Tree[tot++];
	root-&gt;cnt = root-&gt;size = 1;
	root-&gt;key = key, root-&gt;priority = rand();
}
inline void update(Treap *root) {
	if (root == NULL) return; //ç©ºæŒ‡é’ˆç›´æ¥return
	int Lsize = (Lson == NULL) ? 0 : Lson-&gt;size, Rsize = (Rson == NULL) ? 0 : Rson-&gt;size;
	root-&gt;size = Lsize + Rsize + root-&gt;cnt;
}
inline void Lrotate(Treap *&amp;root) { //å·¦æ—‹
	Treap *R = Rson;
	Rson = R-&gt;lson, R-&gt;lson = root, root = R;
	update(root-&gt;lson), update(root);
}
inline void Rrotate(Treap *&amp;root) { //å³æ—‹
	Treap *L = Lson;
	Lson = L-&gt;rson, L-&gt;rson = root, root = L;
	update(root-&gt;rson), update(root);
}
inline int getPre(Treap *root, int key, int pre) {
	if (root == NULL) return pre;
	if (key &lt;= root-&gt;key) return getPre(Lson, key, pre);
	return getPre(Rson, key, max(pre, root-&gt;key));
}
inline int getNext(Treap *root, int key, int next) {
	if (root == NULL) return next;
	if (key &gt;= root-&gt;key) return getNext(Rson, key, next);
	return getNext(Lson, key, min(next, root-&gt;key));
}
inline int getRank(Treap *root, int key) {
	if (root == NULL) return 0;
	int Lsize = Lson == NULL ? 0 : Lson-&gt;size; //å·¦å„¿å­æœ‰å¤šå°‘æ•°
	if (key == root-&gt;key) return Lsize + 1; 
	if (key &lt; root-&gt;key) return getRank(Lson, key);
	return getRank(Rson, key) + Lsize + root-&gt;cnt;
}
inline int getVal(Treap *root, int rank) {
	if (root == NULL) return Inf; 
	int Lsize = Lson == NULL ? 0 : Lson-&gt;size; //å·¦å„¿å­æœ‰å¤šå°‘æ•°
	if (Lsize &gt;= rank) return getVal(Lson, rank); 
	if (Lsize + root-&gt;cnt &gt;= rank) return root-&gt;key;
	return getVal(Rson, rank - Lsize - root-&gt;cnt);
}
inline void insert(Treap *&amp;root, int key) {
	if (root == NULL) { //ä¸å­˜åœ¨è¯¥key æ–°å»ºèŠ‚ç‚¹
		newNode(root, key);
		return;
	}
	if (key == root-&gt;key) root-&gt;cnt++, update(root); //å·²å­˜åœ¨key cnt++, update
	else if (key &lt; root-&gt;key) { //æœç´¢å·¦å„¿å­
		insert(Lson, key);
		if (root-&gt;priority &lt; Lson-&gt;priority) Rrotate(root);
	} else {
		insert(Rson, key); //æœç´¢å³å„¿å­
		if (root-&gt;priority &lt; Rson-&gt;priority) Lrotate(root);
	}
	update(root);
}
inline void remove(Treap *&amp;root, int key) {
	if (root == NULL) return;
	if (key == root-&gt;key) {
		if (root-&gt;cnt &gt; 1) root-&gt;cnt--; //å‰¯æœ¬å‡å°‘1
		else if (root-&gt;rson == NULL) root = root-&gt;lson; //å³å„¿å­ä¸ºç©º è¯¥ç‚¹åœ°å€å˜ä¸ºå·¦å„¿å­çš„
		else if (root-&gt;lson == NULL) root = root-&gt;rson; //å·¦å„¿å­ä¸ºç©º è¯¥ç‚¹åœ°å€å˜ä¸ºå³å„¿å­çš„
		else { //æ ¹æ®priorityå°†è¯¥èŠ‚ç‚¹æ—‹è½¬è‡³æ ¹ æ³¨æ„rootå¯èƒ½æ—‹ä¸ºNULL
			if (Lson-&gt;priority &gt; Rson-&gt;priority) Rrotate(root), remove(Rson, key);
			else Lrotate(root), remove(Lson, key);
		}
	} else key &lt; root-&gt;key ? remove(Lson, key) : remove(Rson, key); //æŸ¥æ‰¾å·¦å³å„¿å­
	update(root);
}
int main(){
	srand(time(0));
	read(Q);
    while (Q--) {
        read(type), read(x);
        switch (type) {
            case 1:
                insert(rt, x);
                break;
            case 2:
                remove(rt, x);
                break;
            case 3:
                printf(&quot;%d\n&quot;, getRank(rt, x));
                break;
            case 4:
                printf(&quot;%d\n&quot;, getVal(rt, x));
                break;
            case 5:
                printf(&quot;%d\n&quot;, getPre(rt, x, -Inf));
                break;
            case 6:
                printf(&quot;%d\n&quot;, getNext(rt, x, Inf));
                break;
        }
    }
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[T122393 Ã€ la VolontÃ© du Peuple]]></title>
        <id>https://shaun118294191.github.io/post/t122393-a-la-volonte-du-peuple/</id>
        <link href="https://shaun118294191.github.io/post/t122393-a-la-volonte-du-peuple/">
        </link>
        <updated>2020-03-02T02:32:08.000Z</updated>
        <content type="html"><![CDATA[<p>é¢˜ç›®æè¿°ï¼š<br>
A solitary spark can start a prairie fire.</p>
<p>You are given a weighted connected undirected graph with nn vertices and mm edges. You know that someone light up a fire at vertex 1, which will burn the current position into dust immediately and expand to adjacent places at the speed 1 mile per second. The fire will split at the vertices to all those edges who have not been lighten up, and will cause a blast when at least two fires meet at the same point.</p>
<p>Revolutionaries love explosions. They want you to count the number of explosions that will happen on the graph.</p>
<p>It's guaranteed that the graph is connected.<br>
<img src="https://shaun118294191.github.io/post-images/1583116803542.png" alt="" loading="lazy"></p>
<p>The graph may contain self loops and multiple edges. Example 1shows the method to deal with them.</p>
<p>The size of input file may be large. Please, do not read input by too slow ways.<br>
INPUT:<br>
2 3<br>
1 1 1<br>
1 2 1<br>
1 2 1<br>
OUTPUT:<br>
2</p>
<p>INPUT:<br>
4 5<br>
1 2 1<br>
1 3 1<br>
2 3 1<br>
2 4 1<br>
3 4 1<br>
OUTPUT:<br>
2<br>
<img src="https://shaun118294191.github.io/post-images/1583116672068.png" alt="" loading="lazy"></p>
<p>å…ˆæ±‚å‡ºæœ€çŸ­è·¯ï¼Œå¦‚æœä¸€ä¸ªç‚¹çš„æœ€çŸ­è·¯å‰é©± &gt;= 2ï¼Œåˆ™è¯¥ç‚¹èƒ½äº§ç”Ÿblastï¼›å¯¹äºä¸åœ¨æœ€çŸ­è·¯ä¸Šçš„è¾¹ï¼Œè‹¥<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">âˆ£</mi><mo>(</mo><mi>d</mi><mi>i</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>âˆ’</mo><mi>d</mi><mi>i</mi><mi>s</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>)</mo><mi mathvariant="normal">âˆ£</mi><mo>&lt;</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">|(dis[i] - dis[j])| &lt; w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">âˆ£</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">âˆ’</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mclose">)</span><span class="mord">âˆ£</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>åˆ™ä¹Ÿä¼šäº§ç”Ÿblast(æ³¨æ„åè¾¹ä¸è¦å†åŠ )ã€‚</p>
<pre><code class="language-cpp">for (int cur = 2; cur &lt;= n; cur++) {
	int cnt = 0;
	for(int i = head[cur]; ~i; i = Edge[i].next) {
		int to = Edge[i].to, w = Edge[i].w;
		if (dis[cur] == dis[to] + w) cnt++;
		else if (cur &gt;= to &amp;&amp; abs(dis[to] - dis[cur]) &lt; w) sum++;
	}
    if (cnt &gt; 1) sum++;
}
</code></pre>
<p>Code:</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long 
#define pii pair&lt;int, int&gt; 
constexpr int MAXN = 5e5 + 5;
using namespace std;
template &lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1; x = 0; 
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
struct node {
	int to, w, next;
	node(){}
	node(int _to, int _w, int _next) : to(_to), w(_w), next(_next) {}
}Edge[MAXN &lt;&lt; 3];
int head[MAXN], tot, n, m, sum, cnt[MAXN], vis[MAXN], dis[MAXN], depth[MAXN];
int u[MAXN], v[MAXN], w[MAXN];
inline void add (int from, int to, int w) {
	Edge[tot] = node(to, w, head[from]), head[from] = tot++;
	Edge[tot] = node(from, w, head[to]), head[to] = tot++;
}
inline void dijkstra(){
	memset(dis, 0x3f, sizeof(dis)), cnt[1] = 0;
    priority_queue&lt; pii , vector&lt;pii&gt; , greater&lt;pii&gt; &gt; q;
    q.push({dis[1] = 0, 1});
    while(!q.empty()){
        int cur = q.top().second;
        q.pop();
        if(vis[cur]) continue;
        for(int i = head[cur]; ~i; i = Edge[i].next){
            int go = Edge[i].to, w = Edge[i].w;
            if(dis[go] &gt; dis[cur] + w){
                dis[go] = dis[cur] + w;
                q.push({dis[go], go});
            } 
        } 
        vis[cur] = 1;
    }
}
signed main(){
	read(n), read(m);
	memset(head, -1, sizeof(head));
	for (int i = 1; i &lt;= m; i++) {
		read(u[i]), read(v[i]), read(w[i]);
		if (u[i] == v[i]) sum++;
		else add(u[i], v[i], w[i]);
	}
	dijkstra();
	for (int cur = 2; cur &lt;= n; cur++) {
		int cnt = 0;
		for(int i = head[cur]; ~i; i = Edge[i].next) {
			int to = Edge[i].to, w = Edge[i].w;
			if (dis[cur] == dis[to] + w) cnt++;
			else if (cur &gt;= to &amp;&amp; abs(dis[to] - dis[cur]) &lt; w) sum++;
		}
		if (cnt &gt; 1) sum++;
	}
	cout &lt;&lt; sum &lt;&lt; endl;
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P3605 [USACO17JAN]Promotion Counting P]]></title>
        <id>https://shaun118294191.github.io/post/p3605-usaco17janpromotion-counting-p/</id>
        <link href="https://shaun118294191.github.io/post/p3605-usaco17janpromotion-counting-p/">
        </link>
        <updated>2020-03-01T06:24:30.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3605">é¢˜ç›®é“¾æ¥</a></p>
<p>ä¸€é¢—nä¸ªèŠ‚ç‚¹çš„æ ‘ï¼Œæ¯ä¸ªèŠ‚ç‚¹æœ‰ä¸€ä¸ªç‚¹æƒå€¼ã€‚æ±‚èŠ‚ç‚¹<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>çš„å­æ ‘ä¸­æ¯”å…¶æƒå€¼å¤§çš„èŠ‚ç‚¹çš„ä¸ªæ•°ã€‚</p>
<p>ç¦»æ•£åŒ–åå¯¹äºæ¯ä¸ªç‚¹å»ºç«‹ä¸€ä¸ªåŠ¨æ€å¼€ç‚¹çš„æƒå€¼çº¿æ®µæ ‘ï¼Œè®°å½•cntã€‚</p>
<pre><code class="language-cpp">inline Node * newNode(Node * &amp;root) { 
	if (root == NULL) root = &amp;Tree[++tot];
	return root;
}
for (int i = 1; i &lt;= n; i++) 
		newNode(root[i]), insert(root[i], 1, cnt, Map[val[i]]);
inline void insert(Node *root, int L, int R, int val) {
	if (L == R) {
		root-&gt;cnt++;
		return;
	}
	int mid = (L + R) &gt;&gt; 1;
	if (val &lt;= mid) insert(newNode(Lson), L, mid, val);
	else insert(newNode(Rson), mid + 1, R, val);
	update(root);
}
</code></pre>
<p>dfsæ—¶è‡ªåº•å‘ä¸Šåˆå¹¶æŸ¥è¯¢ï¼š</p>
<pre><code class="language-cpp">inline void dfs(int cur) {
	for (auto to : G[cur]) {
		dfs(to);
		merge(root[cur], root[to], 1, cnt);
	}
	ans[cur] = query(root[cur], 1, cnt, Map[val[cur]] + 1, cnt);
}
</code></pre>
<p>Code:</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
constexpr int MAXN = 1e5 + 1;
constexpr int LOG = 17;
using namespace std;
template &lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1; x = 0; 
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
struct Node {
	Node *lson, *rson;
	int cnt;
}Tree[MAXN * LOG * 4], *root[MAXN];
#define Lson root-&gt;lson
#define Rson root-&gt;rson
vector&lt;int&gt; G[MAXN];
int tot, n, ans[MAXN], val[MAXN], cnt, cpy[MAXN];
unordered_map&lt;int, int&gt; Map;
inline void discretization() {
	sort(cpy + 1, cpy + n + 1);
	cnt = unique(cpy + 1, cpy + n + 1) - cpy - 1;
	for (int i = 1; i &lt;= cnt; i++) Map[cpy[i]] = i;
}
inline Node * newNode(Node * &amp;root) { 
	if (root == NULL) root = &amp;Tree[++tot];
	return root;
}
inline void update(Node *root) {
    int Lcnt = Lson == NULL ? 0 : Lson-&gt;cnt, Rcnt = Rson == NULL ? 0 : Rson-&gt;cnt;
	root-&gt;cnt = Lcnt + Rcnt;
}
inline void insert(Node *root, int L, int R, int val) {
	if (L == R) {
		root-&gt;cnt++;
		return;
	}
	int mid = (L + R) &gt;&gt; 1;
	if (val &lt;= mid) insert(newNode(Lson), L, mid, val);
	else insert(newNode(Rson), mid + 1, R, val);
	update(root);
}
inline void merge(Node *&amp;root, Node *p, int L, int R) {
	if (root == NULL) {root = p; return;}
	if (p == NULL) return;
	if (L == R) {
		root-&gt;cnt += p-&gt;cnt;
        return;
	}
	int mid = (L + R) &gt;&gt; 1;
	merge(Lson, p-&gt;lson, L, mid);
	merge(Rson, p-&gt;rson, mid + 1, R);
	update(root);
}
inline int query(Node *root, int L, int R, int qL, int qR) {
	if (root == NULL) return 0;
	if (qL &lt;= L &amp;&amp; R &lt;= qR) 
		return root-&gt;cnt;
	int mid = (L + R) &gt;&gt; 1, res = 0;
	if (qL &lt;= mid) res += query(Lson, L, mid, qL, qR);
	if (qR &gt; mid) res += query(Rson, mid + 1 ,R, qL, qR);
	return res;
}
inline void dfs(int cur) {
	for (auto to : G[cur]) {
		dfs(to);
		merge(root[cur], root[to], 1, cnt);
	}
	ans[cur] = query(root[cur], 1, cnt, Map[val[cur]] + 1, cnt);
}
int main(){
	read(n);
	for (int i = 1; i &lt;= n; i++) read(val[i]), cpy[i] = val[i];
	discretization();
	for (int i = 1; i &lt;= n; i++) 
		newNode(root[i]), insert(root[i], 1, cnt, Map[val[i]]);
	for (int i = 2, fa; i &lt;= n; i++) 
		cin &gt;&gt; fa, G[fa].emplace_back(i);
	dfs(1);
	for (int i = 1; i &lt;= n; i++) printf(&quot;%d\n&quot;, ans[i]);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P2168 [NOI2015]è·é©¬å²è¯—]]></title>
        <id>https://shaun118294191.github.io/post/p2168-noi2015he-ma-shi-shi/</id>
        <link href="https://shaun118294191.github.io/post/p2168-noi2015he-ma-shi-shi/">
        </link>
        <updated>2020-03-01T05:13:56.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2168">é¢˜ç›®é“¾æ¥</a><br>
å“ˆå¤«æ›¼æ ‘ä¹Ÿå«æœ€ä¼˜äºŒå‰æ ‘ï¼Œæ˜¯ä¸€ç§å¸¦æƒè·¯å¾„ï¼ˆå¶å­èŠ‚ç‚¹æƒå€¼ä¹˜è¯¥èŠ‚ç‚¹åˆ°æ ¹èŠ‚ç‚¹è·¯å¾„é•¿åº¦ï¼‰ä¹‹å’Œæœ€çŸ­çš„äºŒå‰æ ‘ã€‚é€šè¿‡å“ˆå¤«æ›¼æ ‘å¯ä»¥æ„é€ å‡ºå“ˆå¤«æ›¼ç¼–ç ï¼Œå¯ä»¥ç”¨äºæ•°æ®å‹ç¼©å’Œæ•°æ®åŠ å¯†ã€‚</p>
<p>å“ˆå¤«æ›¼ç¼–ç çš„åŸç†æ˜¯ï¼Œåˆ©ç”¨å“ˆå¤«æ›¼æ ‘ä¸­æƒå€¼è¶Šé«˜ï¼ˆæ•°æ®å‡ºç°é¢‘ç‡è¶Šé«˜ï¼‰çš„èŠ‚ç‚¹åˆ°æ ¹èŠ‚ç‚¹çš„è·ç¦»è¶Šå°ï¼ˆå¯¹åº”å“ˆå¤«æ›¼ç¼–ç è¶ŠçŸ­ï¼‰çš„æ€§è´¨ï¼Œå°†æ•°æ®å‹ç¼©æˆå“ˆå¤«æ›¼ç¼–ç ã€‚æ­£æ˜¯ç”±äºæ¯ä¸€ä¸ªæ•°æ®å¯¹åº”äºæ ‘ä¸Šçš„æ¯ä¸€ä¸ªå¶å­èŠ‚ç‚¹ï¼Œè€Œå¯¹åº”çš„ç¼–ç ä¸ºæ ¹åˆ°è¯¥å¶å­èŠ‚ç‚¹çš„è·¯å¾„ï¼Œæ‰€ä»¥ä¸€ä¸²å“ˆå¤«æ›¼ç¼–ç æ‰èƒ½å¯¹åº”æƒŸä¸€çš„ä¸€ä¸²åŸç ï¼ˆå³é¢˜ç›®ä¸­æ‰€è¯´siä¸æ˜¯sjçš„å‰ç¼€ã€‚ï¼‰ï¼Œè§£ç æ—¶æ‰ä¸ä¼šäº§ç”Ÿæ··æ·†ã€‚</p>
<p>å¹³æ—¶æˆ‘ä»¬æ‰€è¯´çš„å“ˆå¤«æ›¼ç¼–ç ä¸º2è¿›åˆ¶çš„ï¼Œæ„é€ çš„æ–¹æ³•ä¹Ÿå¾ˆå®¹æ˜“ï¼ˆç±»ä¼¼äºNOIP2004 åˆå¹¶æœå­ï¼‰ï¼Œæœ¬é¢˜ä¹Ÿå¯ä»¥ä½¿ç”¨ç›¸åŒçš„æ€æƒ³ã€‚</p>
<p>å¯¹äºkå‰å“ˆå¤«æ›¼æ ‘ï¼Œä»å¯ä»¥æ¯æ¬¡ä»å †ä¸­å–å‡ºæœ€å°çš„kä¸ªå€¼ã€‚ä½†å¦‚æœæœ€åä¸€è½®å¾ªç¯æ—¶å †çš„å¤§å°åœ¨2~k - 1ä¹‹é—´ï¼Œåˆ™æ•´ä¸ªå“ˆå¤«æ›¼æ ‘çš„æ ¹çš„å­èŠ‚ç‚¹æ ‘å°±å°äºkï¼Œä»»å–å¶å­èŠ‚ç‚¹åˆ°æ ¹çš„å­èŠ‚ç‚¹ï¼Œç­”æ¡ˆå°±ä¼šå˜å°ã€‚æ‰€ä»¥éœ€è¦æ·»åŠ ç©ºèŠ‚ç‚¹ã€‚</p>
<pre><code class="language-cpp">for (LL i = 1, tmp; i &lt;= n; i++)
    read(tmp), q.push(node(tmp, 0));
while ((n - 1) % (k - 1)) n++, q.push(node(0, 0));
</code></pre>
<p>æœ¬é¢˜å¯ç”¨ç»“æ„ä½“è®°å½•å•è¯å‡ºç°æ¬¡æ•°ï¼Œhight of nodeï¼Œä¼˜å…ˆé€‰æ‹©å‡ºç°æ¬¡æ•°å°‘çš„ä½œä¸ºå¶å­èŠ‚ç‚¹ï¼Œå…¶æ¬¡æ˜¯èŠ‚ç‚¹é«˜åº¦å°çš„ä¼˜å…ˆã€‚æœ€åæ ¹èŠ‚ç‚¹çš„é«˜åº¦å³ä¸ºæœ€é•¿çš„siçš„æœ€å°é•¿åº¦ã€‚</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
//huffman tree
constexpr int MAXN = 1e5 + 5;
constexpr int LOG = 18;
using namespace std;
using LL = long long;
template &lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1; x = 0; 
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
struct node {
	LL w, h; //height of node
	node(){}
	node(LL _w, LL _h) : w(_w), h (_h){}
	inline bool friend operator &lt; (const node &amp;a, const node &amp;b) {
		return a.w == b.w ? a.h &gt; b.h : a.w &gt; b.w;
	}
};
priority_queue&lt;node, vector&lt;node&gt;&gt;q; 
LL n, k;
int main(){
	read(n), read(k);
	for (LL i = 1, tmp; i &lt;= n; i++)
		read(tmp), q.push(node(tmp, 0));
	while ((n - 1) % (k - 1)) n++, q.push(node(0, 0));
	LL sum = 0;
	while (q.size() &gt; 1) {
		LL num = 0, h = 0;
		for (int i = 1; i &lt;= k; i++) {
			num += q.top().w;
			h = max(h, q.top().h);
			q.pop();
		}
		sum += num, q.push(node(num, h + 1));
	}
	cout &lt;&lt; sum &lt;&lt; endl &lt;&lt; q.top().h &lt;&lt; endl; 
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P3128 [USACO15DEC]Max Flow P]]></title>
        <id>https://shaun118294191.github.io/post/p3128-usaco15decmax-flow-p/</id>
        <link href="https://shaun118294191.github.io/post/p3128-usaco15decmax-flow-p/">
        </link>
        <updated>2020-03-01T05:00:22.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3128">é¢˜ç›®é“¾æ¥</a></p>
<p>Fjæœ‰<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>æ¡è¿è¾“å¥¶ç‰›çš„è·¯çº¿ï¼Œç¬¬iæ¡è·¯çº¿ä»éš”é—´<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>åˆ°<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">t_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, ä¸€æ¡è¿è¾“è·¯çº¿ä¼šç»™å®ƒçš„ä¸¤ä¸ªç«¯ç‚¹å¤„çš„éš”é—´ä»¥åŠä¸­é—´é€”å¾„çš„æ‰€æœ‰éš”é—´å¸¦æ¥ä¸€ä¸ªå•ä½çš„è¿è¾“å‹åŠ›ï¼Œä½ éœ€è¦è®¡ç®—å‹åŠ›æœ€å¤§çš„éš”é—´çš„å‹åŠ›æ˜¯å¤šå°‘ã€‚</p>
<p>æ ‘ä¸Šå·®åˆ†ç‚¹ä¿®æ”¹æ¨¡æ¿é¢˜ï¼Œå°†<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>e</mi><mi>l</mi><mi>t</mi><mi>a</mi><mo>[</mo><msub><mi>s</mi><mi>i</mi></msub><mo>]</mo></mrow><annotation encoding="application/x-tex">delta[s_i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>ï¼Œ<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>e</mi><mi>l</mi><mi>t</mi><mi>a</mi><mo>[</mo><msub><mi>t</mi><mi>i</mi></msub><mo>]</mo></mrow><annotation encoding="application/x-tex">delta[t_i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> åŠ 1; å°†<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>e</mi><mi>l</mi><mi>t</mi><mi>a</mi><mo>[</mo><mi>l</mi><mi>c</mi><mi>a</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">delta[lca]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mclose">]</span></span></span></span>ï¼Œ<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>e</mi><mi>l</mi><mi>t</mi><mi>a</mi><mo>[</mo><msub><mi>f</mi><mrow><mi>l</mi><mi>c</mi><mi>a</mi></mrow></msub><mo>]</mo></mrow><annotation encoding="application/x-tex">delta[f_{lca}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> å‡1ã€‚</p>
<p>æœ€ådfsæ±‚å­æ ‘deltaå’Œå³å¯ã€‚</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define pii pair&lt;int, int&gt; 
constexpr int MAXN = 5e4 + 4;
constexpr int LOG = 17;
using namespace std;
template &lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1; x = 0; 
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
int n, m, f[MAXN][LOG], depth[MAXN], delta[MAXN], ans;
vector&lt;int&gt; G[MAXN];
inline void dfs(int cur, int fa) {
	depth[cur] = depth[fa] + 1, f[cur][0] = fa;
	for (int i = 1; i &lt; LOG; i++) f[cur][i] = f[f[cur][i - 1]][i - 1];
	for (auto to : G[cur]) {
		if (fa == to) continue;
		dfs(to, cur);
	}
}
inline int LCA(int u, int v) {
	if (depth[u] &lt; depth[v]) swap(u, v);
	for (int i = LOG - 1; i &gt;= 0; i--) 
		if (depth[f[u][i]] &gt;= depth[v])
			u = f[u][i];
	if (u == v) return u;
	for (int i = LOG - 1; i &gt;= 0; i--) 
		if (f[u][i] != f[v][i])
			u = f[u][i], v = f[v][i];
	return f[u][0];
}
inline int dfs2(int cur, int fa) {
	int cnt = 0;
	for (auto to : G[cur]) {
		if (to == fa) continue;
		cnt += dfs2(to, cur);
	}
	ans = max(ans, cnt + delta[cur]);
	return cnt + delta[cur];
}
int main(){
	std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	cin &gt;&gt; n &gt;&gt; m;
	for (int i = 1, u, v; i &lt; n; i++) 
		cin &gt;&gt; u &gt;&gt; v, G[u].emplace_back(v), G[v].emplace_back(u);
	dfs(1, 0);
	for (int i = 1, u, v, lca; i &lt;= m; i++) {
		cin &gt;&gt; u &gt;&gt; v, lca = LCA(u, v);
		delta[u]++, delta[v]++, delta[lca]--, delta[f[lca][0]]--;
	}
	ans = max(ans, dfs2(1, 0));
	cout &lt;&lt; ans &lt;&lt; endl;
	return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[å…³äº]]></title>
        <id>https://shaun118294191.github.io/post/guan-yu/</id>
        <link href="https://shaun118294191.github.io/post/guan-yu/">
        </link>
        <updated>2020-03-01T03:33:30.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>æ¬¢è¿æ¥åˆ°æˆ‘çš„å°ç«™å‘€ï¼Œå¾ˆé«˜å…´é‡è§ä½ ï¼ğŸ¤</p>
</blockquote>
<h2 id="å…³äºæœ¬ç«™">ğŸ  å…³äºæœ¬ç«™</h2>
<h2 id="åšä¸»æ˜¯è°">ğŸ‘¨â€ğŸ’» åšä¸»æ˜¯è°</h2>
<h2 id="å…´è¶£çˆ±å¥½">â›¹ å…´è¶£çˆ±å¥½</h2>
<h2 id="è”ç³»æˆ‘å‘€">ğŸ“¬ è”ç³»æˆ‘å‘€</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF617E XOR and Favorite Number]]></title>
        <id>https://shaun118294191.github.io/post/cf617e-xor-and-favorite-number/</id>
        <link href="https://shaun118294191.github.io/post/cf617e-xor-and-favorite-number/">
        </link>
        <updated>2020-02-29T13:51:11.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF617E">é¢˜ç›®é“¾æ¥</a><br>
è¯¢é—®åŒºé—´<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mi>i</mi><mo separator="true">,</mo><mi>r</mi><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[li, ri]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>ä¸­æœ‰å¤šå°‘å¯¹<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i, j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>æ»¡è¶³ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><mo>â€¦</mo><msub><mi>a</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">a_i,a_{i + 1}, â€¦a_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">â€¦</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>çš„å¼‚æˆ–å€¼ä¸ºkã€‚</p>
<p>å¯¹æ¯ä¸ª<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>æ±‚å‡ºå…¶å¯¹åº”çš„å¼‚æˆ–å‰ç¼€å’Œ<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>ï¼Œé—®é¢˜è½¬åŒ–ä¸ºæ±‚åŒºé—´<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><msub><mi>l</mi><mi>i</mi></msub><mo>âˆ’</mo><mn>1</mn><mo separator="true">,</mo><mi>r</mi><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l_i - 1, ri]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">âˆ’</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>æœ‰å¯¹å°‘å¯¹<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>s</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">s_i, s_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>çš„å¼‚æˆ–å€¼ä¸ºkã€‚å³æ±‚<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi><mo>[</mo><msub><mi>s</mi><mi>i</mi></msub><mi>X</mi><mi>o</mi><mi>r</mi><mi>k</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">cnt[s_i Xor k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span>ï¼Œè«é˜Ÿå¤„ç†å³å¯ã€‚</p>
<p>é‡é¢˜ï¼š<a href="https://www.luogu.com.cn/problem/P4462">P4462 [CQOI2018]å¼‚æˆ–åºåˆ—</a></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
constexpr int MAXN = 1e5 + 5;
using namespace std;
int n, m, k, base, block[MAXN], a[MAXN];
long long Cnt, ans[MAXN], cnt[MAXN &lt;&lt; 4];
template &lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1; x = 0; 
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
struct query {
	int l, r, id;
	inline friend bool operator &lt; (const query &amp;a, const query &amp;b) {
		return (block[a.l] == block[b.l]) ? ((block[a.l] &amp; 1) ? a.r &lt; b.r : a.r &gt; b.r) : a.l &lt; b.l; 
	}
}Q[MAXN];
inline void add(int x) {
	Cnt += cnt[x ^ k]; //a[i] ^ a[j - 1] = k ==&gt; how many a[j - 1] = a[i] ^ k
	cnt[x]++;
}
inline void del(int x) {
	cnt[x]--;
	Cnt -= cnt[x ^ k];
}
int main(){
	read(n), read(m), read(k), base = pow(n, 0.54);
	for (int i = 1; i &lt;= n; i++) 
		read(a[i]), a[i] ^= a[i - 1], block[i] = i / base;
	for (int i = 1; i &lt;= m; i++) 
		read(Q[i].l), Q[i].l--, read(Q[i].r), Q[i].id = i;
	sort(Q + 1, Q + m + 1);
	int l = 1, r = 0;
	for (int i = 1; i &lt;= m; i++) {
		while (r &lt; Q[i].r) add(a[++r]);
		while (r &gt; Q[i].r) del(a[r--]);
		while (l &lt; Q[i].l) del(a[l++]);
		while (l &gt; Q[i].l) add(a[--l]);
		ans[Q[i].id] = Cnt;
	}
	for (int i = 1; i &lt;= m; i++) printf(&quot;%lld\n&quot;, ans[i]);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://shaun118294191.github.io/post/hello-gridea/</id>
        <link href="https://shaun118294191.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>ğŸ‘  æ¬¢è¿ä½¿ç”¨ <strong>Gridea</strong> ï¼<br>
âœï¸  <strong>Gridea</strong> ä¸€ä¸ªé™æ€åšå®¢å†™ä½œå®¢æˆ·ç«¯ã€‚ä½ å¯ä»¥ç”¨å®ƒæ¥è®°å½•ä½ çš„ç”Ÿæ´»ã€å¿ƒæƒ…ã€çŸ¥è¯†ã€ç¬”è®°ã€åˆ›æ„... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>ğŸ‘  æ¬¢è¿ä½¿ç”¨ <strong>Gridea</strong> ï¼<br>
âœï¸  <strong>Gridea</strong> ä¸€ä¸ªé™æ€åšå®¢å†™ä½œå®¢æˆ·ç«¯ã€‚ä½ å¯ä»¥ç”¨å®ƒæ¥è®°å½•ä½ çš„ç”Ÿæ´»ã€å¿ƒæƒ…ã€çŸ¥è¯†ã€ç¬”è®°ã€åˆ›æ„... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea ä¸»é¡µ</a><br>
<a href="http://fehey.com/">ç¤ºä¾‹ç½‘ç«™</a></p>
<h2 id="ç‰¹æ€§">ç‰¹æ€§ğŸ‘‡</h2>
<p>ğŸ“  ä½ å¯ä»¥ä½¿ç”¨æœ€é…·çš„ <strong>Markdown</strong> è¯­æ³•ï¼Œè¿›è¡Œå¿«é€Ÿåˆ›ä½œ</p>
<p>ğŸŒ‰  ä½ å¯ä»¥ç»™æ–‡ç« é…ä¸Šç²¾ç¾çš„å°é¢å›¾å’Œåœ¨æ–‡ç« ä»»æ„ä½ç½®æ’å…¥å›¾ç‰‡</p>
<p>ğŸ·ï¸  ä½ å¯ä»¥å¯¹æ–‡ç« è¿›è¡Œæ ‡ç­¾åˆ†ç»„</p>
<p>ğŸ“‹  ä½ å¯ä»¥è‡ªå®šä¹‰èœå•ï¼Œç”šè‡³å¯ä»¥åˆ›å»ºå¤–éƒ¨é“¾æ¥èœå•</p>
<p>ğŸ’»  ä½ å¯ä»¥åœ¨ <strong>Windows</strong>ï¼Œ<strong>MacOS</strong> æˆ– <strong>Linux</strong> è®¾å¤‡ä¸Šä½¿ç”¨æ­¤å®¢æˆ·ç«¯</p>
<p>ğŸŒ  ä½ å¯ä»¥ä½¿ç”¨ <strong>ğ–¦ğ—‚ğ—ğ—ğ—ğ–» ğ–¯ğ–ºğ—€ğ–¾ğ—Œ</strong> æˆ– <strong>Coding Pages</strong> å‘ä¸–ç•Œå±•ç¤ºï¼Œæœªæ¥å°†æ”¯æŒæ›´å¤šå¹³å°</p>
<p>ğŸ’¬  ä½ å¯ä»¥è¿›è¡Œç®€å•çš„é…ç½®ï¼Œæ¥å…¥ <a href="https://github.com/gitalk/gitalk">Gitalk</a> æˆ– <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> è¯„è®ºç³»ç»Ÿ</p>
<p>ğŸ‡¬ğŸ‡§  ä½ å¯ä»¥ä½¿ç”¨<strong>ä¸­æ–‡ç®€ä½“</strong>æˆ–<strong>è‹±è¯­</strong></p>
<p>ğŸŒ  ä½ å¯ä»¥ä»»æ„ä½¿ç”¨åº”ç”¨å†…é»˜è®¤ä¸»é¢˜æˆ–ä»»æ„ç¬¬ä¸‰æ–¹ä¸»é¢˜ï¼Œå¼ºå¤§çš„ä¸»é¢˜è‡ªå®šä¹‰èƒ½åŠ›</p>
<p>ğŸ–¥  ä½ å¯ä»¥è‡ªå®šä¹‰æºæ–‡ä»¶å¤¹ï¼Œåˆ©ç”¨ OneDriveã€ç™¾åº¦ç½‘ç›˜ã€iCloudã€Dropbox ç­‰è¿›è¡Œå¤šè®¾å¤‡åŒæ­¥</p>
<p>ğŸŒ± å½“ç„¶ <strong>Gridea</strong> è¿˜å¾ˆå¹´è½»ï¼Œæœ‰å¾ˆå¤šä¸è¶³ï¼Œä½†è¯·ç›¸ä¿¡ï¼Œå®ƒä¼šä¸åœå‘å‰ ğŸƒ</p>
<p>æœªæ¥ï¼Œå®ƒä¸€å®šä¼šæˆä¸ºä½ ç¦»ä¸å¼€çš„ä¼™ä¼´</p>
<p>å°½æƒ…å‘æŒ¥ä½ çš„æ‰åå§ï¼</p>
<p>ğŸ˜˜ Enjoy~</p>
]]></content>
    </entry>
</feed>