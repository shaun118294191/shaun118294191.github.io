<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://shaun118294191.github.io</id>
    <title>Shaun</title>
    <updated>2020-03-05T11:59:48.698Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://shaun118294191.github.io"/>
    <link rel="self" href="https://shaun118294191.github.io/atom.xml"/>
    <subtitle>Valar morghulis Valar Dohaeris</subtitle>
    <logo>https://shaun118294191.github.io/images/avatar.png</logo>
    <icon>https://shaun118294191.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Shaun</rights>
    <entry>
        <title type="html"><![CDATA[Hazardous(map)]]></title>
        <id>https://shaun118294191.github.io/post/hazardousmap/</id>
        <link href="https://shaun118294191.github.io/post/hazardousmap/">
        </link>
        <updated>2020-03-05T11:50:57.000Z</updated>
        <content type="html"><![CDATA[<p>给定n个节点，每个节点有一种颜色。对于每个节i, 求i的子树中所有颜色相同的节点两两距离和。</p>
<p>采用支持合并的数据结构，下标维护标号，信息维护深度总和与点数，在每个点合并子树信息并维护<br>
答案。合并的两端的某个颜色的信息分别为 (dep1, cnt1),(dep2, cnt2)，当前点深度为 d，则合并时产生贡献dep1 × cnt2 + dep2 × cnt11- 2d × cnt1 × cnt2（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Σ</mi><mrow><mo>(</mo><mi>d</mi><mn>1</mn><mo>−</mo><mi>d</mi><mo>)</mo></mrow><mo>∗</mo><mi>c</mi><mi>n</mi><mi>t</mi><mn>2</mn><mo>+</mo><mi mathvariant="normal">Σ</mi><mrow><mo>(</mo><mi>d</mi><mn>2</mn><mo>−</mo><mi>d</mi><mo>)</mo></mrow><mo>∗</mo><mi>c</mi><mi>n</mi><mi>t</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">\Sigma{(d1 - d)} * cnt2+ \Sigma{(d2 - d)}  * cnt1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Σ</span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">d</span><span class="mclose">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Σ</span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">d</span><span class="mclose">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord">1</span></span></span></span>)。</p>
<p>Map合并:</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
typedef pair&lt;int, int&gt; pii;

#define N 101111

int n;
int color[N], dep[N];

typedef map &lt;int, pair&lt;long long, int&gt;&gt; Map;
Map root[N];
vector &lt;int&gt; G[N];
LL sc[N], delta;
int curdep;

void merge(Map &amp;root, Map &amp;p) {
	if (root.size() &lt; p.size()) swap(root, p);
	for (auto&amp; v : p) {
		int color = v.first;
		auto it = root.find(color);
		if (it != root.end()) {
			LL d1 = it-&gt;second.first, c1 = it-&gt;second.second;
			LL d2 = v.second.first, c2 = v.second.second;
			delta += d1 * c2 + d2 * c1 - 2ll * curdep * c1 * c2;
			it-&gt;second.first += d2;
			it-&gt;second.second += int(c2);
		}
		else root.insert(v);
	}
}

void init(Map&amp; root, int color) {
	root[color] = {curdep, 1};
}

void dfs(int x, int fa) {
	curdep = dep[x];
	init(root[x], color[x]);
	for (auto to : G[x]) if (to != fa){
		dep[to] = dep[x] + 1;
		dfs(to, x);
		sc[x] += sc[to];
		delta = 0;
		curdep = dep[x];
		merge(root[x], root[to]);
		sc[x] += delta;
	}
}

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, color + i);
	for (int i = 1; i &lt; n; i++) {
		int u, v;
		scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
		G[u].push_back(v);
		G[v].push_back(u);
	}
	dfs(1, -1);
	for (int i = 1; i &lt;= n; i++) printf(&quot;%lld &quot;, sc[i]);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hazardous]]></title>
        <id>https://shaun118294191.github.io/post/hazardous/</id>
        <link href="https://shaun118294191.github.io/post/hazardous/">
        </link>
        <updated>2020-03-05T11:34:37.000Z</updated>
        <content type="html"><![CDATA[<p>Viruses are hazardous. Controlling viruses is hard.</p>
<p>In order to prepare for potential virus incoming, Country H need to investigate the hazard score for every administrative division. Abstractly Country H's hierarchy forms a rooted tree that every vertex is a level<br>
of administration - like province, city, county, town, etc. The root is vertex 1. Every vertex has its color which indicates the living habits of local residents - people are more likely to transport between vertices of the same color.</p>
<p>The hazard score for every vertex is calculated as the sum of distance of all pairs of different vertices in the subtree of the vertex that have the same color. The distance between two vertices is calculated as the minimum number of edges it need to transport between two vertices.</p>
<p>Time is life. You are hired to calculate the hazard score for every vectex in Country H as fast as possible.</p>
<p>Input<br>
The first line contains a integer n(1 ≤ n ≤ 100000) - the number of vertices.<br>
The second line contains n integers, the i-th number ci(1 ≤ ci ≤ n) denotes the color of vertex i.<br>
Each of the next n 1 lines contains 2 integers ui, vi(1 ≤ ui, vi ≤ n) - the ends of the i-th edge.<br>
It's guaranteed that the edges forms a tree containing n vertices.</p>
<p>Output<br>
Output n lines, on the i-th line print a single integer denoting the hazard score for subtree i。</p>
<p>给定n个节点，每个节点有一种颜色。对于每个节i, 求i的子树中所有颜色相同的节点两两距离和。</p>
<p>INPUT<br>
5<br>
1 2 1 1 2<br>
1 2<br>
2 3<br>
2 4<br>
5 1<br>
OUTPUT<br>
8 2 0 0 0<br>
<img src="https://shaun118294191.github.io/post-images/1583408451493.png" alt="" loading="lazy"></p>
<p>采用支持合并的数据结构，下标维护标号，信息维护深度总和与点数，在每个点合并子树信息并维护<br>
答案。合并的两端的某个颜色的信息分别为 (dep1, cnt1),(dep2, cnt2)，当前点深度为 d，则合并时产生贡献dep1 × cnt2 + dep2 × cnt11- 2d × cnt1 × cnt2（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Σ</mi><mrow><mo>(</mo><mi>d</mi><mn>1</mn><mo>−</mo><mi>d</mi><mo>)</mo></mrow><mo>∗</mo><mi>c</mi><mi>n</mi><mi>t</mi><mn>2</mn><mo>+</mo><mi mathvariant="normal">Σ</mi><mrow><mo>(</mo><mi>d</mi><mn>2</mn><mo>−</mo><mi>d</mi><mo>)</mo></mrow><mo>∗</mo><mi>c</mi><mi>n</mi><mi>t</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">\Sigma{(d1 - d)} * cnt2+ \Sigma{(d2 - d)}  * cnt1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Σ</span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">d</span><span class="mclose">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Σ</span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">d</span><span class="mclose">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord">1</span></span></span></span>)。</p>
<p>线段树合并: delta和curdepth为全局变量，dfs后需重新赋值</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
constexpr int MAXN = 1e5 + 5;
constexpr int LOG = 18;
using namespace std;
template &lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1; x = 0; 
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
struct Node {
	Node *lson, *rson;
	long long cnt, depth;
}Tree[MAXN * LOG * 4], *root[MAXN];
#define Lson root-&gt;lson
#define Rson root-&gt;rson
vector&lt;int&gt; G[MAXN];
int tot, n, val[MAXN];
long long delta, curDepth, depth[MAXN], ans[MAXN];
inline Node * newNode(Node * &amp;root) { 
	if (root == NULL) root = &amp;Tree[++tot];
	return root;
}
inline void insert(Node *root, int L, int R, int val) {
	if (L == R) {
		root-&gt;cnt++;
		root-&gt;depth += curDepth;
		return;
	}
	int mid = (L + R) &gt;&gt; 1;
	if (val &lt;= mid) insert(newNode(Lson), L, mid, val);
	else insert(newNode(Rson), mid + 1, R, val);
}
inline void merge(Node *&amp;root, Node *p, int L, int R) {
	if (root == NULL) {root = p; return;}
	if (p == NULL) return;
	if (L == R) {
		delta += root-&gt;depth * p-&gt;cnt + root-&gt;cnt * p-&gt;depth - 2LL * curDepth * (root-&gt;cnt) * (p-&gt;cnt);
		root-&gt;cnt += p-&gt;cnt;
		root-&gt;depth += p-&gt;depth;	
        return;
	}
	int mid = (L + R) &gt;&gt; 1;
	merge(Lson, p-&gt;lson, L, mid);
	merge(Rson, p-&gt;rson, mid + 1, R);
}
inline void dfs(int cur, int fa) {
	depth[cur] = depth[fa] + 1;
	curDepth = depth[cur];
	insert(root[cur], 1, n, val[cur]);
	for (auto to : G[cur]) {
		if (fa == to) continue;
		dfs(to, cur);
		delta = 0, curDepth = depth[cur];
		merge(root[cur], root[to], 1, n);
		ans[cur] += ans[to] + delta;
	}
}
int main(){
	read(n);
	for (int i = 1; i &lt;= n; i++) 
		read(val[i]), newNode(root[i]);
	for (int i = 1, u, v; i &lt; n; i++) {
		read(u), read(v);
		G[u].push_back(v), G[v].push_back(u);
	}
	dfs(1, 0);
	for (int i = 1; i &lt;= n; i++) printf(&quot;%lld &quot;, ans[i]);
	return 0;
}
</code></pre>
<p>Map合并:</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P1944 最长括号匹配]]></title>
        <id>https://shaun118294191.github.io/post/p1944-zui-chang-gua-hao-pi-pei/</id>
        <link href="https://shaun118294191.github.io/post/p1944-zui-chang-gua-hao-pi-pei/">
        </link>
        <updated>2020-03-05T11:21:27.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1944">题目链接</a></p>
<p>求最长括号序列, 若有相同长度的括号序列，则输出最靠前的。</p>
<p>合法括号序列: [], (), [()], [()], <a href="">()()</a>[]</p>
<ul>
<li>用栈来维护下标, 用C[i]表示i处最长括号序列长度。</li>
<li>读入'(' 或 '['就压入栈, 否则判断当前字符是否与栈顶元素匹配。</li>
<li>如果匹配，则有C[i] = i - Stack[top] + 1 + C[Stack[top] - 1]，并弹出栈顶元素。示例 <a href="">()</a></li>
<li>若不匹配，则清空栈。示例[)]，不清空则会出错。</li>
</ul>
<pre><code class="language-cpp">    for (int i = 1; i &lt; s.size(); i++) {
        if (s[i] == '(' || s[i] == '[') Stack[++top] = i;
        else if (top) {
            if ((s[i] == ']' &amp;&amp; s[Stack[top]] == '[') ||
                (s[i] == ')' &amp;&amp; s[Stack[top]] == '(')) {
                C[i] = i - Stack[top] + 1 + C[Stack[top] - 1];
                maxL = max(maxL, C[i]);
                top--;
            } else while(top) top--;
        }
    }
</code></pre>
<p>最后遍历字符串找到第一个C[i] = maxLen的位置，输出即可。</p>
<p>Code:</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
constexpr int MAXN = 1e6 + 6;
constexpr int MAXM = 1e4 + 4;
using namespace std;
template &lt;typename T&gt;

inline void read(T &amp;x) {
    int f = 1;
    x = 0;
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}

string s, cur, ans;
int Stack[MAXN], top, C[MAXN], maxL(-1);

int main() {
    std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
    cin &gt;&gt; s, s = &quot; &quot; + s;
    for (int i = 1; i &lt; s.size(); i++) {
        if (s[i] == '(' || s[i] == '[') Stack[++top] = i;
        else if (top) {
            if ((s[i] == ']' &amp;&amp; s[Stack[top]] == '[') ||
                (s[i] == ')' &amp;&amp; s[Stack[top]] == '(')) {
                C[i] = i - Stack[top] + 1 + C[Stack[top] - 1];
                maxL = max(maxL, C[i]);
                top--;
            } else while(top) top--;
        }
    }
    for (int i = 1; i &lt; s.size(); i++) {
        if (C[i] == maxL) {
            for (int j = i - maxL + 1; j &lt;= i; j++)cout &lt;&lt; s[j];
            return 0;
        }
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[文艺平衡树]]></title>
        <id>https://shaun118294191.github.io/post/wen-yi-ping-heng-shu/</id>
        <link href="https://shaun118294191.github.io/post/wen-yi-ping-heng-shu/">
        </link>
        <updated>2020-03-04T10:13:27.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3391">题目链接</a><br>
您需要写一种数据结构（可参考题目标题），来维护一个有序数列。</p>
<p>其中需要提供以下操作：翻转一个区间，例如原有序序列是5 4 3 2 1，翻转区间是 [2,4]的话，结果是 5 2 3 4 1。</p>
<p>无旋Treap：<br>
初始化：直接将1~i merge到root即可。</p>
<pre><code class="language-cpp">for (int i = 1; i &lt;= n; i++) 
		newNode(tmp, i), merge(root, root, tmp); //直接merge
</code></pre>
<p>区间反转需按子树size分裂将整棵树分裂为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mi>l</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[1, l - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l, r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[r + 1, n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span>，并将[l, r]对应的root加上标记。</p>
<pre><code class="language-cpp">inline void rev(Node &amp;root, int l, int r) {
   Node L = NULL, mid = NULL, R = NULL;
   split(root, L, R, r), split(L, L, mid, l - 1); //分出[l, r]的部分
   mid-&gt;tag ^= 1;
   merge(L, L, mid), merge(root, L, R);
}
</code></pre>
<p>区间反转交换无旋Treap的左右儿子并下放标记(split和merge都要pushdown)。</p>
<pre><code class="language-cpp">inline void pushTag(Node root) {
	if (root-&gt;tag == 0) return;
	swap(Lson, Rson); //区间反转 交换左右儿子再打上标记即可
	if (Lson) Lson-&gt;tag ^= 1; if (Rson) Rson-&gt;tag ^= 1;
	root-&gt;tag = 0;
}
</code></pre>
<p>Code:</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
const int MAXN = 1e5 + 5;
using namespace std;
template &lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1; x = 0; 
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
struct Treap {
	Treap * lson, *rson;
	int size, priority;
	int key, tag;
}Tree[MAXN &lt;&lt; 1], *root, *tmp;
typedef Treap * Node;
#define Lson root-&gt;lson
#define Rson root-&gt;rson
int n, m, tot, l, r;
inline void newNode(Node &amp;root, int key) {
	root = &amp;Tree[++tot], root-&gt;size = 1;
	root-&gt;key = key, root-&gt;priority = rand();
}
inline void update(Node root) {
	int Lsize = Lson ? Lson-&gt;size : 0, Rsize = Rson ? Rson-&gt;size : 0;
	root-&gt;size = Lsize + Rsize + 1;
}
inline void pushTag(Node root) {
	if (root-&gt;tag == 0) return;
	swap(Lson, Rson); //区间反转 交换左右儿子再打上标记即可
	if (Lson) Lson-&gt;tag ^= 1; if (Rson) Rson-&gt;tag ^= 1;
	root-&gt;tag = 0;
}
inline void split(Node root, Node &amp;L, Node &amp;R, int size) {
	if (root == NULL) {
		L = R = NULL;
		return;
	}
	pushTag(root); //分裂前下放标记到左右子树
	int Lsize = Lson ? Lson-&gt;size : 0;
	if (Lsize + 1 &lt;= size) L = root, split(Rson, Rson, R, size - Lsize - 1);
	else R = root, split(Lson, L, Lson, size);
	update(root);
}
inline void merge(Node &amp;root, Node L, Node R) {
	if (L == NULL) {root = R; return;}
	if (R == NULL) {root = L; return;}
	if (L-&gt;priority &lt; R-&gt;priority) pushTag(root = L), merge(Rson, Rson, R);
	else pushTag(root = R), merge(Lson, L, Lson);
	update(root);
}
inline void rev(Node &amp;root, int l, int r) {
	Node L = NULL, mid = NULL, R = NULL;
	split(root, L, R, r), split(L, L, mid, l - 1); //分出[l, r]的部分
	mid-&gt;tag ^= 1;
	merge(L, L, mid), merge(root, L, R);
}
inline void print(Node root) { //中序遍历输出
	if (root == NULL) return;
	pushTag(root);
	print(Lson), printf(&quot;%d &quot;, root-&gt;key), print(Rson);
}
int main() {
	srand(time(0));
	read(n), read(m);
	for (int i = 1; i &lt;= n; i++) 
		newNode(tmp, i), merge(root, root, tmp); //直接merge
	while (m--) read(l), read(r), rev(root, l, r);
	print(root);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[fhq-Treap]]></title>
        <id>https://shaun118294191.github.io/post/fhq-treap/</id>
        <link href="https://shaun118294191.github.io/post/fhq-treap/">
        </link>
        <updated>2020-03-03T13:49:12.000Z</updated>
        <content type="html"><![CDATA[<p>无旋Treap核心操作</p>
<p><strong>1.split</strong><br>
将一个平衡树分成两棵树；</p>
<ul>
<li>split有两种： 一种是按照权值split，一种是按照size来split。</li>
<li>如果按照权值split，那么分出来两棵树的第一棵树上的每一个数的大小都小于（或小于等于，视具体情况而定）给定的key值;</li>
<li>如果按照size split，那么分出来两棵树的第一棵树恰好有x个节点。</li>
</ul>
<pre><code class="language-cpp">inline void split(Treap *root, Treap *&amp;L, Treap *&amp;R, int key) { //L为分裂后的左树 R为分裂后的右树
    if (root == NULL) {
	L = NULL, R = NULL; //分到底了 返回
	return;
	}
	if (root-&gt;key &lt;= key) L = root, split(Rson, Rson, R, key); //左子树key一定都小于key, 再分裂root右子树给L右子树与R
    /*  int Lsize = Lson ? Lson-&gt;size : 0; 
        if (Lsize + 1 &lt;= size) L = root, split(Rson, Rson, R, size - Lsize - 1;
    */
	else R = root, split(Lson, L, Lson, key); 
	update(root);//更新
}
</code></pre>
<p><strong>2.merge</strong><br>
将两颗分开的树合在一起，维护大根堆或小根堆性质</p>
<pre><code class="language-cpp">inline void merge(Treap *&amp;root, Treap *L, Treap *R) {
	if (L == NULL) {root = R; return;}
	if (R == NULL) {root = L; return;} 
	if (L-&gt;priority &lt; R-&gt;priority) root = L, merge(Rson, Rson, R); //L加到root上，合并右子树
	else root = R, merge(Lson, L, Lson); //R加到root上, 合并左子树
	update(root);
}
</code></pre>
<p>注意: 有merge和split操作时需要引用Treap *&amp;root。</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
constexpr int MAXN = 1e6 + 6;
constexpr int Inf = 2e9;
using namespace std;
template &lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1; x = 0; 
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
struct Treap {
	Treap *lson, *rson;
	int key, priority;
	int size;
}Tree[MAXN], *rt;
int tot, Q, type, x;
#define Lson root-&gt;lson
#define Rson root-&gt;rson
inline void newNode(Treap *&amp;root, int key) {
	root = &amp;Tree[++tot], root-&gt;size = 1;
	root-&gt;key = key, root-&gt;priority = rand();
}
inline void update(Treap *root) {
	int Lsize = Lson ? Lson-&gt;size : 0, Rsize = Rson ? Rson-&gt;size : 0;
	root-&gt;size = Lsize + Rsize + 1;
}
inline void split(Treap *root, Treap *&amp;L, Treap *&amp;R, int key) {
	if (root == NULL) {
		L = NULL, R = NULL;
		return;
	}
	if (root-&gt;key &lt;= key) L = root, split(Rson, Rson, R, key);
	else R = root, split(Lson, L, Lson, key);
	update(root);
}
inline void merge(Treap *&amp;root, Treap *L, Treap *R) {
	if (L == NULL) {root = R; return;}
	if (R == NULL) {root = L; return;}
	if (L-&gt;priority &lt; R-&gt;priority) root = L, merge(Rson, Rson, R);
	else root = R, merge(Lson, L, Lson);
	update(root);
}
inline void insert(Treap *&amp;root, int key) {
	Treap *L = NULL, *R = NULL, *tmp = NULL;
	newNode(tmp, key); //新建节点
	split(root, L, R, key); //按key分裂
	merge(L, L, tmp), merge(root, L, R); //tmp与L合并，L与R合并
}
inline void remove(Treap *&amp;root, int key) {
	Treap *L = NULL, *R = NULL, *tmp = NULL;
	split(root, L, R, key);
	split(L, L, tmp, key - 1); //按key - 1分裂 tmp的值都&gt;= key
	merge(tmp, tmp-&gt;lson, tmp-&gt;rson); //合并lson rson，从而减去一个key值
	merge(L, L, tmp), merge(root, L, R); //合并回root
}
inline int getVal(Treap *root, int rank) {//排名为rank的值
	while (true) {
		if (root == NULL) return 0;
		int Lsize = Lson ? Lson-&gt;size : 0;
		if (Lsize + 1 == rank) return root-&gt;key;
		if (Lsize &gt;= rank) root = Lson;
		else rank -= Lsize + 1, root = Rson;
	}
}
inline int getRank(Treap *&amp;root, int key) { 
	Treap *L = NULL, *R = NULL;
	split(root, L, R, key - 1);
	int res = (L ? L-&gt;size : 0) + 1;
	merge(root, L, R);
	return res;
}
inline int getPre(Treap *&amp;root, int key) {
	Treap *L = NULL, *R = NULL;
	split(root, L, R, key - 1);
	int res = getVal(L, L-&gt;size);
	merge(root, L, R);
	return res;
}
inline int getNext(Treap *&amp;root, int key) {
	Treap *L = NULL, *R = NULL;
	split(root, L, R, key);
	int res = getVal(R, 1);
	merge(root, L, R);
	return res;
}
int main(){
	srand(time(0));
	read(Q);
    while (Q--) {
        read(type), read(x);
        switch (type) {
            case 1:
                insert(rt, x);
                break;
            case 2:
                remove(rt, x);
                break;
            case 3:
                printf(&quot;%d\n&quot;, getRank(rt, x));
                break;
            case 4:
                printf(&quot;%d\n&quot;, getVal(rt, x));
                break;
            case 5:
                printf(&quot;%d\n&quot;, getPre(rt, x));
                break;
            case 6:
                printf(&quot;%d\n&quot;, getNext(rt, x));
                break;
        }
    }
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF813E Army Creation]]></title>
        <id>https://shaun118294191.github.io/post/cf813e-army-creation/</id>
        <link href="https://shaun118294191.github.io/post/cf813e-army-creation/">
        </link>
        <updated>2020-03-03T13:41:53.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF813E">题目链接</a><br>
方法和<a href="https://www.luogu.com.cn/blog/user48611/sp3267-dquery-d-query">SP3267 DQUERY - D-query</a>类似，本题更具一般性。</p>
<ul>
<li>
<p>可以求出每个数前面第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个数的位置(不足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个设为0)。</p>
<pre><code class="language-cpp">for (int i = 1, x; i &lt;= n; i++) {
    x = read(), pos[x].push_back(i);
    int sz = pos[x].size();
    if (sz &gt; k) sz = pos[x][sz - k - 1]; else sz = 0;
    modify(root[i - 1], newNode(root[i]), 0, n, sz);
}
</code></pre>
</li>
<li>
<p>询问即求有多少个数，其前面第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个数的位置小于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">l - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</p>
</li>
</ul>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
constexpr int MAXN = 1e5 + 5;
constexpr int LOG = 20;
using namespace std;
inline int read(){
    int x = 0, f = 1;
    char ch = getchar();
    while(!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while(isdigit(ch)) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch -48, ch = getchar();
    return x * f;
}
struct Node {
	Node * lson, *rson;
	int cnt;
}Tree[MAXN * LOG], *root[MAXN];
int tot, n, m, k, last;
inline Node * newNode(Node * &amp;root) { return root = &amp;Tree[tot++];}
inline void build(int L, int R, Node *root) {
	if (L == R) return;
	int mid = (L + R) &gt;&gt; 1;
	build(L, mid, newNode(root-&gt;lson)), build(mid + 1, R, newNode(root-&gt;rson));
}
inline void modify(Node *pre, Node *cur, int L, int R, int pos) {
	*cur = *pre;
	if (L == R) {
		cur-&gt;cnt++;
		return;
	}
	int mid = (L + R) &gt;&gt; 1;
	if (pos &lt;= mid) modify(pre-&gt;lson, newNode(cur-&gt;lson), L, mid, pos);
	else modify(pre-&gt;rson, newNode(cur-&gt;rson), mid + 1, R, pos);
	cur-&gt;cnt = cur-&gt;lson-&gt;cnt + cur-&gt;rson-&gt;cnt;
}
inline int query(Node * pre, Node * cur, int L, int R, int qL, int qR) {
	if (qL &lt;= L &amp;&amp; R &lt;= qR) return cur-&gt;cnt - pre-&gt;cnt;
	int mid = (L + R ) &gt;&gt; 1, ans = 0;
	if (qL &lt;= mid) ans += query(pre-&gt;lson, cur-&gt;lson, L, mid, qL, qR);
	if (qR &gt; mid) ans += query(pre-&gt;rson, cur-&gt;rson, mid + 1, R, qL, qR);
	return ans;
}
vector&lt;int&gt;pos[MAXN];
int main(){
	n = read(), k = read();
	build(0, n, newNode(root[0]));
	for (int i = 1, x; i &lt;= n; i++) {
		x = read(), pos[x].push_back(i);
        int sz = pos[x].size();
        if (sz &gt; k) sz = pos[x][sz - k - 1]; else sz = 0;
        modify(root[i - 1], newNode(root[i]), 0, n, sz);
    }
	m = read();
	while (m--) {
		int l = read(), r = read();
        l = (l + last) % n + 1, r = (r + last) % n + 1;
        if (l &gt; r) swap(l, r);
		printf(&quot;%d\n&quot;, last = query(root[l - 1], root[r], 0, n, 0, l - 1));
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P3258 [JLOI2014]松鼠的新家]]></title>
        <id>https://shaun118294191.github.io/post/p3258-jloi2014song-shu-de-xin-jia/</id>
        <link href="https://shaun118294191.github.io/post/p3258-jloi2014song-shu-de-xin-jia/">
        </link>
        <updated>2020-03-03T11:27:21.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3258">题目链接</a><br>
本题树上差分解决即可。</p>
<p>对于房间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>…</mo><msub><mi>a</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_1…a_{n - 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>，将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_{i + 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>路径上的点覆盖。</p>
<p>由于这样会使<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>2</mn></msub><mo>…</mo><msub><mi>a</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_2…a_{n - 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>都被多覆盖一次，而题目说<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>不需要再加1，所以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>2</mn></msub><mo>…</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_2…a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的访问次数减1即可。</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
constexpr int MAXN = 3e5 + 5;
constexpr int LOG = 19;
using namespace std;
template &lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1; x = 0; 
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
vector&lt;int&gt; G[MAXN];
int n, path[MAXN], f[MAXN][LOG], depth[MAXN], delta[MAXN];
inline void dfs(int cur, int fa) {
	depth[cur] = depth[fa] + 1, f[cur][0] = fa;
	for (int i = 1; i &lt; LOG; i++) f[cur][i] = f[f[cur][i - 1]][i - 1];
	for (auto to : G[cur]) {
		if (to == fa) continue;
		dfs(to, cur);
	}
}
inline void getCnt(int cur, int fa) {
	for (auto to : G[cur]) {
		if (to == fa) continue;
		getCnt(to, cur);
		delta[cur] += delta[to];
	}
}
inline int LCA(int u, int v) {
	if (depth[u] &lt; depth[v]) swap(u, v);
	for (int i = LOG - 1; i &gt;= 0; i--) 
		if (depth[f[u][i]] &gt;= depth[v])
			u = f[u][i];
	if (u == v) return u;
	for (int i = LOG - 1; i &gt;= 0; i--) 
		if (f[u][i] != f[v][i])
			u = f[u][i], v = f[v][i];
	return f[u][0];
}
signed main(){
	read(n);
	for (int i = 1; i &lt;= n; i++) read(path[i]);
	for (int i = 1, u, v; i &lt; n; i++) {
		read(u), read(v);
		G[u].emplace_back(v), G[v].push_back(u);
	}
	dfs(1, 0);
	for (int i = 1; i &lt; n; i++) {
		int from = path[i], to = path[i + 1], lca = LCA(to, from);
		delta[from]++, delta[to]++, delta[lca]--, delta[f[lca][0]]--;
	}
	getCnt(1, 0);
	for (int i = 2; i &lt;= n; i++) delta[path[i]]--;
	for (int i = 1; i &lt;= n; i++) printf(&quot;%d\n&quot;, delta[i]);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P3369 【模板】普通平衡树(数组)]]></title>
        <id>https://shaun118294191.github.io/post/p3369-mo-ban-pu-tong-ping-heng-shu-shu-zu/</id>
        <link href="https://shaun118294191.github.io/post/p3369-mo-ban-pu-tong-ping-heng-shu-shu-zu/">
        </link>
        <updated>2020-03-02T13:39:48.000Z</updated>
        <content type="html"><![CDATA[<p>您需要写一种数据结构，来维护一些数，其中需要提供以下操作：</p>
<p>1.插入 x 数</p>
<p>2.删除 x 数(若有多个相同的数，因只删除一个)</p>
<p>3.查询 x 数的排名(排名定义为比当前数小的数的个数 +1)</p>
<p>4.查询排名为 x 的数</p>
<p>5.求 x 的前驱(前驱定义为小于 x，且最大的数)</p>
<p>6.求 x 的后继(后继定义为大于 x，且最小的数)</p>
<p>Treap:</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 1e6 + 6;
const int Inf = 1 &lt;&lt; 30;
struct Treap{
    int Lson, Rson;
    int val, dat;
    int cnt, size;
}Tree[MAXN];
#define Lnode Tree[node].Lson
#define Rnode Tree[node].Rson
int tot, root, n;
inline int New(int val){
    Tree[++tot].val = val;
    Tree[tot].dat = rand();
    Tree[tot].cnt = Tree[tot].size = 1; 
    return tot;
}
inline void update(int node){
    Tree[node].size = Tree[Lnode].size + Tree[Rnode].size + Tree[node].cnt;
}
inline void build(){
    New(-Inf), New(Inf);
    root = 1, Tree[root].Rson = 2; 
    update(root);
}
inline int GetRankByVal(int node, int val) {
	if (node == 0) return 0;
	if (val == Tree[node].val) return Tree[Lnode].size + 1;
	if (val &lt; Tree[node].val) return GetRankByVal(Lnode, val);
	return GetRankByVal(Rnode, val) + Tree[Lnode].size + Tree[node].cnt;
}
inline int GetValByRank(int node, int rank) {
	if (node == 0) return Inf;
	if (Tree[Lnode].size &gt;= rank) return GetValByRank(Lnode, rank);
	if (Tree[Lnode].size + Tree[node].cnt &gt;= rank) return Tree[node].val;
	return GetValByRank(Rnode, rank - Tree[Lnode].size - Tree[node].cnt);
}
inline void zig(int &amp;node){
    int p = Lnode;
    Lnode = Tree[p].Rson, Tree[p].Rson = node, node = p; //该节点变为左儿子的右儿子
    update(Rnode), update(node);
}
inline void zag(int &amp;node){
    int p = Rnode;
    Rnode = Tree[p].Lson, Tree[p].Lson = node, node = p; //该节点变为右儿子的左儿子
    update(Lnode), update(node);
}
inline void insert(int &amp;node, int val){
    if(node == 0){
        node = New(val);
        return;
    }
    if(val == Tree[node].val){
        Tree[node].cnt++;
        update(node);  //插入后更新
        return;
    }
    if(val &lt; Tree[node].val){
        insert(Lnode, val);
        if(Tree[node].dat &lt; Tree[Lnode].dat) zig(node); // 不满足堆性质，右旋
    }
    else{
        insert(Rnode, val);
        if(Tree[node].dat &lt; Tree[Rnode].dat) zag(node); // 不满足堆性质，左旋
    }
    update(node);
}
inline int GetPre(int val){
	int pre = 1; // Tree[1].val == -INF
	int node = root;
	while(node){
		if(val == Tree[node].val){
			if(Lnode &gt; 0){
			    node = Lnode;
				while(Rnode &gt; 0) node = Rnode; // 左子树上一直向右走
				pre = node;
			}
			break;
		}
        //每经过一个结点 尝试更新前驱
		if(Tree[node].val &lt; val &amp;&amp; Tree[node].val &gt; Tree[pre].val) pre = node;
		node = val &lt; Tree[node].val ? Lnode : Rnode;
	}
	return Tree[pre].val;
}
inline int GetNext(int val){
	int nxt = 2; // Tree[2].val == INF
	int node = root;
	while(node){
		if(val == Tree[node].val){
			if(Rnode &gt; 0){
			    node = Rnode;
				while(Lnode &gt; 0) node = Lnode; // 右子树上一直向左走
				nxt = node;
			}
			break;
		}
        //每经过一个结点 尝试更新后继 
		if(Tree[node].val &gt; val &amp;&amp; Tree[node].val &lt; Tree[nxt].val) nxt = node;
		node = val &lt; Tree[node].val ? Lnode : Rnode;
	}
	return Tree[nxt].val;
}
inline void Remove(int &amp;node, int val){
	if (node == 0) return;
	if (val == Tree[node].val) { // 检索到了val
		if (Tree[node].cnt &gt; 1) { // 有重复，减少副本数即可
			Tree[node].cnt--;
            update(node);
			return;
		}
		if(Lnode || Rnode){ // 不是叶子节点，向下旋转
			if (Rnode == 0 || Tree[Lnode].dat &gt; Tree[Rnode].dat)
				zig(node), Remove(Rnode, val);
			else
				zag(node), Remove(Lnode, val);
			update(node);
		} else node = 0; // 叶子节点，删除
		return;
	}
	val &lt; Tree[node].val ? Remove(Lnode, val) : Remove(Rnode, val);
	update(node);
}
int main() {
	//srand(time(0));
	build();
	cin &gt;&gt; n;
	while (n--) {
		int opt, x;
		scanf(&quot;%d%d&quot;, &amp;opt, &amp;x);
		switch (opt) {
		case 1:
			insert(root, x);
			break;
		case 2:
			Remove(root, x);
			break;
		case 3:
			printf(&quot;%d\n&quot;, GetRankByVal(root, x) - 1);
			break;
		case 4:
			printf(&quot;%d\n&quot;, GetValByRank(root, x + 1));
			break;
		case 5:
			printf(&quot;%d\n&quot;, GetPre(x));
			break;
		case 6:
			printf(&quot;%d\n&quot;, GetNext(x));
			break;
		}
	}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P3369 【模板】普通平衡树(指针)]]></title>
        <id>https://shaun118294191.github.io/post/p3369-mo-ban-pu-tong-ping-heng-shu-zhi-zhen-shi-xian/</id>
        <link href="https://shaun118294191.github.io/post/p3369-mo-ban-pu-tong-ping-heng-shu-zhi-zhen-shi-xian/">
        </link>
        <updated>2020-03-02T13:37:45.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3369">题目链接</a><br>
您需要写一种数据结构，来维护一些数，其中需要提供以下操作：</p>
<p>1.插入 x 数</p>
<p>2.删除 x 数(若有多个相同的数，因只删除一个)</p>
<p>3.查询 x 数的排名(排名定义为比当前数小的数的个数 +1)</p>
<p>4.查询排名为 x 的数</p>
<p>5.求 x 的前驱(前驱定义为小于 x，且最大的数)</p>
<p>6.求 x 的后继(后继定义为大于 x，且最小的数)</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
constexpr int MAXN = 1e5 + 5;
constexpr int Inf = 0x3f3f3f3f;
using namespace std;
template &lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1; x = 0; 
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
struct Treap {
	Treap *lson, *rson;
	int key, priority;
	int cnt, size;
}Tree[MAXN &lt;&lt; 1], *rt;
#define Lson root-&gt;lson
#define Rson root-&gt;rson
int tot, Q, type, x;
inline void newNode(Treap *&amp;root, int key) {
	root = &amp;Tree[tot++];
	root-&gt;cnt = root-&gt;size = 1;
	root-&gt;key = key, root-&gt;priority = rand();
}
inline void update(Treap *root) {
	if (root == NULL) return; //空指针直接return
	int Lsize = (Lson == NULL) ? 0 : Lson-&gt;size, Rsize = (Rson == NULL) ? 0 : Rson-&gt;size;
	root-&gt;size = Lsize + Rsize + root-&gt;cnt;
}
inline void Lrotate(Treap *&amp;root) { //左旋
	Treap *R = Rson;
	Rson = R-&gt;lson, R-&gt;lson = root, root = R;
	update(root-&gt;lson), update(root);
}
inline void Rrotate(Treap *&amp;root) { //右旋
	Treap *L = Lson;
	Lson = L-&gt;rson, L-&gt;rson = root, root = L;
	update(root-&gt;rson), update(root);
}
inline int getPre(Treap *root, int key, int pre) {
	if (root == NULL) return pre;
	if (key &lt;= root-&gt;key) return getPre(Lson, key, pre);
	return getPre(Rson, key, max(pre, root-&gt;key));
}
inline int getNext(Treap *root, int key, int next) {
	if (root == NULL) return next;
	if (key &gt;= root-&gt;key) return getNext(Rson, key, next);
	return getNext(Lson, key, min(next, root-&gt;key));
}
inline int getRank(Treap *root, int key) {
	if (root == NULL) return 0;
	int Lsize = Lson == NULL ? 0 : Lson-&gt;size; //左儿子有多少数
	if (key == root-&gt;key) return Lsize + 1; 
	if (key &lt; root-&gt;key) return getRank(Lson, key);
	return getRank(Rson, key) + Lsize + root-&gt;cnt;
}
inline int getVal(Treap *root, int rank) {
	if (root == NULL) return Inf; 
	int Lsize = Lson == NULL ? 0 : Lson-&gt;size; //左儿子有多少数
	if (Lsize &gt;= rank) return getVal(Lson, rank); 
	if (Lsize + root-&gt;cnt &gt;= rank) return root-&gt;key;
	return getVal(Rson, rank - Lsize - root-&gt;cnt);
}
inline void insert(Treap *&amp;root, int key) {
	if (root == NULL) { //不存在该key 新建节点
		newNode(root, key);
		return;
	}
	if (key == root-&gt;key) root-&gt;cnt++, update(root); //已存在key cnt++, update
	else if (key &lt; root-&gt;key) { //搜索左儿子
		insert(Lson, key);
		if (root-&gt;priority &lt; Lson-&gt;priority) Rrotate(root);
	} else {
		insert(Rson, key); //搜索右儿子
		if (root-&gt;priority &lt; Rson-&gt;priority) Lrotate(root);
	}
	update(root);
}
inline void remove(Treap *&amp;root, int key) {
	if (root == NULL) return;
	if (key == root-&gt;key) {
		if (root-&gt;cnt &gt; 1) root-&gt;cnt--; //副本减少1
		else if (root-&gt;rson == NULL) root = root-&gt;lson; //右儿子为空 该点地址变为左儿子的
		else if (root-&gt;lson == NULL) root = root-&gt;rson; //左儿子为空 该点地址变为右儿子的
		else { //根据priority将该节点旋转至根 注意root可能旋为NULL
			if (Lson-&gt;priority &gt; Rson-&gt;priority) Rrotate(root), remove(Rson, key);
			else Lrotate(root), remove(Lson, key);
		}
	} else key &lt; root-&gt;key ? remove(Lson, key) : remove(Rson, key); //查找左右儿子
	update(root);
}
int main(){
	srand(time(0));
	read(Q);
    while (Q--) {
        read(type), read(x);
        switch (type) {
            case 1:
                insert(rt, x);
                break;
            case 2:
                remove(rt, x);
                break;
            case 3:
                printf(&quot;%d\n&quot;, getRank(rt, x));
                break;
            case 4:
                printf(&quot;%d\n&quot;, getVal(rt, x));
                break;
            case 5:
                printf(&quot;%d\n&quot;, getPre(rt, x, -Inf));
                break;
            case 6:
                printf(&quot;%d\n&quot;, getNext(rt, x, Inf));
                break;
        }
    }
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[T122393 À la Volonté du Peuple]]></title>
        <id>https://shaun118294191.github.io/post/t122393-a-la-volonte-du-peuple/</id>
        <link href="https://shaun118294191.github.io/post/t122393-a-la-volonte-du-peuple/">
        </link>
        <updated>2020-03-02T02:32:08.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：<br>
A solitary spark can start a prairie fire.</p>
<p>You are given a weighted connected undirected graph with nn vertices and mm edges. You know that someone light up a fire at vertex 1, which will burn the current position into dust immediately and expand to adjacent places at the speed 1 mile per second. The fire will split at the vertices to all those edges who have not been lighten up, and will cause a blast when at least two fires meet at the same point.</p>
<p>Revolutionaries love explosions. They want you to count the number of explosions that will happen on the graph.</p>
<p>It's guaranteed that the graph is connected.<br>
<img src="https://shaun118294191.github.io/post-images/1583116803542.png" alt="" loading="lazy"></p>
<p>The graph may contain self loops and multiple edges. Example 1shows the method to deal with them.</p>
<p>The size of input file may be large. Please, do not read input by too slow ways.<br>
INPUT:<br>
2 3<br>
1 1 1<br>
1 2 1<br>
1 2 1<br>
OUTPUT:<br>
2</p>
<p>INPUT:<br>
4 5<br>
1 2 1<br>
1 3 1<br>
2 3 1<br>
2 4 1<br>
3 4 1<br>
OUTPUT:<br>
2<br>
<img src="https://shaun118294191.github.io/post-images/1583116672068.png" alt="" loading="lazy"></p>
<p>先求出最短路，如果一个点的最短路前驱 &gt;= 2，则该点能产生blast；对于不在最短路上的边，若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mo>(</mo><mi>d</mi><mi>i</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>−</mo><mi>d</mi><mi>i</mi><mi>s</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>)</mo><mi mathvariant="normal">∣</mi><mo>&lt;</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">|(dis[i] - dis[j])| &lt; w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mclose">)</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>则也会产生blast(注意反边不要再加)。</p>
<pre><code class="language-cpp">for (int cur = 2; cur &lt;= n; cur++) {
	int cnt = 0;
	for(int i = head[cur]; ~i; i = Edge[i].next) {
		int to = Edge[i].to, w = Edge[i].w;
		if (dis[cur] == dis[to] + w) cnt++;
		else if (cur &gt;= to &amp;&amp; abs(dis[to] - dis[cur]) &lt; w) sum++;
	}
    if (cnt &gt; 1) sum++;
}
</code></pre>
<p>Code:</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long 
#define pii pair&lt;int, int&gt; 
constexpr int MAXN = 5e5 + 5;
using namespace std;
template &lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1; x = 0; 
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
struct node {
	int to, w, next;
	node(){}
	node(int _to, int _w, int _next) : to(_to), w(_w), next(_next) {}
}Edge[MAXN &lt;&lt; 3];
int head[MAXN], tot, n, m, sum, cnt[MAXN], vis[MAXN], dis[MAXN], depth[MAXN];
int u[MAXN], v[MAXN], w[MAXN];
inline void add (int from, int to, int w) {
	Edge[tot] = node(to, w, head[from]), head[from] = tot++;
	Edge[tot] = node(from, w, head[to]), head[to] = tot++;
}
inline void dijkstra(){
	memset(dis, 0x3f, sizeof(dis)), cnt[1] = 0;
    priority_queue&lt; pii , vector&lt;pii&gt; , greater&lt;pii&gt; &gt; q;
    q.push({dis[1] = 0, 1});
    while(!q.empty()){
        int cur = q.top().second;
        q.pop();
        if(vis[cur]) continue;
        for(int i = head[cur]; ~i; i = Edge[i].next){
            int go = Edge[i].to, w = Edge[i].w;
            if(dis[go] &gt; dis[cur] + w){
                dis[go] = dis[cur] + w;
                q.push({dis[go], go});
            } 
        } 
        vis[cur] = 1;
    }
}
signed main(){
	read(n), read(m);
	memset(head, -1, sizeof(head));
	for (int i = 1; i &lt;= m; i++) {
		read(u[i]), read(v[i]), read(w[i]);
		if (u[i] == v[i]) sum++;
		else add(u[i], v[i], w[i]);
	}
	dijkstra();
	for (int cur = 2; cur &lt;= n; cur++) {
		int cnt = 0;
		for(int i = head[cur]; ~i; i = Edge[i].next) {
			int to = Edge[i].to, w = Edge[i].w;
			if (dis[cur] == dis[to] + w) cnt++;
			else if (cur &gt;= to &amp;&amp; abs(dis[to] - dis[cur]) &lt; w) sum++;
		}
		if (cnt &gt; 1) sum++;
	}
	cout &lt;&lt; sum &lt;&lt; endl;
	return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>