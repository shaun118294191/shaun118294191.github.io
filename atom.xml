<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://shaun118294191.github.io</id>
    <title>Shaun</title>
    <updated>2020-03-04T00:39:02.930Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://shaun118294191.github.io"/>
    <link rel="self" href="https://shaun118294191.github.io/atom.xml"/>
    <subtitle>Valar morghulis Valar Dohaeris</subtitle>
    <logo>https://shaun118294191.github.io/images/avatar.png</logo>
    <icon>https://shaun118294191.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Shaun</rights>
    <entry>
        <title type="html"><![CDATA[fhq-Treap]]></title>
        <id>https://shaun118294191.github.io/post/fhq-treap/</id>
        <link href="https://shaun118294191.github.io/post/fhq-treap/">
        </link>
        <updated>2020-03-03T13:49:12.000Z</updated>
        <content type="html"><![CDATA[<p>无旋Treap核心操作</p>
<p><strong>1.split</strong><br>
将一个平衡树分成两棵树；</p>
<ul>
<li>split有两种： 一种是按照权值split，一种是按照size来split。</li>
<li>如果按照权值split，那么分出来两棵树的第一棵树上的每一个数的大小都小于（或小于等于，视具体情况而定）给定的key值;</li>
<li>如果按照size split，那么分出来两棵树的第一棵树恰好有x个节点。</li>
</ul>
<pre><code class="language-cpp">inline void split(Treap *root, Treap *&amp;L, Treap *&amp;R, int key) { //L为分裂后的左树 R为分裂后的右树
    if (root == NULL) {
	L = NULL, R = NULL; //分到底了 返回
	return;
	}
	if (root-&gt;key &lt;= key) L = root, split(Rson, Rson, R, key); //左子树key一定都小于key, 再分裂root右子树给L右子树与R
	else R = root, split(Lson, L, Lson, key); 
	update(root);//更新
}
</code></pre>
<p><strong>2.merge</strong><br>
将两颗分开的树合在一起，维护大根堆或小根堆性质</p>
<pre><code class="language-cpp">inline void merge(Treap *&amp;root, Treap *L, Treap *R) {
	if (L == NULL) {root = R; return;}
	if (R == NULL) {root = L; return;} 
	if (L-&gt;priority &lt; R-&gt;priority) root = L, merge(Rson, Rson, R); //L加到root上，合并右子树
	else root = R, merge(Lson, L, Lson); //R加到root上, 合并左子树
	update(root);
}
</code></pre>
<p>注意: 有merge和split操作时需要引用Treap *&amp;root。</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
constexpr int MAXN = 1e6 + 6;
constexpr int Inf = 2e9;
using namespace std;
template &lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1; x = 0; 
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
struct Treap {
	Treap *lson, *rson;
	int key, priority;
	int size;
}Tree[MAXN], *rt;
int tot, Q, type, x;
#define Lson root-&gt;lson
#define Rson root-&gt;rson
inline void newNode(Treap *&amp;root, int key) {
	root = &amp;Tree[++tot], root-&gt;size = 1;
	root-&gt;key = key, root-&gt;priority = rand();
}
inline void update(Treap *root) {
	int Lsize = Lson ? Lson-&gt;size : 0, Rsize = Rson ? Rson-&gt;size : 0;
	root-&gt;size = Lsize + Rsize + 1;
}
inline void split(Treap *root, Treap *&amp;L, Treap *&amp;R, int key) {
	if (root == NULL) {
		L = NULL, R = NULL;
		return;
	}
	if (root-&gt;key &lt;= key) L = root, split(Rson, Rson, R, key);
	else R = root, split(Lson, L, Lson, key);
	update(root);
}
inline void merge(Treap *&amp;root, Treap *L, Treap *R) {
	if (L == NULL) {root = R; return;}
	if (R == NULL) {root = L; return;}
	if (L-&gt;priority &lt; R-&gt;priority) root = L, merge(Rson, Rson, R);
	else root = R, merge(Lson, L, Lson);
	update(root);
}
inline void insert(Treap *&amp;root, int key) {
	Treap *L = NULL, *R = NULL, *tmp = NULL;
	newNode(tmp, key); //新建节点
	split(root, L, R, key); //按key分裂
	merge(L, L, tmp), merge(root, L, R); //tmp与L合并，L与R合并
}
inline void remove(Treap *&amp;root, int key) {
	Treap *L = NULL, *R = NULL, *tmp = NULL;
	split(root, L, R, key);
	split(L, L, tmp, key - 1); //按key - 1分裂 tmp的值都&gt;= key
	merge(tmp, tmp-&gt;lson, tmp-&gt;rson); //合并lson rson，从而减去一个key值
	merge(L, L, tmp), merge(root, L, R); //合并回root
}
inline int getVal(Treap *root, int rank) {//排名为rank的值
	while (true) {
		if (root == NULL) return 0;
		int Lsize = Lson ? Lson-&gt;size : 0;
		if (Lsize + 1 == rank) return root-&gt;key;
		if (Lsize &gt;= rank) root = Lson;
		else rank -= Lsize + 1, root = Rson;
	}
}
inline int getRank(Treap *&amp;root, int key) { 
	Treap *L = NULL, *R = NULL;
	split(root, L, R, key - 1);
	int res = (L ? L-&gt;size : 0) + 1;
	merge(root, L, R);
	return res;
}
inline int getPre(Treap *&amp;root, int key) {
	Treap *L = NULL, *R = NULL;
	split(root, L, R, key - 1);
	int res = getVal(L, L-&gt;size);
	merge(root, L, R);
	return res;
}
inline int getNext(Treap *&amp;root, int key) {
	Treap *L = NULL, *R = NULL;
	split(root, L, R, key);
	int res = getVal(R, 1);
	merge(root, L, R);
	return res;
}
int main(){
	srand(time(0));
	read(Q);
    while (Q--) {
        read(type), read(x);
        switch (type) {
            case 1:
                insert(rt, x);
                break;
            case 2:
                remove(rt, x);
                break;
            case 3:
                printf(&quot;%d\n&quot;, getRank(rt, x));
                break;
            case 4:
                printf(&quot;%d\n&quot;, getVal(rt, x));
                break;
            case 5:
                printf(&quot;%d\n&quot;, getPre(rt, x));
                break;
            case 6:
                printf(&quot;%d\n&quot;, getNext(rt, x));
                break;
        }
    }
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF813E Army Creation]]></title>
        <id>https://shaun118294191.github.io/post/cf813e-army-creation/</id>
        <link href="https://shaun118294191.github.io/post/cf813e-army-creation/">
        </link>
        <updated>2020-03-03T13:41:53.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF813E">题目链接</a><br>
方法和<a href="https://www.luogu.com.cn/blog/user48611/sp3267-dquery-d-query">SP3267 DQUERY - D-query</a>类似，本题更具一般性。</p>
<ul>
<li>
<p>可以求出每个数前面第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个数的位置(不足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个设为0)。</p>
<pre><code class="language-cpp">for (int i = 1, x; i &lt;= n; i++) {
    x = read(), pos[x].push_back(i);
    int sz = pos[x].size();
    if (sz &gt; k) sz = pos[x][sz - k - 1]; else sz = 0;
    modify(root[i - 1], newNode(root[i]), 0, n, sz);
}
</code></pre>
</li>
<li>
<p>询问即求有多少个数，其前面第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个数的位置小于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">l - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</p>
</li>
</ul>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
constexpr int MAXN = 1e5 + 5;
constexpr int LOG = 20;
using namespace std;
inline int read(){
    int x = 0, f = 1;
    char ch = getchar();
    while(!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while(isdigit(ch)) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch -48, ch = getchar();
    return x * f;
}
struct Node {
	Node * lson, *rson;
	int cnt;
}Tree[MAXN * LOG], *root[MAXN];
int tot, n, m, k, last;
inline Node * newNode(Node * &amp;root) { return root = &amp;Tree[tot++];}
inline void build(int L, int R, Node *root) {
	if (L == R) return;
	int mid = (L + R) &gt;&gt; 1;
	build(L, mid, newNode(root-&gt;lson)), build(mid + 1, R, newNode(root-&gt;rson));
}
inline void modify(Node *pre, Node *cur, int L, int R, int pos) {
	*cur = *pre;
	if (L == R) {
		cur-&gt;cnt++;
		return;
	}
	int mid = (L + R) &gt;&gt; 1;
	if (pos &lt;= mid) modify(pre-&gt;lson, newNode(cur-&gt;lson), L, mid, pos);
	else modify(pre-&gt;rson, newNode(cur-&gt;rson), mid + 1, R, pos);
	cur-&gt;cnt = cur-&gt;lson-&gt;cnt + cur-&gt;rson-&gt;cnt;
}
inline int query(Node * pre, Node * cur, int L, int R, int qL, int qR) {
	if (qL &lt;= L &amp;&amp; R &lt;= qR) return cur-&gt;cnt - pre-&gt;cnt;
	int mid = (L + R ) &gt;&gt; 1, ans = 0;
	if (qL &lt;= mid) ans += query(pre-&gt;lson, cur-&gt;lson, L, mid, qL, qR);
	if (qR &gt; mid) ans += query(pre-&gt;rson, cur-&gt;rson, mid + 1, R, qL, qR);
	return ans;
}
vector&lt;int&gt;pos[MAXN];
int main(){
	n = read(), k = read();
	build(0, n, newNode(root[0]));
	for (int i = 1, x; i &lt;= n; i++) {
		x = read(), pos[x].push_back(i);
        int sz = pos[x].size();
        if (sz &gt; k) sz = pos[x][sz - k - 1]; else sz = 0;
        modify(root[i - 1], newNode(root[i]), 0, n, sz);
    }
	m = read();
	while (m--) {
		int l = read(), r = read();
        l = (l + last) % n + 1, r = (r + last) % n + 1;
        if (l &gt; r) swap(l, r);
		printf(&quot;%d\n&quot;, last = query(root[l - 1], root[r], 0, n, 0, l - 1));
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P3258 [JLOI2014]松鼠的新家]]></title>
        <id>https://shaun118294191.github.io/post/p3258-jloi2014song-shu-de-xin-jia/</id>
        <link href="https://shaun118294191.github.io/post/p3258-jloi2014song-shu-de-xin-jia/">
        </link>
        <updated>2020-03-03T11:27:21.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3258">题目链接</a><br>
本题树上差分解决即可。</p>
<p>对于房间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>…</mo><msub><mi>a</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_1…a_{n - 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>，将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_{i + 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>路径上的点覆盖。</p>
<p>由于这样会使<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>2</mn></msub><mo>…</mo><msub><mi>a</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_2…a_{n - 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>都被多覆盖一次，而题目说<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>不需要再加1，所以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>2</mn></msub><mo>…</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_2…a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的访问次数减1即可。</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
constexpr int MAXN = 3e5 + 5;
constexpr int LOG = 19;
using namespace std;
template &lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1; x = 0; 
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
vector&lt;int&gt; G[MAXN];
int n, path[MAXN], f[MAXN][LOG], depth[MAXN], delta[MAXN];
inline void dfs(int cur, int fa) {
	depth[cur] = depth[fa] + 1, f[cur][0] = fa;
	for (int i = 1; i &lt; LOG; i++) f[cur][i] = f[f[cur][i - 1]][i - 1];
	for (auto to : G[cur]) {
		if (to == fa) continue;
		dfs(to, cur);
	}
}
inline void getCnt(int cur, int fa) {
	for (auto to : G[cur]) {
		if (to == fa) continue;
		getCnt(to, cur);
		delta[cur] += delta[to];
	}
}
inline int LCA(int u, int v) {
	if (depth[u] &lt; depth[v]) swap(u, v);
	for (int i = LOG - 1; i &gt;= 0; i--) 
		if (depth[f[u][i]] &gt;= depth[v])
			u = f[u][i];
	if (u == v) return u;
	for (int i = LOG - 1; i &gt;= 0; i--) 
		if (f[u][i] != f[v][i])
			u = f[u][i], v = f[v][i];
	return f[u][0];
}
signed main(){
	read(n);
	for (int i = 1; i &lt;= n; i++) read(path[i]);
	for (int i = 1, u, v; i &lt; n; i++) {
		read(u), read(v);
		G[u].emplace_back(v), G[v].push_back(u);
	}
	dfs(1, 0);
	for (int i = 1; i &lt; n; i++) {
		int from = path[i], to = path[i + 1], lca = LCA(to, from);
		delta[from]++, delta[to]++, delta[lca]--, delta[f[lca][0]]--;
	}
	getCnt(1, 0);
	for (int i = 2; i &lt;= n; i++) delta[path[i]]--;
	for (int i = 1; i &lt;= n; i++) printf(&quot;%d\n&quot;, delta[i]);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P3369 【模板】普通平衡树(数组)]]></title>
        <id>https://shaun118294191.github.io/post/p3369-mo-ban-pu-tong-ping-heng-shu-shu-zu/</id>
        <link href="https://shaun118294191.github.io/post/p3369-mo-ban-pu-tong-ping-heng-shu-shu-zu/">
        </link>
        <updated>2020-03-02T13:39:48.000Z</updated>
        <content type="html"><![CDATA[<p>您需要写一种数据结构，来维护一些数，其中需要提供以下操作：</p>
<p>1.插入 x 数</p>
<p>2.删除 x 数(若有多个相同的数，因只删除一个)</p>
<p>3.查询 x 数的排名(排名定义为比当前数小的数的个数 +1)</p>
<p>4.查询排名为 x 的数</p>
<p>5.求 x 的前驱(前驱定义为小于 x，且最大的数)</p>
<p>6.求 x 的后继(后继定义为大于 x，且最小的数)</p>
<p>Treap:</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 1e6 + 6;
const int Inf = 1 &lt;&lt; 30;
struct Treap{
    int Lson, Rson;
    int val, dat;
    int cnt, size;
}Tree[MAXN];
#define Lnode Tree[node].Lson
#define Rnode Tree[node].Rson
int tot, root, n;
inline int New(int val){
    Tree[++tot].val = val;
    Tree[tot].dat = rand();
    Tree[tot].cnt = Tree[tot].size = 1; 
    return tot;
}
inline void update(int node){
    Tree[node].size = Tree[Lnode].size + Tree[Rnode].size + Tree[node].cnt;
}
inline void build(){
    New(-Inf), New(Inf);
    root = 1, Tree[root].Rson = 2; 
    update(root);
}
inline int GetRankByVal(int node, int val) {
	if (node == 0) return 0;
	if (val == Tree[node].val) return Tree[Lnode].size + 1;
	if (val &lt; Tree[node].val) return GetRankByVal(Lnode, val);
	return GetRankByVal(Rnode, val) + Tree[Lnode].size + Tree[node].cnt;
}
inline int GetValByRank(int node, int rank) {
	if (node == 0) return Inf;
	if (Tree[Lnode].size &gt;= rank) return GetValByRank(Lnode, rank);
	if (Tree[Lnode].size + Tree[node].cnt &gt;= rank) return Tree[node].val;
	return GetValByRank(Rnode, rank - Tree[Lnode].size - Tree[node].cnt);
}
inline void zig(int &amp;node){
    int p = Lnode;
    Lnode = Tree[p].Rson, Tree[p].Rson = node, node = p; //该节点变为左儿子的右儿子
    update(Rnode), update(node);
}
inline void zag(int &amp;node){
    int p = Rnode;
    Rnode = Tree[p].Lson, Tree[p].Lson = node, node = p; //该节点变为右儿子的左儿子
    update(Lnode), update(node);
}
inline void insert(int &amp;node, int val){
    if(node == 0){
        node = New(val);
        return;
    }
    if(val == Tree[node].val){
        Tree[node].cnt++;
        update(node);  //插入后更新
        return;
    }
    if(val &lt; Tree[node].val){
        insert(Lnode, val);
        if(Tree[node].dat &lt; Tree[Lnode].dat) zig(node); // 不满足堆性质，右旋
    }
    else{
        insert(Rnode, val);
        if(Tree[node].dat &lt; Tree[Rnode].dat) zag(node); // 不满足堆性质，左旋
    }
    update(node);
}
inline int GetPre(int val){
	int pre = 1; // Tree[1].val == -INF
	int node = root;
	while(node){
		if(val == Tree[node].val){
			if(Lnode &gt; 0){
			    node = Lnode;
				while(Rnode &gt; 0) node = Rnode; // 左子树上一直向右走
				pre = node;
			}
			break;
		}
        //每经过一个结点 尝试更新前驱
		if(Tree[node].val &lt; val &amp;&amp; Tree[node].val &gt; Tree[pre].val) pre = node;
		node = val &lt; Tree[node].val ? Lnode : Rnode;
	}
	return Tree[pre].val;
}
inline int GetNext(int val){
	int nxt = 2; // Tree[2].val == INF
	int node = root;
	while(node){
		if(val == Tree[node].val){
			if(Rnode &gt; 0){
			    node = Rnode;
				while(Lnode &gt; 0) node = Lnode; // 右子树上一直向左走
				nxt = node;
			}
			break;
		}
        //每经过一个结点 尝试更新后继 
		if(Tree[node].val &gt; val &amp;&amp; Tree[node].val &lt; Tree[nxt].val) nxt = node;
		node = val &lt; Tree[node].val ? Lnode : Rnode;
	}
	return Tree[nxt].val;
}
inline void Remove(int &amp;node, int val){
	if (node == 0) return;
	if (val == Tree[node].val) { // 检索到了val
		if (Tree[node].cnt &gt; 1) { // 有重复，减少副本数即可
			Tree[node].cnt--;
            update(node);
			return;
		}
		if(Lnode || Rnode){ // 不是叶子节点，向下旋转
			if (Rnode == 0 || Tree[Lnode].dat &gt; Tree[Rnode].dat)
				zig(node), Remove(Rnode, val);
			else
				zag(node), Remove(Lnode, val);
			update(node);
		} else node = 0; // 叶子节点，删除
		return;
	}
	val &lt; Tree[node].val ? Remove(Lnode, val) : Remove(Rnode, val);
	update(node);
}
int main() {
	//srand(time(0));
	build();
	cin &gt;&gt; n;
	while (n--) {
		int opt, x;
		scanf(&quot;%d%d&quot;, &amp;opt, &amp;x);
		switch (opt) {
		case 1:
			insert(root, x);
			break;
		case 2:
			Remove(root, x);
			break;
		case 3:
			printf(&quot;%d\n&quot;, GetRankByVal(root, x) - 1);
			break;
		case 4:
			printf(&quot;%d\n&quot;, GetValByRank(root, x + 1));
			break;
		case 5:
			printf(&quot;%d\n&quot;, GetPre(x));
			break;
		case 6:
			printf(&quot;%d\n&quot;, GetNext(x));
			break;
		}
	}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P3369 【模板】普通平衡树(指针)]]></title>
        <id>https://shaun118294191.github.io/post/p3369-mo-ban-pu-tong-ping-heng-shu-zhi-zhen-shi-xian/</id>
        <link href="https://shaun118294191.github.io/post/p3369-mo-ban-pu-tong-ping-heng-shu-zhi-zhen-shi-xian/">
        </link>
        <updated>2020-03-02T13:37:45.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3369">题目链接</a><br>
您需要写一种数据结构，来维护一些数，其中需要提供以下操作：</p>
<p>1.插入 x 数</p>
<p>2.删除 x 数(若有多个相同的数，因只删除一个)</p>
<p>3.查询 x 数的排名(排名定义为比当前数小的数的个数 +1)</p>
<p>4.查询排名为 x 的数</p>
<p>5.求 x 的前驱(前驱定义为小于 x，且最大的数)</p>
<p>6.求 x 的后继(后继定义为大于 x，且最小的数)</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
constexpr int MAXN = 1e5 + 5;
constexpr int Inf = 0x3f3f3f3f;
using namespace std;
template &lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1; x = 0; 
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
struct Treap {
	Treap *lson, *rson;
	int key, priority;
	int cnt, size;
}Tree[MAXN &lt;&lt; 1], *rt;
#define Lson root-&gt;lson
#define Rson root-&gt;rson
int tot, Q, type, x;
inline void newNode(Treap *&amp;root, int key) {
	root = &amp;Tree[tot++];
	root-&gt;cnt = root-&gt;size = 1;
	root-&gt;key = key, root-&gt;priority = rand();
}
inline void update(Treap *root) {
	if (root == NULL) return; //空指针直接return
	int Lsize = (Lson == NULL) ? 0 : Lson-&gt;size, Rsize = (Rson == NULL) ? 0 : Rson-&gt;size;
	root-&gt;size = Lsize + Rsize + root-&gt;cnt;
}
inline void Lrotate(Treap *&amp;root) { //左旋
	Treap *R = Rson;
	Rson = R-&gt;lson, R-&gt;lson = root, root = R;
	update(root-&gt;lson), update(root);
}
inline void Rrotate(Treap *&amp;root) { //右旋
	Treap *L = Lson;
	Lson = L-&gt;rson, L-&gt;rson = root, root = L;
	update(root-&gt;rson), update(root);
}
inline int getPre(Treap *root, int key, int pre) {
	if (root == NULL) return pre;
	if (key &lt;= root-&gt;key) return getPre(Lson, key, pre);
	return getPre(Rson, key, max(pre, root-&gt;key));
}
inline int getNext(Treap *root, int key, int next) {
	if (root == NULL) return next;
	if (key &gt;= root-&gt;key) return getNext(Rson, key, next);
	return getNext(Lson, key, min(next, root-&gt;key));
}
inline int getRank(Treap *root, int key) {
	if (root == NULL) return 0;
	int Lsize = Lson == NULL ? 0 : Lson-&gt;size; //左儿子有多少数
	if (key == root-&gt;key) return Lsize + 1; 
	if (key &lt; root-&gt;key) return getRank(Lson, key);
	return getRank(Rson, key) + Lsize + root-&gt;cnt;
}
inline int getVal(Treap *root, int rank) {
	if (root == NULL) return Inf; 
	int Lsize = Lson == NULL ? 0 : Lson-&gt;size; //左儿子有多少数
	if (Lsize &gt;= rank) return getVal(Lson, rank); 
	if (Lsize + root-&gt;cnt &gt;= rank) return root-&gt;key;
	return getVal(Rson, rank - Lsize - root-&gt;cnt);
}
inline void insert(Treap *&amp;root, int key) {
	if (root == NULL) { //不存在该key 新建节点
		newNode(root, key);
		return;
	}
	if (key == root-&gt;key) root-&gt;cnt++, update(root); //已存在key cnt++, update
	else if (key &lt; root-&gt;key) { //搜索左儿子
		insert(Lson, key);
		if (root-&gt;priority &lt; Lson-&gt;priority) Rrotate(root);
	} else {
		insert(Rson, key); //搜索右儿子
		if (root-&gt;priority &lt; Rson-&gt;priority) Lrotate(root);
	}
	update(root);
}
inline void remove(Treap *&amp;root, int key) {
	if (root == NULL) return;
	if (key == root-&gt;key) {
		if (root-&gt;cnt &gt; 1) root-&gt;cnt--; //副本减少1
		else if (root-&gt;rson == NULL) root = root-&gt;lson; //右儿子为空 该点地址变为左儿子的
		else if (root-&gt;lson == NULL) root = root-&gt;rson; //左儿子为空 该点地址变为右儿子的
		else { //根据priority将该节点旋转至根 注意root可能旋为NULL
			if (Lson-&gt;priority &gt; Rson-&gt;priority) Rrotate(root), remove(Rson, key);
			else Lrotate(root), remove(Lson, key);
		}
	} else key &lt; root-&gt;key ? remove(Lson, key) : remove(Rson, key); //查找左右儿子
	update(root);
}
int main(){
	srand(time(0));
	read(Q);
    while (Q--) {
        read(type), read(x);
        switch (type) {
            case 1:
                insert(rt, x);
                break;
            case 2:
                remove(rt, x);
                break;
            case 3:
                printf(&quot;%d\n&quot;, getRank(rt, x));
                break;
            case 4:
                printf(&quot;%d\n&quot;, getVal(rt, x));
                break;
            case 5:
                printf(&quot;%d\n&quot;, getPre(rt, x, -Inf));
                break;
            case 6:
                printf(&quot;%d\n&quot;, getNext(rt, x, Inf));
                break;
        }
    }
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[T122393 À la Volonté du Peuple]]></title>
        <id>https://shaun118294191.github.io/post/t122393-a-la-volonte-du-peuple/</id>
        <link href="https://shaun118294191.github.io/post/t122393-a-la-volonte-du-peuple/">
        </link>
        <updated>2020-03-02T02:32:08.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：<br>
A solitary spark can start a prairie fire.</p>
<p>You are given a weighted connected undirected graph with nn vertices and mm edges. You know that someone light up a fire at vertex 1, which will burn the current position into dust immediately and expand to adjacent places at the speed 1 mile per second. The fire will split at the vertices to all those edges who have not been lighten up, and will cause a blast when at least two fires meet at the same point.</p>
<p>Revolutionaries love explosions. They want you to count the number of explosions that will happen on the graph.</p>
<p>It's guaranteed that the graph is connected.<br>
<img src="https://shaun118294191.github.io/post-images/1583116803542.png" alt="" loading="lazy"></p>
<p>The graph may contain self loops and multiple edges. Example 1shows the method to deal with them.</p>
<p>The size of input file may be large. Please, do not read input by too slow ways.<br>
INPUT:<br>
2 3<br>
1 1 1<br>
1 2 1<br>
1 2 1<br>
OUTPUT:<br>
2</p>
<p>INPUT:<br>
4 5<br>
1 2 1<br>
1 3 1<br>
2 3 1<br>
2 4 1<br>
3 4 1<br>
OUTPUT:<br>
2<br>
<img src="https://shaun118294191.github.io/post-images/1583116672068.png" alt="" loading="lazy"></p>
<p>先求出最短路，如果一个点的最短路前驱 &gt;= 2，则该点能产生blast；对于不在最短路上的边，若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mo>(</mo><mi>d</mi><mi>i</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>−</mo><mi>d</mi><mi>i</mi><mi>s</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>)</mo><mi mathvariant="normal">∣</mi><mo>&lt;</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">|(dis[i] - dis[j])| &lt; w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mclose">)</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>则也会产生blast(注意反边不要再加)。</p>
<pre><code class="language-cpp">for (int cur = 2; cur &lt;= n; cur++) {
	int cnt = 0;
	for(int i = head[cur]; ~i; i = Edge[i].next) {
		int to = Edge[i].to, w = Edge[i].w;
		if (dis[cur] == dis[to] + w) cnt++;
		else if (cur &gt;= to &amp;&amp; abs(dis[to] - dis[cur]) &lt; w) sum++;
	}
    if (cnt &gt; 1) sum++;
}
</code></pre>
<p>Code:</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long 
#define pii pair&lt;int, int&gt; 
constexpr int MAXN = 5e5 + 5;
using namespace std;
template &lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1; x = 0; 
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
struct node {
	int to, w, next;
	node(){}
	node(int _to, int _w, int _next) : to(_to), w(_w), next(_next) {}
}Edge[MAXN &lt;&lt; 3];
int head[MAXN], tot, n, m, sum, cnt[MAXN], vis[MAXN], dis[MAXN], depth[MAXN];
int u[MAXN], v[MAXN], w[MAXN];
inline void add (int from, int to, int w) {
	Edge[tot] = node(to, w, head[from]), head[from] = tot++;
	Edge[tot] = node(from, w, head[to]), head[to] = tot++;
}
inline void dijkstra(){
	memset(dis, 0x3f, sizeof(dis)), cnt[1] = 0;
    priority_queue&lt; pii , vector&lt;pii&gt; , greater&lt;pii&gt; &gt; q;
    q.push({dis[1] = 0, 1});
    while(!q.empty()){
        int cur = q.top().second;
        q.pop();
        if(vis[cur]) continue;
        for(int i = head[cur]; ~i; i = Edge[i].next){
            int go = Edge[i].to, w = Edge[i].w;
            if(dis[go] &gt; dis[cur] + w){
                dis[go] = dis[cur] + w;
                q.push({dis[go], go});
            } 
        } 
        vis[cur] = 1;
    }
}
signed main(){
	read(n), read(m);
	memset(head, -1, sizeof(head));
	for (int i = 1; i &lt;= m; i++) {
		read(u[i]), read(v[i]), read(w[i]);
		if (u[i] == v[i]) sum++;
		else add(u[i], v[i], w[i]);
	}
	dijkstra();
	for (int cur = 2; cur &lt;= n; cur++) {
		int cnt = 0;
		for(int i = head[cur]; ~i; i = Edge[i].next) {
			int to = Edge[i].to, w = Edge[i].w;
			if (dis[cur] == dis[to] + w) cnt++;
			else if (cur &gt;= to &amp;&amp; abs(dis[to] - dis[cur]) &lt; w) sum++;
		}
		if (cnt &gt; 1) sum++;
	}
	cout &lt;&lt; sum &lt;&lt; endl;
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P3605 [USACO17JAN]Promotion Counting P]]></title>
        <id>https://shaun118294191.github.io/post/p3605-usaco17janpromotion-counting-p/</id>
        <link href="https://shaun118294191.github.io/post/p3605-usaco17janpromotion-counting-p/">
        </link>
        <updated>2020-03-01T06:24:30.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3605">题目链接</a></p>
<p>一颗n个节点的树，每个节点有一个点权值。求节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>的子树中比其权值大的节点的个数。</p>
<p>离散化后对于每个点建立一个动态开点的权值线段树，记录cnt。</p>
<pre><code class="language-cpp">inline Node * newNode(Node * &amp;root) { 
	if (root == NULL) root = &amp;Tree[++tot];
	return root;
}
for (int i = 1; i &lt;= n; i++) 
		newNode(root[i]), insert(root[i], 1, cnt, Map[val[i]]);
inline void insert(Node *root, int L, int R, int val) {
	if (L == R) {
		root-&gt;cnt++;
		return;
	}
	int mid = (L + R) &gt;&gt; 1;
	if (val &lt;= mid) insert(newNode(Lson), L, mid, val);
	else insert(newNode(Rson), mid + 1, R, val);
	update(root);
}
</code></pre>
<p>dfs时自底向上合并查询：</p>
<pre><code class="language-cpp">inline void dfs(int cur) {
	for (auto to : G[cur]) {
		dfs(to);
		merge(root[cur], root[to], 1, cnt);
	}
	ans[cur] = query(root[cur], 1, cnt, Map[val[cur]] + 1, cnt);
}
</code></pre>
<p>Code:</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
constexpr int MAXN = 1e5 + 1;
constexpr int LOG = 17;
using namespace std;
template &lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1; x = 0; 
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
struct Node {
	Node *lson, *rson;
	int cnt;
}Tree[MAXN * LOG * 4], *root[MAXN];
#define Lson root-&gt;lson
#define Rson root-&gt;rson
vector&lt;int&gt; G[MAXN];
int tot, n, ans[MAXN], val[MAXN], cnt, cpy[MAXN];
unordered_map&lt;int, int&gt; Map;
inline void discretization() {
	sort(cpy + 1, cpy + n + 1);
	cnt = unique(cpy + 1, cpy + n + 1) - cpy - 1;
	for (int i = 1; i &lt;= cnt; i++) Map[cpy[i]] = i;
}
inline Node * newNode(Node * &amp;root) { 
	if (root == NULL) root = &amp;Tree[++tot];
	return root;
}
inline void update(Node *root) {
    int Lcnt = Lson == NULL ? 0 : Lson-&gt;cnt, Rcnt = Rson == NULL ? 0 : Rson-&gt;cnt;
	root-&gt;cnt = Lcnt + Rcnt;
}
inline void insert(Node *root, int L, int R, int val) {
	if (L == R) {
		root-&gt;cnt++;
		return;
	}
	int mid = (L + R) &gt;&gt; 1;
	if (val &lt;= mid) insert(newNode(Lson), L, mid, val);
	else insert(newNode(Rson), mid + 1, R, val);
	update(root);
}
inline void merge(Node *&amp;root, Node *p, int L, int R) {
	if (root == NULL) {root = p; return;}
	if (p == NULL) return;
	if (L == R) {
		root-&gt;cnt += p-&gt;cnt;
        return;
	}
	int mid = (L + R) &gt;&gt; 1;
	merge(Lson, p-&gt;lson, L, mid);
	merge(Rson, p-&gt;rson, mid + 1, R);
	update(root);
}
inline int query(Node *root, int L, int R, int qL, int qR) {
	if (root == NULL) return 0;
	if (qL &lt;= L &amp;&amp; R &lt;= qR) 
		return root-&gt;cnt;
	int mid = (L + R) &gt;&gt; 1, res = 0;
	if (qL &lt;= mid) res += query(Lson, L, mid, qL, qR);
	if (qR &gt; mid) res += query(Rson, mid + 1 ,R, qL, qR);
	return res;
}
inline void dfs(int cur) {
	for (auto to : G[cur]) {
		dfs(to);
		merge(root[cur], root[to], 1, cnt);
	}
	ans[cur] = query(root[cur], 1, cnt, Map[val[cur]] + 1, cnt);
}
int main(){
	read(n);
	for (int i = 1; i &lt;= n; i++) read(val[i]), cpy[i] = val[i];
	discretization();
	for (int i = 1; i &lt;= n; i++) 
		newNode(root[i]), insert(root[i], 1, cnt, Map[val[i]]);
	for (int i = 2, fa; i &lt;= n; i++) 
		cin &gt;&gt; fa, G[fa].emplace_back(i);
	dfs(1);
	for (int i = 1; i &lt;= n; i++) printf(&quot;%d\n&quot;, ans[i]);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P2168 [NOI2015]荷马史诗]]></title>
        <id>https://shaun118294191.github.io/post/p2168-noi2015he-ma-shi-shi/</id>
        <link href="https://shaun118294191.github.io/post/p2168-noi2015he-ma-shi-shi/">
        </link>
        <updated>2020-03-01T05:13:56.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2168">题目链接</a><br>
哈夫曼树也叫最优二叉树，是一种带权路径（叶子节点权值乘该节点到根节点路径长度）之和最短的二叉树。通过哈夫曼树可以构造出哈夫曼编码，可以用于数据压缩和数据加密。</p>
<p>哈夫曼编码的原理是，利用哈夫曼树中权值越高（数据出现频率越高）的节点到根节点的距离越小（对应哈夫曼编码越短）的性质，将数据压缩成哈夫曼编码。正是由于每一个数据对应于树上的每一个叶子节点，而对应的编码为根到该叶子节点的路径，所以一串哈夫曼编码才能对应惟一的一串原码（即题目中所说si不是sj的前缀。），解码时才不会产生混淆。</p>
<p>平时我们所说的哈夫曼编码为2进制的，构造的方法也很容易（类似于NOIP2004 合并果子），本题也可以使用相同的思想。</p>
<p>对于k叉哈夫曼树，仍可以每次从堆中取出最小的k个值。但如果最后一轮循环时堆的大小在2~k - 1之间，则整个哈夫曼树的根的子节点树就小于k，任取叶子节点到根的子节点，答案就会变小。所以需要添加空节点。</p>
<pre><code class="language-cpp">for (LL i = 1, tmp; i &lt;= n; i++)
    read(tmp), q.push(node(tmp, 0));
while ((n - 1) % (k - 1)) n++, q.push(node(0, 0));
</code></pre>
<p>本题可用结构体记录单词出现次数，hight of node，优先选择出现次数少的作为叶子节点，其次是节点高度小的优先。最后根节点的高度即为最长的si的最小长度。</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
//huffman tree
constexpr int MAXN = 1e5 + 5;
constexpr int LOG = 18;
using namespace std;
using LL = long long;
template &lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1; x = 0; 
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
struct node {
	LL w, h; //height of node
	node(){}
	node(LL _w, LL _h) : w(_w), h (_h){}
	inline bool friend operator &lt; (const node &amp;a, const node &amp;b) {
		return a.w == b.w ? a.h &gt; b.h : a.w &gt; b.w;
	}
};
priority_queue&lt;node, vector&lt;node&gt;&gt;q; 
LL n, k;
int main(){
	read(n), read(k);
	for (LL i = 1, tmp; i &lt;= n; i++)
		read(tmp), q.push(node(tmp, 0));
	while ((n - 1) % (k - 1)) n++, q.push(node(0, 0));
	LL sum = 0;
	while (q.size() &gt; 1) {
		LL num = 0, h = 0;
		for (int i = 1; i &lt;= k; i++) {
			num += q.top().w;
			h = max(h, q.top().h);
			q.pop();
		}
		sum += num, q.push(node(num, h + 1));
	}
	cout &lt;&lt; sum &lt;&lt; endl &lt;&lt; q.top().h &lt;&lt; endl; 
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P3128 [USACO15DEC]Max Flow P]]></title>
        <id>https://shaun118294191.github.io/post/p3128-usaco15decmax-flow-p/</id>
        <link href="https://shaun118294191.github.io/post/p3128-usaco15decmax-flow-p/">
        </link>
        <updated>2020-03-01T05:00:22.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3128">题目链接</a></p>
<p>Fj有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>条运输奶牛的路线，第i条路线从隔间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">t_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 一条运输路线会给它的两个端点处的隔间以及中间途径的所有隔间带来一个单位的运输压力，你需要计算压力最大的隔间的压力是多少。</p>
<p>树上差分点修改模板题，将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>e</mi><mi>l</mi><mi>t</mi><mi>a</mi><mo>[</mo><msub><mi>s</mi><mi>i</mi></msub><mo>]</mo></mrow><annotation encoding="application/x-tex">delta[s_i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>e</mi><mi>l</mi><mi>t</mi><mi>a</mi><mo>[</mo><msub><mi>t</mi><mi>i</mi></msub><mo>]</mo></mrow><annotation encoding="application/x-tex">delta[t_i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 加1; 将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>e</mi><mi>l</mi><mi>t</mi><mi>a</mi><mo>[</mo><mi>l</mi><mi>c</mi><mi>a</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">delta[lca]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mclose">]</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>e</mi><mi>l</mi><mi>t</mi><mi>a</mi><mo>[</mo><msub><mi>f</mi><mrow><mi>l</mi><mi>c</mi><mi>a</mi></mrow></msub><mo>]</mo></mrow><annotation encoding="application/x-tex">delta[f_{lca}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 减1。</p>
<p>最后dfs求子树delta和即可。</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define pii pair&lt;int, int&gt; 
constexpr int MAXN = 5e4 + 4;
constexpr int LOG = 17;
using namespace std;
template &lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1; x = 0; 
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
int n, m, f[MAXN][LOG], depth[MAXN], delta[MAXN], ans;
vector&lt;int&gt; G[MAXN];
inline void dfs(int cur, int fa) {
	depth[cur] = depth[fa] + 1, f[cur][0] = fa;
	for (int i = 1; i &lt; LOG; i++) f[cur][i] = f[f[cur][i - 1]][i - 1];
	for (auto to : G[cur]) {
		if (fa == to) continue;
		dfs(to, cur);
	}
}
inline int LCA(int u, int v) {
	if (depth[u] &lt; depth[v]) swap(u, v);
	for (int i = LOG - 1; i &gt;= 0; i--) 
		if (depth[f[u][i]] &gt;= depth[v])
			u = f[u][i];
	if (u == v) return u;
	for (int i = LOG - 1; i &gt;= 0; i--) 
		if (f[u][i] != f[v][i])
			u = f[u][i], v = f[v][i];
	return f[u][0];
}
inline int dfs2(int cur, int fa) {
	int cnt = 0;
	for (auto to : G[cur]) {
		if (to == fa) continue;
		cnt += dfs2(to, cur);
	}
	ans = max(ans, cnt + delta[cur]);
	return cnt + delta[cur];
}
int main(){
	std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	cin &gt;&gt; n &gt;&gt; m;
	for (int i = 1, u, v; i &lt; n; i++) 
		cin &gt;&gt; u &gt;&gt; v, G[u].emplace_back(v), G[v].emplace_back(u);
	dfs(1, 0);
	for (int i = 1, u, v, lca; i &lt;= m; i++) {
		cin &gt;&gt; u &gt;&gt; v, lca = LCA(u, v);
		delta[u]++, delta[v]++, delta[lca]--, delta[f[lca][0]]--;
	}
	ans = max(ans, dfs2(1, 0));
	cout &lt;&lt; ans &lt;&lt; endl;
	return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于]]></title>
        <id>https://shaun118294191.github.io/post/guan-yu/</id>
        <link href="https://shaun118294191.github.io/post/guan-yu/">
        </link>
        <updated>2020-03-01T03:33:30.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>欢迎来到我的小站呀，很高兴遇见你！🤝</p>
</blockquote>
<h2 id="关于本站">🏠 关于本站</h2>
<h2 id="博主是谁">👨‍💻 博主是谁</h2>
<h2 id="兴趣爱好">⛹ 兴趣爱好</h2>
<h2 id="联系我呀">📬 联系我呀</h2>
]]></content>
    </entry>
</feed>