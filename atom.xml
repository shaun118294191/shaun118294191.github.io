<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://shaun118294191.github.io</id>
    <title>Shaun</title>
    <updated>2020-03-17T06:51:26.097Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://shaun118294191.github.io"/>
    <link rel="self" href="https://shaun118294191.github.io/atom.xml"/>
    <subtitle>Valar morghulis Valar Dohaeris</subtitle>
    <logo>https://shaun118294191.github.io/images/avatar.png</logo>
    <icon>https://shaun118294191.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Shaun</rights>
    <entry>
        <title type="html"><![CDATA[CF1070C Cloud Computing]]></title>
        <id>https://shaun118294191.github.io/post/cf1070c-cloud-computing/</id>
        <link href="https://shaun118294191.github.io/post/cf1070c-cloud-computing/">
        </link>
        <updated>2020-03-17T06:35:08.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1070C">题目链接</a></p>
<p>Buber公司决定连续 n 天云端租用 CPU ，每天需要 k 个 CPU</p>
<p>云端供应商提供 m 个租用计划，第 i 个计划有如下的特征：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>l</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>r</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">l_i, r_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示第 i 个计划从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>l</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">l_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 天开始到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>r</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">r_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 天结束。</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示第 i 个计划中每天最多租用CPU个数</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">p_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示第i 个计划租用一个CPU的花费。</li>
</ul>
<p>Buber 可以同时使用多个计划，即他可以在第 x 天在每个进行中的计划中租用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>0</mn><mo separator="true">,</mo><msub><mi>c</mi><mi>i</mi></msub><mo>]</mo></mrow><annotation encoding="application/x-tex">[0,c_i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 个 CPU。<br>
求最少花费。</p>
<p>每一天每个计划中CPU个数可以任意选，因此应优先选费用低的计划，经行区间修改。</p>
<pre><code class="language-cpp">struct node {
    int l, r, c, p;
    inline bool operator &lt; (const node &amp;other) const {
        return p &lt; other.p;
    }
}tariff[MAXN];
</code></pre>
<p>用 max 记录节点维护的区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi><mo>−</mo><mo>&gt;</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi><mo>−</mo><mo>&gt;</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[root-&gt;l, root-&gt;r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>中已购买CPU数的最大值，min 记录最小值:</p>
<ul>
<li>若 min &gt;= k，则直接 return。</li>
<li>否则若 max + c &lt;= k, 则区间增值c。</li>
<li>否则若 max == min, 则区间增值min(c, k - max)。</li>
<li>否则递归左右儿子修改。</li>
</ul>
<pre><code class="language-cpp">inline void change(int qL, int qR, int L, int R, Node root) {
    if (qL &lt;= L &amp;&amp; R &lt;= qR) {
        if (root-&gt;min &gt;= k) return;
        if (root-&gt;max + curC &lt;= k) {
            root-&gt;max += curC, root-&gt;min += curC, root-&gt;tag += curC;
            res += curC * curP * (R - L + 1);
            return;
        } else if (root-&gt;max == root-&gt;min){
            LL delta = min(curC, k - root-&gt;max);
            root-&gt;max += delta, root-&gt;min += delta, root-&gt;tag += delta;
            res += delta * curP * (R - L + 1);
            return;
        }
        if (L == R) return;
    }
    pushTag(L, R, root);
    int mid = (L + R) &gt;&gt; 1;
    if (qL &lt;= mid) change(qL, qR, L, mid, Lson);
    if (qR &gt; mid) change(qL, qR, mid + 1, R, Rson);
    update(root);
}
</code></pre>
<p>Code:</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
//cloud computing
constexpr int MAXN = 1e6 + 6;
using namespace std;
template &lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1; x = 0;
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
struct node {
    int l, r, c, p;
    inline bool operator &lt; (const node &amp;other) const {
        return p &lt; other.p;
    }
}tariff[MAXN];
using LL = long long;
struct segTree {
    segTree * lson, *rson;
    LL max, min, tag;
}Tree[MAXN &lt;&lt; 1];
using Node = segTree *;
#define Lson root-&gt;lson
#define Rson root-&gt;rson
int n, m, tot;
LL k, res, curC, curP;
inline void update(Node root) {
    root-&gt;max = max(Lson-&gt;max, Rson-&gt;max);
    root-&gt;min = min(Lson-&gt;min, Rson-&gt;min);
}
inline void build(int L, int R, Node root) {
    if (L == R) return;
    int mid = (L + R) &gt;&gt; 1;
    Lson = &amp;Tree[++tot], Rson = &amp;Tree[++tot];
    build(L, mid, Lson), build(mid + 1 ,R, Rson);
}
inline void pushTag(int L, int R, Node root) {
    if (!root-&gt;tag) return;
    Lson-&gt;tag += root-&gt;tag, Rson-&gt;tag += root-&gt;tag;
    Lson-&gt;max += root-&gt;tag, Rson-&gt;max += root-&gt;tag;
    Lson-&gt;min += root-&gt;tag, Rson-&gt;min += root-&gt;tag;
    root-&gt;tag = 0;
}
inline void change(int qL, int qR, int L, int R, Node root) {
    if (qL &lt;= L &amp;&amp; R &lt;= qR) {
        if (root-&gt;min &gt;= k) return;
        if (root-&gt;max + curC &lt;= k) {
            root-&gt;max += curC, root-&gt;min += curC, root-&gt;tag += curC;
            res += curC * curP * (R - L + 1);
            return;
        } else if (root-&gt;max == root-&gt;min){
            LL delta = min(curC, k - root-&gt;max);
            root-&gt;max += delta, root-&gt;min += delta, root-&gt;tag += delta;
            res += delta * curP * (R - L + 1);
            return;
        }
        if (L == R) return;
    }
    pushTag(L, R, root);
    int mid = (L + R) &gt;&gt; 1;
    if (qL &lt;= mid) change(qL, qR, L, mid, Lson);
    if (qR &gt; mid) change(qL, qR, mid + 1, R, Rson);
    update(root);
}
int main() {
    read(n), read(k), read(m);
    for (int i = 1; i &lt;= m; i++) {
        read(tariff[i].l), read(tariff[i].r);
        read(tariff[i].c), read(tariff[i].p);
    }
    sort(tariff + 1, tariff + m + 1);
    build(1, n, Tree);
    for (int i = 1; i &lt;= m; i++) {
        curC = tariff[i].c, curP = tariff[i].p;
        int l = tariff[i].l, r = tariff[i].r;
        change(l, r, 1, n, Tree);
    }
    cout &lt;&lt; res &lt;&lt; endl;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P4556 [Vani有约会]雨天的尾巴]]></title>
        <id>https://shaun118294191.github.io/post/p4556-vani-you-yue-hui-yu-tian-de-wei-ba/</id>
        <link href="https://shaun118294191.github.io/post/p4556-vani-you-yue-hui-yu-tian-de-wei-ba/">
        </link>
        <updated>2020-03-17T03:21:26.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4556">题目链接</a><br>
树上差分两种形式：</p>
<ul>
<li>
<p>将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(u, v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>间的边覆盖， 将u点的权值加1，v点的权值加1，节点LCA(u, v)的权值减2。对树进行深度优先遍历，求出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">f_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>为根的子树中各节点的权值和。则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">f_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>与其父亲节点间的树边的覆盖次数。</p>
</li>
<li>
<p>将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(u, v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>路径上的点覆盖，将u点的权值加1，v点的权值加1，LCA(u, v)的权值减1，fa[LCA(u, v)]的点权值减1。对树进行深度优先遍历，求出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">f_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>为根的子树中各节点的权值和。</p>
</li>
</ul>
<p>对于本题，节点修改可用树上差分实现。对于出现次数最多的z以及z的数值，可对每个点建立动态开点的权值线段树并在最后深度优先遍历时合并。</p>
<p>时间空间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mo>(</mo><mi>N</mi><mo>+</mo><mi>M</mi><mo>)</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo>(</mo><mi>N</mi><mo>+</mo><mi>M</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">O((N + M)log_2(N + M))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>。</p>
<p>为防止左右儿子为空，可将其指针默认为Tree[0]的地址。最后还是得开<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>∗</mo><mi>L</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo>∗</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">N * LogN * 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>的空间……</p>
<p>动态插入：</p>
<pre><code class="language-cpp">inline Node * newNode(Node * &amp;root) { 
	if (root == NULL || root == Tree) root = &amp;Tree[++tot], Lson = Rson = Tree;
	return root;
}
inline void insert(Node *root, int L, int R, int val, int delta) {
	if (L == R) {
		root-&gt;cnt += delta;
		root-&gt;pos = root-&gt;cnt ? L : 0;
		return;
	}
	int mid = (L + R) &gt;&gt; 1;
	if (val &lt;= mid) insert(newNode(Lson), L, mid, val, delta);
	else insert(newNode(Rson), mid + 1, R, val, delta);
	update(root);
}
</code></pre>
<p>合并：</p>
<pre><code class="language-cpp">inline Node * merge(Node *root, Node *pre, int L, int R) {
	if (root == NULL || root == Tree) return pre;
	if (pre == NULL || pre == Tree) return root;
	if (L == R) {
		root-&gt;cnt += pre-&gt;cnt;
		root-&gt;pos = root-&gt;cnt ? L : 0;
		return root;
	}
	int mid = (L + R) &gt;&gt; 1;
	Lson = merge(Lson, pre-&gt;lson, L, mid);
	Rson = merge(Rson, pre-&gt;rson, mid + 1, R);
	update(root);
	return root;
}
</code></pre>
<p>Code:</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
constexpr int MAXN = 1e5 + 5;
constexpr int LOG = 18;
using namespace std;
template &lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1; x = 0; 
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
struct Node {
	Node *lson, *rson;
	int cnt, pos;
}Tree[MAXN * LOG * 4], *root[MAXN];
#define Lson root-&gt;lson
#define Rson root-&gt;rson
vector&lt;vector&lt;int&gt; &gt; G;
int tot, n, m, f[MAXN][LOG], depth[MAXN], ans[MAXN];
inline Node * newNode(Node * &amp;root) { 
	if (root == NULL || root == Tree) root = &amp;Tree[++tot], Lson = Rson = Tree;
	return root;
}
inline void update(Node *root) {
	root-&gt;cnt = max(Lson-&gt;cnt, Rson-&gt;cnt);
	root-&gt;pos = (Lson-&gt;cnt &gt;= Rson-&gt;cnt) ? Lson-&gt;pos : Rson-&gt;pos;
}
inline void insert(Node *root, int L, int R, int val, int delta) {
	if (L == R) {
		root-&gt;cnt += delta;
		root-&gt;pos = root-&gt;cnt ? L : 0;
		return;
	}
	int mid = (L + R) &gt;&gt; 1;
	if (val &lt;= mid) insert(newNode(Lson), L, mid, val, delta);
	else insert(newNode(Rson), mid + 1, R, val, delta);
	update(root);
}
inline Node * merge(Node *root, Node *pre, int L, int R) {
	if (root == NULL || root == Tree) return pre;
	if (pre == NULL || pre == Tree) return root;
	if (L == R) {
		root-&gt;cnt += pre-&gt;cnt;
		root-&gt;pos = root-&gt;cnt ? L : 0;
		return root;
	}
	int mid = (L + R) &gt;&gt; 1;
	Lson = merge(Lson, pre-&gt;lson, L, mid);
	Rson = merge(Rson, pre-&gt;rson, mid + 1, R);
	update(root);
	return root;
}
inline void dfs(int cur, int fa) {
	depth[cur] = depth[fa] + 1, f[cur][0] = fa;
	for (int i = 1; i &lt; LOG; i++) f[cur][i] = f[f[cur][i - 1]][i - 1];
	for (auto to : G[cur]) {
		if (to == fa) continue;
		dfs(to, cur);
	}
}
inline void dfs2(int cur, int fa) {
	for (auto to : G[cur]) {
		if (to == fa) continue;
		dfs2(to, cur);
		root[cur] = merge(root[cur], root[to], 1, MAXN - 5);
	}
	ans[cur] = root[cur]-&gt;pos;
}
inline int LCA(int u, int v) {
	if (depth[u] &lt; depth[v]) swap(u, v);
	for (int i = LOG - 1; i &gt;= 0; i--)
		if (depth[f[u][i]] &gt;= depth[v]) u = f[u][i];
	if (u == v) return u;
	for (int i = LOG - 1; i &gt;= 0; i--)
		if (f[u][i] != f[v][i]) u = f[u][i], v = f[v][i];
	return f[u][0];
}
int main(){
	read(n), read(m), G.resize(n + 1);
	for (int i = 1, u, v; i &lt; n; i++) {
		read(u), read(v);
		G[u].push_back(v), G[v].push_back(u); 
	}
	for (int i = 0; i &lt;= n; i++) newNode(root[i]);
	dfs(1, 0); //建立有根树，LCA预处理
	for (int i = 1, u, v, z, lca; i &lt;= m; i++) {
		read(u), read(v), read(z), lca = LCA(u, v); //差分操作
		insert(root[u], 1, MAXN - 5, z, 1);
		insert(root[v], 1, MAXN - 5, z, 1);
		insert(root[lca], 1, MAXN - 5, z, -1);
		insert(root[f[lca][0]], 1, MAXN - 5, z, -1);
	}
	dfs2(1, 0); //遍历并合并线段树
	for (int i = 1; i &lt;= n; i++) printf(&quot;%d\n&quot;, ans[i]);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P2634 [国家集训队]聪聪可可]]></title>
        <id>https://shaun118294191.github.io/post/p2634-guo-jia-ji-xun-dui-cong-cong-ke-ke/</id>
        <link href="https://shaun118294191.github.io/post/p2634-guo-jia-ji-xun-dui-cong-cong-ke-ke/">
        </link>
        <updated>2020-03-15T13:34:45.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2634">题目链接</a></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
constexpr int MAXN = 2e4 + 4;
//长度 mod 3 = 0的点对数
using namespace std;
template &lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1; x = 0;
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
using A = int [MAXN];
A dp, sz, cntDis, vis, dis, vec, vecBig;
vector&lt; pair&lt;int, int&gt; &gt; G[MAXN];
int n, root, tot, res, cnt;
inline void getRoot(int cur, int fa) {
    sz[cur] = 1, dp[cur] = 0;
    for (auto &amp;e : G[cur]) {
        int to = e.first;
        if (vis[to] || fa == to) continue;
        getRoot(to, cur);
        sz[cur] += sz[to];
        dp[cur] = max(dp[cur], sz[to]);
    }
    dp[cur] = max(dp[cur], tot - sz[cur]);
    if (dp[cur] &lt; dp[root]) root = cur;
}
inline void getDis(int cur, int fa) {
    vec[cnt++] = dis[cur];
    for (auto &amp;e : G[cur]) {
        int to = e.first, w = e.second;
        if (vis[to] || fa == to) continue;
        dis[to] = (dis[cur] + w) % 3;
        getDis(to, cur);
    }
}
inline void calc(int cur) { //长度 mod 3 = 0的路径数
    int Cnt(0);
    for (auto &amp;e : G[cur]) {
        int to = e.first, w = e.second;
        if (vis[to]) continue;
        cnt = 0, dis[to] = w % 3, getDis(to, cur);
        for (int i = 0; i &lt; cnt; ++i) {
            res += cntDis[(3 - vec[i]) % 3];
            if (vec[i] % 3 == 0) ++res; //根为端点
        }
        for (int i = 0; i &lt; cnt; ++i)
            vecBig[Cnt++] = vec[i], ++cntDis[vec[i]];
    }
    for (int i = 0; i &lt; Cnt; ++i) cntDis[vecBig[i]] = 0;
}
inline void dfs(int cur) {
    vis[cur] = true, calc(cur);
    for (auto &amp;e : G[cur]) {
        int to = e.first;
        if (vis[to]) continue;
        root = cur, tot = dp[root] = sz[to];
        getRoot(to, root), dfs(root);
    }
}
int main() {
    freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
    read(n);
    for (int i = 1, u, v, w; i &lt; n; ++i) {
        read(u), read(v), read(w);
        G[u].emplace_back(make_pair(v, w));
        G[v].emplace_back(make_pair(u, w));
    }
    root = 0, tot = dp[root] = n;
    getRoot(1, root), dfs(root);
    res = res * 2 + n;
    int tmp = __gcd(res, n * n);
    cout &lt;&lt; res / tmp &lt;&lt; &quot;/&quot; &lt;&lt; n * n / tmp&lt;&lt; endl;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Rebuild Teldrassil]]></title>
        <id>https://shaun118294191.github.io/post/rebuild-teldrassil/</id>
        <link href="https://shaun118294191.github.io/post/rebuild-teldrassil/">
        </link>
        <updated>2020-03-15T05:57:49.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/T123576">题目链接(内部题目)</a></p>
<p>题意：有一棵树，每个点有权值，一条路径的中位数大于等于 x 时，认为这条路径是重要的，现在你可以改变一个节点的权值，求改变后最多可以新增加多少重要路径。</p>
<p>将所有小于x的点认为权值是 -1，大于等于x的点权值认为是 1，一条路径的和如果大于等于 0，则这条路径是重要的，修改一个点可以将这个点从 -1 改为 1 ，对于每一个 -1 的点，统计有多少条过该点的权值为 -1 or -2 的路径。</p>
<p>求出长度为 -1 或 -2 的路径数比较容易，但是本题要求经过某一点长度为 -1 或 -2 的路径数，不能简单地在子树中统计。</p>
<p>对于一条经过根的长度为k的路径， 若这条路径在某个子树中的终点为node , 则从node到根的节点都经过这条路径。</p>
<p>于是把以 node 为终点长度为 k 的路径数存在到add[node]数组，并累加到add[father[node]]中。过程如下：</p>
<p>先遍历所有子树求出cntDis[], 记录father (根节点答案需单独处理)。<br>
dfs:</p>
<pre><code class="language-cpp">inline void getDis(int cur, int fa) {
    add[cur] = 0;
    vec[cnt++] = make_pair(dis[cur], cur);
    for (auto &amp;to : G[cur]) {
        if (to == fa || vis[to]) continue;
        dis[to] = dis[cur] + w[to];
        father[to] = cur;
        getDis(to, cur);
    }
}
</code></pre>
<p>calc:</p>
<pre><code class="language-cpp">    for (auto &amp;to : G[cur]) {
        if (vis[to]) continue;
        cnt = 0, dis[to] = w[to], getDis(to, cur);
        for (int i = 0; i &lt; cnt; i++) {
            int d = vec[i].first;
            res[cur] += cntDis[-1 - w[cur] - d + ADD] + cntDis[-2 - w[cur] - d + ADD];
            if (d + w[cur] == -1 || d + w[cur] == -2) res[cur]++; //只经过根节点，不经过另一颗子树
        }
        for (int i = 0; i &lt; cnt; i++)
            vecBig[Cnt++] = vec[i], cntDis[vec[i].first + ADD]++; //保存已访问子树的结果
    }
</code></pre>
<p>再次遍历子树，减去cntDis, 求出add[], 再将cntDis加回。若node到根节点点权和(不过括w[root])为d，则add[node] += cntDis[-1 - d - w[root]] + cntDis[-2 - d - w[root]] + 到根节点距离为-1 or-2的路径数。<br>
calc:</p>
<pre><code class="language-cpp">    for (int i = 0; i &lt; cnt; i++) cntDis[vec[i].first + ADD]--;
    for (int i = cnt - 1; i &gt;= 0; i--) {
            int d = vec[i].first, node = vec[i].second;
            add[node] += cntDis[-1 - w[cur] - d + ADD] + cntDis[-2 - w[cur] - d + ADD];
            if (d + w[cur] == -1 || d + w[cur] == -2) add[node]++; //只经过根节点，不经过另一颗子树
            add[father[node]] += add[node];
            res[node] += add[node];
    }
    for (int i = 0; i &lt; cnt; i++) cntDis[vec[i].first + ADD]++;
</code></pre>
<p>Code(NlogN):</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
constexpr int MAXN = 4e5 + 4;
constexpr int ADD = 3e5 + 3;
using namespace std;
template &lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1; x = 0;
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
vector&lt;int&gt; G[MAXN];
int w[MAXN], dp[MAXN], sz[MAXN], father[MAXN];
long long res[MAXN], add[MAXN];
int vis[MAXN], dis[MAXN];
pair &lt;int, int&gt; vec[MAXN], vecBig[MAXN];
int n, x, tot, cnt, root;
int cntDis[MAXN &lt;&lt; 1], cntDis[MAXN &lt;&lt; 1];
inline void getRoot(int cur, int fa) {
    sz[cur] = 1, dp[cur] = 0;
    for (auto &amp;to : G[cur]) {
        if (to == fa || vis[to]) continue;
        getRoot(to, cur);
        sz[cur] += sz[to];
        dp[cur] = max(dp[cur], sz[to]);
    }
    dp[cur] = max(dp[cur], tot - sz[cur]);
    if (dp[cur] &lt; dp[root]) root = cur;
}
inline void getDis(int cur, int fa) {
    add[cur] = 0;
    vec[cnt++] = make_pair(dis[cur], cur);//, cntDis[dis[cur] + ADD]++;
    for (auto &amp;to : G[cur]) {
        if (to == fa || vis[to]) continue;
        dis[to] = dis[cur] + w[to];
        father[to] = cur;
        getDis(to, cur);
    }
}
inline void calc(int cur) {
    int Cnt(0);
    for (auto &amp;to : G[cur]) {
        if (vis[to]) continue;
        cnt = 0, dis[to] = w[to], getDis(to, cur);
        for (int i = 0; i &lt; cnt; i++) {
            int d = vec[i].first;
            res[cur] += cntDis[-1 - w[cur] - d + ADD] + cntDis[-2 - w[cur] - d + ADD];
            if (d + w[cur] == -1 || d + w[cur] == -2) res[cur]++;
        }
        for (int i = 0; i &lt; cnt; i++)
            vecBig[Cnt++] = vec[i], cntDis[vec[i].first + ADD]++; //保存已访问子树的结果
    }
    for (auto &amp;to : G[cur]) {
        if (vis[to]) continue;
        cnt = 0, dis[to] = w[to], getDis(to, cur);
        for (int i = 0; i &lt; cnt; i++) cntDis[vec[i].first + ADD]--;
        for (int i = cnt - 1; i &gt;= 0; i--) {
            int d = vec[i].first, node = vec[i].second;
            add[node] += cntDis[-1 - w[cur] - d + ADD] + cntDis[-2 - w[cur] - d + ADD];
            if (d + w[cur] == -1 || d + w[cur] == -2) add[node]++;
            add[father[node]] += add[node];
            res[node] += add[node];
        }
        for (int i = 0; i &lt; cnt; i++) cntDis[vec[i].first + ADD]++;
    }
    for (int i = 0; i &lt; Cnt; i++) cntDis[vecBig[i].first + ADD] = 0;
}
inline void dfs(int cur) {
    vis[cur] = true, calc(cur);
    for (auto &amp;to : G[cur]) {
        if (vis[to]) continue;
        root = cur, tot = dp[root] = sz[to];
        getRoot(to, root), dfs(root);
    }
}
int main() {
    read(n), read(x);
    for (int i = 1, u, v; i &lt; n; i++) {
        read(u), read(v);
        G[u].emplace_back(v), G[v].emplace_back(u);
    }
    for (int i = 1, tmp; i &lt;= n; i++)
        read(tmp), w[i] = tmp &gt;= x ? 1 : -1;
    root = 0, tot = dp[root] = n;
    getRoot(1, root), dfs(root);
    long long mx = 0;
    for (int i = 1; i &lt;= n; i++) 
        if (w[i] == -1) mx = max(mx, res[i]);
    cout &lt;&lt; mx &lt;&lt; endl;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF161D Distance in Tree]]></title>
        <id>https://shaun118294191.github.io/post/cf161d-distance-in-tree/</id>
        <link href="https://shaun118294191.github.io/post/cf161d-distance-in-tree/">
        </link>
        <updated>2020-03-13T03:26:15.000Z</updated>
        <content type="html"><![CDATA[<p>求数上长度恰好为 k 的路径数。</p>
<p>点分治即可(k较大或为负数时也可做)：对于当前 root 依次遍历子树，记录子树节点到根的路径长度以及相应的cntDis。访问下一棵子树时用已访问的cntDis更新答案即可。</p>
<pre><code class="language-cpp">inline void calc(int cur) {
    int Cnt(0);
    for (auto &amp;to : G[cur]) {
        if (vis[to]) continue;
        cnt = 0, dis[to] = 1, getDis(to, cur);
        for (int i = 0; i &lt; cnt; i++) {
            res += cntDis[k - vec[i]];
            if (vec[i] == k) res++; //子节点到根的路径
        }
        for (int i = 0; i &lt; cnt; i++)
            vecBig[Cnt++] = vec[i], cntDis[vec[i]]++;
    }
    for (int i = 0; i &lt; Cnt; i++) cntDis[vecBig[i]] = 0;
}
</code></pre>
<p>Code:</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
constexpr int MAXN = 5e4 + 4;
//CF161D Distance in Tree
using namespace std;
template &lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1; x = 0;
    char ch = getchar();
    while (!isdigit(ch)) ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
vector&lt;int&gt; G[MAXN];
int n, k, root, cnt, tot;
long long res;
using A = int [MAXN];
A dp, cntDis, vec, vecBig, sz, dis, vis;
inline void getRoot(int cur, int fa) {
    sz[cur] = 1, dp[cur] = 0;
    for (auto &amp;to : G[cur]) {
        if (vis[to] || fa == to) continue;
        getRoot(to, cur);
        sz[cur] += sz[to];
        dp[cur] = max(dp[cur], sz[to]);
    }
    dp[cur] = max(dp[cur], tot - sz[cur]);
    if (dp[cur] &lt; dp[root]) root = cur;
}
inline void getDis(int cur, int fa) {
    vec[cnt++] = dis[cur];
    for (auto &amp;to :G[cur]) {
        if (vis[to] || to == fa) continue;
        dis[to] = dis[cur] + 1;
        getDis(to, cur);
    }
}
inline void calc(int cur) {
    int Cnt(0);
    for (auto &amp;to : G[cur]) {
        if (vis[to]) continue;
        cnt = 0, dis[to] = 1, getDis(to, cur);
        for (int i = 0; i &lt; cnt; i++) {
            res += cntDis[k - vec[i]];
            if (vec[i] == k) res++; // //子节点到根的路径
        }
        for (int i = 0; i &lt; cnt; i++)
            vecBig[Cnt++] = vec[i], cntDis[vec[i]]++;
    }
    for (int i = 0; i &lt; Cnt; i++) cntDis[vecBig[i]] = 0;
}
inline void dfs(int cur) {
    vis[cur] = true, calc(cur);
    for (auto &amp;to : G[cur]) {
        if (vis[to]) continue;
        root = cur, tot = dp[root] = sz[to];
        getRoot(to, root), dfs(root);
    }
}
int main() {
    read(n), read(k);
    for (int i = 1, u, v; i &lt; n; i++) {
        read(u), read(v);
        G[u].emplace_back(v), G[v].emplace_back(u);
    }
    root = 0, tot = dp[root] = n;
    getRoot(1, root), dfs(root);
    cout &lt;&lt; res &lt;&lt; endl;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P3806 【模板】点分治1]]></title>
        <id>https://shaun118294191.github.io/post/p3806-mo-ban-dian-fen-zhi-1/</id>
        <link href="https://shaun118294191.github.io/post/p3806-mo-ban-dian-fen-zhi-1/">
        </link>
        <updated>2020-03-12T03:59:14.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3806">题目链接</a><br>
给定一棵有 n 个点的树。</p>
<p>询问树上距离为 k 的点对是否存在。</p>
<p>method:<br>
求出以root为根的子树中的cntDis[dis] (dis <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span></span></span></span> 1e7)。</p>
<p>则cntDis[dis] * cnt[k - dis]即为距离为k的点对数<br>
(统计完清0即可，不要memset; 对每个询问都点分治一次要超时; 也可在子树中一一统计)。</p>
<pre><code class="language-cpp">inline void calc(int cur, int w, int type) { //cur为有根树的根节点(重心) type为1表示加
    cnt = 0, dis[cur] = w, getDis(cur, 0);
    for (int j = 1; j &lt;= m; j++)
        for (int i = 0; i &lt; cnt; i++)
            if (vec[i] &lt;= query[j]) res[j] += type * cntDis[vec[i]] * cntDis[query[j] - vec[i]];
    for (int i = 0; i &lt; cnt; i++) cntDis[vec[i]] = false;
}
</code></pre>
<p>不合法的点对数在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>o</mi><msub><mi>n</mi><mrow><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">son_{root}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 中减去即可。<br>
<code>calc(to, w, -1); //容斥 减去儿子中的路径数 注意要加上w</code></p>
<p>Code:</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
constexpr int MAXN = 1e4 + 4;
using namespace std;
template&lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1; x = 0;
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
vector&lt; pair&lt;int, int&gt; &gt; G[MAXN];
int n, m, tot, cnt, root;
int sz[MAXN], dp[MAXN], vis[MAXN];
int query[MAXN], res[MAXN];
int vec[MAXN], dis[MAXN], cntDis[MAXN &lt;&lt; 10];
inline void getRoot(int cur, int fa) { //求树的重心 自上而下
    sz[cur] = 1, dp[cur] = 0;
    for (auto &amp;e : G[cur]) {
        int to = e.first, w = e.second;
        if (to == fa || vis[to]) continue;
        getRoot(to, cur);
        sz[cur] += sz[to];
        dp[cur] = max(dp[cur], sz[to]);
    }
    dp[cur] = max(dp[cur], tot - sz[cur]);
    if (dp[cur] &lt; dp[root]) root = cur;
}
inline void getDis(int cur, int fa) { //求出到根root的距离
    if (dis[cur] &lt;= 1e7) 
        vec[cnt++] = dis[cur], cntDis[dis[cur]]++;
    for (auto &amp;e : G[cur]) {
        int to = e.first, w = e.second;
        if (to == fa || vis[to]) continue;
        dis[to] = dis[cur] + w;
        getDis(to, cur);
    }
}
inline void calc(int cur, int w, int type) { //cur为有根树的根节点(重心) type为1表示加
    cnt = 0, dis[cur] = w, getDis(cur, 0);
    for (int j = 1; j &lt;= m; j++)
        for (int i = 0; i &lt; cnt; i++)
            if (vec[i] &lt;= query[j]) res[j] += type * cntDis[vec[i]] * cntDis[query[j] - vec[i]];
    for (int i = 0; i &lt; cnt; i++) cntDis[vec[i]] = false;
}
inline void dfs(int cur) {
    vis[cur] = true, calc(cur, 0, 1);
    for (auto &amp;e : G[cur]) {
        int to = e.first, w = e.second;
        if (vis[to]) continue;
        calc(to, w, -1); //容斥 减去儿子中的路径数 注意要加上w
        root = cur, tot = dp[root] = sz[to]; //准备重新选择根节点
        getRoot(to, root), dfs(root);
    }
}
int main() {
    read(n), read(m);
    for (int i = 1, u, v, w; i &lt; n; i++) {
        read(u), read(v), read(w);
        G[u].emplace_back(make_pair(v, w)), G[v].emplace_back(make_pair(u, w));
    }
    for (int i = 1; i &lt;= m; i++) read(query[i]);
    root = 0, tot = dp[root] = n;
    getRoot(1, root), dfs(root);
    for (int i = 1; i &lt;= m; i++)
        res[i] &gt; 0 ? puts(&quot;AYE&quot;) : puts(&quot;NAY&quot;);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P4178 Tree]]></title>
        <id>https://shaun118294191.github.io/post/p4178-tree/</id>
        <link href="https://shaun118294191.github.io/post/p4178-tree/">
        </link>
        <updated>2020-03-11T13:12:36.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4178">题目链接</a><br>
求树上长度不超过 k 的路径数。</p>
<p>若节点 root 为根，则对 root 而言，树上路径可分为2类：<br>
1.经过根节点 root 。（分为 x~root, root~y ）<br>
2.包含于 root 的某一棵子树中。(不经过根节点)</p>
<p>对于当前节点 root , dfs 求出子树节点到其的距离dis[node]。</p>
<pre><code class="language-cpp">inline void getDis(int cur, int fa) { //求出到根root的距离
    vec.emplace_back(dis[cur]);
    for (auto &amp;e : G[cur]) {
        int to = e.first, w = e.second;
        if (to == fa || vis[to]) continue;
        dis[to] = dis[cur] + w;
        getDis(to, cur);
    }
}
</code></pre>
<p>将 dis[] 数组升序排序，使用两个指针 l, r 从前、后开始扫描数组。</p>
<p>容易发现，在 l 从左到右扫描的过程中，恰好使得 dis[l] + dis[r] <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span></span></span></span> k 的 r 是从右向左递减的，于是符合条件的点对有 r - l 对。</p>
<pre><code class="language-cpp">inline void calc(int cur, int w, int type) { //cur为有根树的根节点(重心) type为1表示加
    dis[cur] = w, vec.clear(), getDis(cur, 0);
    sort(vec.begin(), vec.end());
    int l = 0, r = (int)vec.size() - 1;
    while (l &lt;= r) {
        if (vec[l] + vec[r] &lt;= k) res += type * (r - l), ++l;
        else --r;
    }
}
</code></pre>
<p>不过一些点对在root的某一棵子树中，且会使 root 与其儿子间的边被经过两次。可以以 root 的儿子节点为根, dis[son] = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mrow><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi><mo separator="true">,</mo><mi>s</mi><mi>o</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">w_{root, son}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.28055599999999997em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">t</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>，再次求dis[]并统计, 减去这部分的结果即可( son 子树满足条件的在 root 中不满足)。<br>
<code>calc(to, w, -1); //容斥思想 减去儿子中的路径数 注意dis要加上w</code></p>
<p>于是可不断选取 root 并统计：<br>
1.若递归深度为 T 层，则总时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>T</mi><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(TNlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。<br>
2.若选取的root为子树重心，则root的子树大小不会超过原子树大小的一半，点分治最多<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">logN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>层。</p>
<pre><code class="language-cpp">inline void getRoot(int cur, int fa) { //求树的重心 自上而下
    sz[cur] = 1, dp[cur] = 0;
    for (auto &amp;e : G[cur]) {
        int to = e.first, w = e.second;
        if (to == fa || vis[to]) continue;
        getRoot(to, cur);
        sz[cur] += sz[to];
        dp[cur] = max(dp[cur], sz[to]);
    }
    dp[cur] = max(dp[cur], tot - sz[cur]);
    if (dp[cur] &lt; dp[root]) root = cur;
}
</code></pre>
<p>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(NlogNlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。</p>
<p>Code:</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
constexpr int MAXN = 4e4 + 4;
using namespace std;
template&lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1; x = 0;
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
vector&lt; pair&lt;int, int&gt; &gt; G[MAXN];
vector&lt;int&gt; vec;
int n, k, tot, root, res;
int sz[MAXN], dp[MAXN], dis[MAXN], vis[MAXN];
inline void getRoot(int cur, int fa) { //求树的重心 自上而下
    sz[cur] = 1, dp[cur] = 0;
    for (auto &amp;e : G[cur]) {
        int to = e.first, w = e.second;
        if (to == fa || vis[to]) continue;
        getRoot(to, cur);
        sz[cur] += sz[to];
        dp[cur] = max(dp[cur], sz[to]);
    }
    dp[cur] = max(dp[cur], tot - sz[cur]);
    if (dp[cur] &lt; dp[root]) root = cur;
}
inline void getDis(int cur, int fa) { //求出到根root的距离
    vec.emplace_back(dis[cur]);
    for (auto &amp;e : G[cur]) {
        int to = e.first, w = e.second;
        if (to == fa || vis[to]) continue;
        dis[to] = dis[cur] + w;
        getDis(to, cur);
    }
}
inline void calc(int cur, int w, int type) { //cur为有根树的根节点(重心) type为1表示加
    dis[cur] = w, vec.clear(), getDis(cur, 0);
    sort(vec.begin(), vec.end());
    int l = 0, r = (int)vec.size() - 1;
    while (l &lt;= r) {
        if (vec[l] + vec[r] &lt;= k) res += type * (r - l), ++l;
        else --r;
    }
}
inline void dfs(int cur) {
    vis[cur] = true, calc(root, 0, 1);
    for (auto &amp;e : G[cur]) {
        int to = e.first, w = e.second;
        if (vis[to]) continue;
        calc(to, w, -1); //容斥思想 减去儿子中的路径数 注意要加上w
        root = cur, tot = dp[root] = sz[to]; //准备重新选择根节点
        getRoot(to, root), dfs(root);
    }
}
int main() {
    read(n);
    for (int i = 1, u, v, w; i &lt; n; i++) {
        read(u), read(v), read(w);
        G[u].emplace_back(make_pair(v, w)), G[v].emplace_back(make_pair(u, w));
    }
    read(k);
    root = 0, tot = dp[root] = n;
    getRoot(1, root), dfs(root);
    cout &lt;&lt; res &lt;&lt; endl;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF1320C World of Darkraft: Battle for Azathoth]]></title>
        <id>https://shaun118294191.github.io/post/cf1320c-world-of-darkraft-battle-for-azathoth/</id>
        <link href="https://shaun118294191.github.io/post/cf1320c-world-of-darkraft-battle-for-azathoth/">
        </link>
        <updated>2020-03-11T01:18:31.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1320C">题目链接</a><br>
给定n种武器(攻击为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 价格为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)，m种(防御为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">y_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">c_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>)防具, p个怪物(防御为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">x_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 攻击<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">y_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 金币<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">z_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)。</p>
<p>你必须选择一个武器(攻击力为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>)和一个防具(防御为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>), 一个怪物能被击杀，当且仅当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>&gt;</mo><msub><mi>x</mi><mi>k</mi></msub><mi>A</mi><mi>N</mi><mi>D</mi><mi>y</mi><mo>&gt;</mo><msub><mi>y</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">x &gt; x_k AND y &gt; y_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。求最大收益(可能为负)。</p>
<ul>
<li>将怪物按照防御x排序，从小到大处理(类似扫描线)。</li>
</ul>
<pre><code class="language-cpp">    for (int i = 0, v, c; i &lt; n; i++) //武器与怪物防御力放在一起排序
        read(v), read(c), vec.emplace_back(make_pair(v - 1, make_pair(Inf, c)));
    for(...) vec.emplace_back(make_pair(def, make_pair(atk, c)));
</code></pre>
<ul>
<li>找到最小的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 使得 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mi>j</mi></msub><mo>&gt;</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">y_j &gt; x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8252079999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>，则编号 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≥</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">\geq j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 的所有防具获得的金币<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>D</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">D_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>都加上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">z_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>(金币初始值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><msub><mi>c</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">-c_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8694379999999999em;vertical-align:-0.286108em;"></span><span class="mord">−</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>)。</li>
<li>upper_bound找到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>&gt;</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">x_i &gt; x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>, 则最大获利为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><msub><mi>c</mi><mi>i</mi></msub><mo>+</mo><mi>max</mi><mo>⁡</mo><msub><mi>D</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">-c_i + \max D_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord">−</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mop">max</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>。</li>
</ul>
<p>于是可以按防具下标建立线段树维护max, 支持区间增值即可。</p>
<p>注:</p>
<ul>
<li>最大收益可能为-2e9。</li>
<li>对pair排序以及upper_bound, 为防止临时变量第二关键值影响需将其设为Inf<br>
<code>int pos = upper_bound(armor.begin(), armor.end(), make_pair(y, Inf)) - armor.begin();</code></li>
</ul>
<p>Code:</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
constexpr int MAXN = 2e5 + 5;
constexpr int Inf = 0x7fffffff;
using namespace std;
using LL = long long;
template &lt;typename T&gt;
inline void read(T &amp;x) {
    int f = 1; x = 0;
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
struct segTree {
    segTree *Lson, *Rson;
    int l, r;
    int max, tag;
}Tree[MAXN &lt;&lt; 1];
int tot, n, m, p, ans = -Inf;
vector&lt; pair&lt;int, int&gt; &gt; weapon, armor;
vector&lt; pair&lt;int, pair&lt;int, int&gt; &gt; &gt; vec;
using Node = segTree *;
#define Lson root-&gt;Lson
#define Rson root-&gt;Rson
inline void build(int L, int R, Node root) {
    root-&gt;l = L, root-&gt;r = R;
    if (L == R) {
        root-&gt;max = -armor[L].second;
        return;
    }
    int mid = (L + R) &gt;&gt; 1;
    Lson = &amp;Tree[++tot], Rson = &amp;Tree[++tot]; 
    build(L, mid, Lson), build(mid + 1, R, Rson);
    root-&gt;max = max(Lson-&gt;max, Rson-&gt;max);
}
inline void pushTag(Node root) {
    if (!root-&gt;tag) return;
    Lson-&gt;tag += root-&gt;tag, Lson-&gt;max += root-&gt;tag;
    Rson-&gt;tag += root-&gt;tag, Rson-&gt;max += root-&gt;tag;
    root-&gt;tag = 0;
}
inline void change(int L, int R, int val, Node root) {
    if (L &lt;= root-&gt;l &amp;&amp; root-&gt;r &lt;= R) {
        root-&gt;max += val, root-&gt;tag += val;
        return;
    }
    pushTag(root);
    int mid = (root-&gt;l + root-&gt;r) &gt;&gt; 1;
    if (L &lt;= mid) change(L, R, val, Lson);
    if (R &gt; mid) change(L, R, val, Rson);
    root-&gt;max = max(Lson-&gt;max, Rson-&gt;max);
}
int main() {
    read(n), read(m), read(p);
    for (int i = 0, v, c; i &lt; n; i++) //武器与怪物防御力放在一起排序
        read(v), read(c), vec.emplace_back(make_pair(v - 1, make_pair(Inf, c)));
    for (int i = 0, v, c; i &lt; m; i++) 
        read(v), read(c), armor.emplace_back(make_pair(v, c));
    sort(armor.begin(), armor.end()); //防具按防御值升序排序
    build(0, m - 1, Tree); //按防具下标建树
    for (int i = 0, def, atk, c; i &lt; p; i++) {
        read(def), read(atk), read(c);
        vec.emplace_back(make_pair(def, make_pair(atk, c)));
    }
    sort(vec.begin(), vec.end());
    for (auto &amp;i : vec) {
        int x = i.first, y = i.second.first, c = i.second.second;
        if (y == Inf) { //y = inf表明这是一个武器
            ans = max(ans, -c + Tree-&gt;max);
            continue;
        }
        int pos = upper_bound(armor.begin(), armor.end(), make_pair(y, Inf)) - armor.begin();
        if (pos &lt; m) change(pos, m - 1, c, Tree); //后缀区间增值
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[网络流]]></title>
        <id>https://shaun118294191.github.io/post/wang-luo-liu/</id>
        <link href="https://shaun118294191.github.io/post/wang-luo-liu/">
        </link>
        <updated>2020-03-10T02:17:53.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/SYCstudio/p/7260613.html">网络流</a></p>
<p>Edmonds Karp:</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
const int MAXN = 1e4 + 4;
const int MAXM = 1e5 + 5;
const int Inf = 0x3f3f3f3f;
using namespace std;
inline int read(){
	int x = 0, f = 1;
	char ch = getchar();
	while(!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
	while(isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
	return x * f;
}
struct E{
	int to, c, next;
	E(){}
	E(int _to, int _c, int _next){
		to = _to, c = _c, next = _next;
	}
}Edge[MAXM &lt;&lt; 1];
int head[MAXN], incf[MAXN], pre[MAXN], tot, inq[MAXN];
inline void add(int from, int to, int c){
	Edge[tot] = E(to, c, head[from]), head[from] = tot++;
}
inline bool bfs(int s, int t){
	memset(inq, 0, sizeof(inq));
	queue&lt;int&gt;q;
	q.push(s);
	inq[s] = true, incf[s] = Inf;
	while(!q.empty()){
		int cur = q.front();
		q.pop();
		for(int i = head[cur]; ~i; i = Edge[i].next){
			if(!Edge[i].c) continue;
			int to = Edge[i].to;
			if(!inq[to]){
				incf[to] = min(incf[cur], Edge[i].c);
				pre[to] = i, inq[to] = true;
				q.push(to);
				if(to == t) return true;
			}
		}
	}
	return false;
}
inline void update(int s, int t, int &amp;maxFlow){
	int x = t;
	while(x != s){
		int i = pre[x];
		Edge[i].c -= incf[t];
		Edge[i ^ 1].c += incf[t];
		x = Edge[i ^ 1].to;
	}
	maxFlow += incf[t];
}
int n, m, s, t, maxFlow;
int main(){
	n = read(), m = read(), s = read(), t = read();
	memset(head, -1, sizeof(head));
	for(int i = 1; i &lt;= m; i++){
		int u, v, c;
		u = read(), v = read(), c = read();
		add(u, v, c), add(v, u, 0);
	}
	while(bfs(s, t)) update(s, t, maxFlow);
	cout &lt;&lt; maxFlow &lt;&lt; endl;
	return 0;
}
</code></pre>
<p>Dinic:</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
//https://www.luogu.com.cn/problem/P2740
const int MAXN = 1e4 + 4;
const int MAXM = 1e5 + 5;
const int Inf = 0x3f3f3f3f;
using namespace std;
inline int read(){
	int x = 0, f = 1;
	char ch = getchar();
	while(!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
	while(isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
	return x * f;
}
struct E{
	int to, c, next;
	E(){}
	E(int _to, int _c, int _next){
		to = _to, c = _c, next = _next;
	}
}Edge[MAXM &lt;&lt; 1];
int head[MAXN &lt;&lt; 1], curv[MAXN &lt;&lt; 1], tot;
int n, m, maxFlow, s, t;
int incf[MAXN &lt;&lt; 1], pre[MAXN &lt;&lt; 1], depth[MAXN &lt;&lt; 1];
inline void add(int from, int to, int c){
	Edge[tot] = E(to, c, head[from]), head[from] = tot++;
}
inline bool bfs(){
	memset(depth, 0, sizeof(depth));
	memcpy(curv, head, sizeof(head));
	queue&lt;int&gt;q;
	q.push(s), depth[s] = 1;
	while(!q.empty()){
		int cur = q.front();
		q.pop();
		for(int i = head[cur]; ~i; i = Edge[i].next){
			int to = Edge[i].to;
			if(!Edge[i].c || depth[to]) continue;
			depth[to] = depth[cur] + 1;
			q.push(to);
			if(t == to) return true;
		}
	}
	return false;
}
int dinic(int cur, int limit){
	if(cur == t) return limit;
	int flow = 0;
	for(int i = curv[cur]; ~i; i = Edge[i].next){
		curv[cur] = i;
		int to = Edge[i].to;
		if(Edge[i].c &amp;&amp; depth[to] == depth[cur] + 1){
			int k = dinic(to, min(Edge[i].c, limit));
			if(k == 0) continue;
			Edge[i].c -= k;
			Edge[i ^ 1].c += k;
			limit -= k, flow += k;
		}
	}
	if(flow == 0) depth[cur] = 0;
	return flow;
}
int main(){
	n = read(), m = read(), s = read(), t = read();
	memset(head, -1, sizeof(head));
	for(int i = 1; i &lt;= m; i++){
		int u, v, c;
		u = read(), v = read(), c = read();
		add(u, v, c), add(v, u, 0);
	}
	while(bfs()) maxFlow += dinic(s, Inf);
	cout &lt;&lt; maxFlow &lt;&lt; endl;
	return 0;
}
</code></pre>
<p>最小割：</p>
<p><a href="https://www.luogu.com.cn/problem/SP300">Cable TV Network</a>:</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
//https://www.luogu.com.cn/problem/P2740
const int MAXN = 55;
const int MAXM = 1e4 + 4;
const int Inf = 0x3f3f3f3f;
using namespace std;
inline int read(){
	int x = 0, f = 1;
	char ch = getchar();
	while(!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
	while(isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
	return x * f;
}
struct E{
	int to, c, next;
	E(){}
	E(int _to, int _c, int _next){
		to = _to, c = _c, next = _next;
	}
}Edge[MAXM &lt;&lt; 1];
int head[MAXN &lt;&lt; 1], tot(1);
int n, m, maxFlow, s, t;
int depth[MAXN &lt;&lt; 1], curv[MAXN &lt;&lt; 1];
inline void add(int from, int to, int c){
	Edge[++tot] = E(to, c, head[from]), head[from] = tot;
}
inline bool bfs(){
	memset(depth, 0, sizeof(depth));
	memcpy(curv, head, sizeof(head));
	queue&lt;int&gt;q;
	q.push(s), depth[s] = 1;
	while(!q.empty()){
		int cur = q.front();
		q.pop();
		for(int i = head[cur]; i; i = Edge[i].next){
			int to = Edge[i].to;
			if(!Edge[i].c || depth[to]) continue;
			depth[to] = depth[cur] + 1;
			q.push(to);
			if(to == t) return true;
		}
	}
	return false;
}
int dinic(int cur, int limit){
	if(cur == t) return limit;
	int flow = 0;
	for(int i = curv[cur]; ~i; i = Edge[i].next){
		curv[cur] = i;
		int to = Edge[i].to;
		if(Edge[i].c &amp;&amp; depth[to] == depth[cur] + 1){
			int k = dinic(to, min(Edge[i].c, limit));
			if(k == 0) continue;
			Edge[i].c -= k;
			Edge[i ^ 1].c += k;
			limit -= k, flow += k;
		}
	}
	if(flow == 0) depth[cur] = 0;
	return flow;
}
int u[MAXM], v[MAXM], f, testCase;
int main(){
	cin &gt;&gt; testCase;
	while(testCase--){
		cin &gt;&gt; n &gt;&gt; m;
		f = Inf;
		for(int i = 1; i &lt;= m; i++)	u[i] = read(), v[i] = read();
		for(s = 0; s &lt; n; s++)
			for(t = 0; t &lt; n; t++){
				if(s == t) continue;
				memset(head, 0, sizeof(head));
				tot = 1, maxFlow = 0;
				for(int i = 0; i &lt; n; i++)
					if(i == s || i == t) add(i, i + n, Inf), add(i + n, i, 0);
					else add(i, i + n, 1), add(i + n, i, 0);
				for(int i = 1; i &lt;= m; i++)
					add(u[i] + n, v[i], Inf), add(v[i], u[i] + n, 0),
					add(v[i] + n, u[i], Inf), add(u[i], v[i] + n, 0);
				while(bfs()) maxFlow += dinic(s, Inf);
				f = min(f, maxFlow);
			}
		if(n &lt;= 1 || f == Inf) f = n;
		cout &lt;&lt; f &lt;&lt; endl; 
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF1320B Navigation System]]></title>
        <id>https://shaun118294191.github.io/post/cf1320b-navigation-system/</id>
        <link href="https://shaun118294191.github.io/post/cf1320b-navigation-system/">
        </link>
        <updated>2020-03-09T13:29:48.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1320B">题目链接</a><br>
Rebuild 最少：若有多条最短路，让每次导航恰好取和工作路径部分重合或完全重合的最短路。如果当前节点经工作路径到终点的距离大于到该点的最短路，且最短路不和工作路径有交集，一定会 Rebuild，有交集就不 Rebuild; 如果工作路径和最短路完全重合，则不会再 Rebuild，beak即可。</p>
<p>Rebuild 最多：若有多条最短路，让每次导航优尽量取在工作路径外的最短路。 如果当前节点经工作路径到终点的距离大于到该点的最短路，且存在一最短路不和工作路径有交集，一定 Rebuild ; 若当前节点经工作路径到终点的距离等于到该点的最短路，且有多条最短路优先取工作路径以外的, 若仅有一条最短路，即只能取在工作路径上的，则不会再 Rebuild，beak即可。</p>
<p>预处理：dfs求工作路径上每个点到终点距离，求最短路时顺便记录这条最短路和工作路径是否有交集。</p>
<p>Code:</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 2e5 + 5;
int n, m, k, a[maxn], vis[maxn], p[maxn], t, u, v;
int mi_dis[maxn], chain_dis[maxn];
bool on_chain[maxn], out_chain[maxn];
int mi, mx;
#ifndef onlinejudge
map&lt;int, int&gt; id;
#else
unordered_map&lt;int, int&gt; id;
#endif
inline int read() {
    char ch = getchar();
    int x = 0, f = 1;
    while (ch &lt; '0' || ch &gt; '9') f = (ch == '-' ? -1 : 1), ch = getchar();
    while (ch &gt;= '0' &amp;&amp; ch &lt;= '9')
        x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - 48, ch = getchar();
    return x * f;
}
struct edge {
    int nxt, to;
    int mi_dis;
} e[maxn * 2];
void add(int from, int to, int dis) {
    e[t].to = to, e[t].mi_dis = dis, e[t].nxt = p[from], p[from] = t++;
}
void spfa(int st) {
    for (int i = 1; i &lt;= n; i++) mi_dis[i] = 1e9;
    deque&lt;int&gt; q;
    q.push_back(st), vis[st] = 1, mi_dis[st] = 0;
    while (!q.empty()) {
        int now = q.front();
        q.pop_front(), vis[now] = 0;
        for (int i = p[now]; i != -1; i = e[i].nxt) {
            int to = e[i].to;
            if (mi_dis[to] &gt; mi_dis[now] + e[i].mi_dis) {
                out_chain[to] = 0, on_chain[to] = 0;
                mi_dis[to] = mi_dis[now] + e[i].mi_dis;
                if (id[to]) {
                    if (id[now] &amp;&amp; id[now] - 1 == id[to])
                        on_chain[to] = 1;
                    else
                        out_chain[to] = 1;
                }
                if (!vis[to]) {
                    if (q.empty() || mi_dis[to] &gt; mi_dis[q.front()])
                        q.push_back(to);
                    else
                        q.push_front(to);
                    vis[to] = 1;
                }
            } else if (mi_dis[to] == mi_dis[now] + e[i].mi_dis) {
                if (id[to]) {
                    if (id[now] &amp;&amp; id[now] - 1 == id[to])
                        on_chain[to] = 1;
                    else
                        out_chain[to] = 1;
                }
            }
        }
    }
}
void dfs(int now, int x, int d) {
    chain_dis[now] = d;
    if (x == 0) return;
    for (int i = p[now]; i + 1; i = e[i].nxt) {
        int to = e[i].to;
        if (to == a[x]) dfs(to, x - 1, d + e[i].mi_dis);
    }
}
int main() {
    memset(p, -1, sizeof(p));
    n = read(), m = read();
    for (int i = 1; i &lt;= m; i++) {
        u = read(), v = read();
        add(v, u, 1);
    }
    k = read();
    for (int i = 1; i &lt;= k; i++) a[i] = read(), id[a[i]] = i;
    spfa(a[k]);
    dfs(a[k], k - 1, 0);
    int mi = 0, mx = 0;
    for (int i = 1; i &lt;= k - 1; i++) {
        if (chain_dis[a[i]] &gt; mi_dis[a[i]]) {
            if (!on_chain[a[i]]) mi++;
        } else break;
    }
    for (int i = 1; i &lt;= k - 1; i++) {
        if (chain_dis[a[i]] &gt; mi_dis[a[i]]) {
            if (out_chain[a[i]]) mx++;
        } else {
            if (out_chain[a[i]]) mx++;
            if (!out_chain[a[i]]) break;
        }
    }
    cout &lt;&lt; mi &lt;&lt; &quot; &quot; &lt;&lt; mx;
    return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>