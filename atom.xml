<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://shaun118294191.github.io</id>
    <title>Shaun</title>
    <updated>2020-04-26T06:22:10.317Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://shaun118294191.github.io"/>
    <link rel="self" href="https://shaun118294191.github.io/atom.xml"/>
    <subtitle>Valar morghulis Valar Dohaeris</subtitle>
    <logo>https://shaun118294191.github.io/images/avatar.png</logo>
    <icon>https://shaun118294191.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Shaun</rights>
    <entry>
        <title type="html"><![CDATA[new blog]]></title>
        <id>https://shaun118294191.github.io/post/new-blog/</id>
        <link href="https://shaun118294191.github.io/post/new-blog/">
        </link>
        <updated>2020-04-26T06:21:11.000Z</updated>
        <content type="html"><![CDATA[<p><a href="shaunshane.gitee.io">blog</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P4098 [HEOI2013]ALO]]></title>
        <id>https://shaun118294191.github.io/post/p4098-heoi2013alo/</id>
        <link href="https://shaun118294191.github.io/post/p4098-heoi2013alo/">
        </link>
        <updated>2020-04-08T06:42:40.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4098">题目链接</a></p>
<p>题意：</p>
<ul>
<li>可以选取一个区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l, r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>并将区间次大值和区间内的某个数异或，求异或最大值。</li>
</ul>
<p>思路：</p>
<ul>
<li>设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为次大值，则只需求出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为次大值的最大区间范围<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mi>i</mi><mo separator="true">,</mo><mi>r</mi><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[li, ri]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>, 通过可持久化trie树贪心即可求出最大异或值。</li>
<li>设位置<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>左边第一个大于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的数的位置为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>l</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">l_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 第二个大于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>l</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">l_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li>设位置<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>右边第一个大于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的数的位置为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>r</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">r_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 第二个大于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>r</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">r_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br>
<img src="https://shaun118294191.github.io/post-images/1586329194206.png" alt="" loading="lazy"></li>
<li>则可选择的区间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><msub><mi>l</mi><mn>1</mn></msub><mo>+</mo><mn>1</mn><mo separator="true">,</mo><msub><mi>r</mi><mn>2</mn></msub><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[l_1 + 1, r_2 - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><msub><mi>l</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn><mo separator="true">,</mo><msub><mi>r</mi><mn>1</mn></msub><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[l_2 + 1, r_1 - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，于是最大区间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><msub><mi>l</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn><mo separator="true">,</mo><msub><mi>r</mi><mn>2</mn></msub><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[l_2 + 1, r_2 - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>。<br>
<img src="https://shaun118294191.github.io/post-images/1586329205107.png" alt="" loading="lazy"><br>
<img src="https://shaun118294191.github.io/post-images/1586329210414.png" alt="" loading="lazy"></li>
<li>求大于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的数即求<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的后继，将原数组排序后一次插入平衡树(set)，则已插入的数值一定是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的后继，只需以下标为key查询<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>l</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>r</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">l_2, r_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。<pre><code class="language-cpp">sort(jewel + 1, jewel + n + 1, cmp); //按key值从大到小插入元素
s.insert(jewel[1]); //按key值从大到小插入元素
for (int i = 2, L, R; i &lt;= n; i++) {
    l = r = s.lower_bound(jewel[i]); //求后继(后继已插入 按indices查找)

    if (l != s.begin()) --l;
    if (l != s.begin()) --l, L = l-&gt;pos + 1;
    else L = 1;

    if (r != s.end()) ++r;
    if (r != s.end()) R = r-&gt;pos - 1;
    else R = n;

    res = max(res, search(root[R], jewel[i].key, L));
    s.insert(jewel[i]);
}
</code></pre>
</li>
</ul>
<p>Code:</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
constexpr int MAXN = 5e4 + 4;
constexpr int BIT = 30;

using namespace std;

template &lt;typename T&gt;
inline void read(T &amp;x) {
    int f = 1; x = 0;
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}

struct node {
    int key, pos;
    inline bool operator &lt; (const node &amp;other) const {
        return pos &lt; other.pos;
    }
}jewel[MAXN];

inline bool cmp(const node &amp;a, const node &amp;b) {
    return a.key &gt; b.key;
}

struct Trie {
    Trie *son[2];
    int lst;
}Tree[MAXN &lt;&lt; 5], *root[MAXN];
using Node = Trie *;

inline Node newNode(Node &amp;root) {
    static int nptr;
    return root = &amp;Tree[++nptr];
}

inline void insert(Node pre, Node root, int x, int index) {
    for (int i = BIT - 1; ~i; i--) {
        int tmp = (x &gt;&gt; i) &amp; 1;
        if (pre) root-&gt;son[tmp ^ 1] = pre-&gt;son[tmp ^ 1];
        root-&gt;lst = max(root-&gt;lst, index);
        root = newNode(root-&gt;son[tmp]), pre = pre ? pre-&gt;son[tmp] : NULL;
    }
    root-&gt;lst = max(root-&gt;lst, index);
}

inline int search(Node root, int x, int limit) {
    int res = 0;
    for (int i = BIT - 1; ~i; i--) {
        int tmp = (x &gt;&gt; i) &amp; 1;
        if (root-&gt;son[tmp ^ 1] &amp;&amp; root-&gt;son[tmp ^ 1]-&gt;lst &gt;= limit)
            res |= (1 &lt;&lt; i), root = root-&gt;son[tmp ^ 1];
        else root = root-&gt;son[tmp];
    }
    return res;
}

int main() {
    int n, res(0);
    set&lt;node&gt; s;
    set&lt;node&gt;::iterator l, r;
    read(n);
    insert(Tree, newNode(root[0]), 0, 0);
    for (int i = 1; i &lt;= n; i++) {
        read(jewel[i].key), jewel[i].pos = i;
        insert(root[i - 1], newNode(root[i]), jewel[i].key, i);
    }
    sort(jewel + 1, jewel + n + 1, cmp); //按key值从大到小插入元素
    s.insert(jewel[1]); //按key值从大到小插入元素
    for (int i = 2, L, R; i &lt;= n; i++) {
        l = r = s.lower_bound(jewel[i]); //求后继(后继已插入 按indices查找)

        if (l != s.begin()) --l;
        if (l != s.begin()) --l, L = l-&gt;pos + 1;
        else L = 1;

        if (r != s.end()) ++r;
        if (r != s.end()) R = r-&gt;pos - 1;
        else R = n;

        res = max(res, search(root[R], jewel[i].key, L));
        s.insert(jewel[i]);
    }
    cout &lt;&lt; res &lt;&lt; endl;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P1337 [JSOI2004]平衡点 / 吊打XXX]]></title>
        <id>https://shaun118294191.github.io/post/p1337-jsoi2004ping-heng-dian-diao-da-xxx/</id>
        <link href="https://shaun118294191.github.io/post/p1337-jsoi2004ping-heng-dian-diao-da-xxx/">
        </link>
        <updated>2020-04-04T08:59:00.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1337">题目链接</a><br>
模拟退火模板题，有空再跟新...</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;

constexpr int MAXN = 1e3 + 3;
constexpr double down = 0.996;

int n;
pair&lt;pair&lt;int, int&gt;, int&gt; obj[MAXN];
double x, y, Ep;

inline double energy(double x, double y) { //重力势能越小越稳定
    double E = 0;
    for (int i = 0; i &lt; n; i++) {
        double dx = x - obj[i].first.first;
        double dy = y - obj[i].first.second;
        E += sqrt(dx * dx + dy * dy) * obj[i].second;
    }
    return E;
}

inline void SA() { //SimulateAnneal
    double T = 3000;
    while (T &gt; 1e-14) {
        double randx = x + (rand() * 2 - RAND_MAX) * T;
        double randy = y + (rand() * 2 - RAND_MAX) * T;
        double E = energy(randx, randy);
        double delta = E - Ep;
        if (delta &lt; 0) { //E更小 答案更优
            x = randx, y = randy, Ep = E;
        }
        else if (exp(-delta / T) * RAND_MAX &gt; rand()) { //根据多项式概率接受
            x = randx, y = randy;
        }
        T *= down;
    }
}

int main() {
    std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
    cin &gt;&gt; n;
    for (int i = 0; i &lt; n; i++) {
        cin &gt;&gt; obj[i].first.first &gt;&gt; obj[i].first.second &gt;&gt; obj[i].second;
        x += obj[i].first.first, y += obj[i].first.second;
    }
    x /= n, y /= n, Ep = energy(x, y);
    for (int i = 0; i &lt; 4; i++) SA();
    cout &lt;&lt; setprecision(3) &lt;&lt; fixed &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF1312E Array Shrinking]]></title>
        <id>https://shaun118294191.github.io/post/cf1312e-array-shrinking/</id>
        <link href="https://shaun118294191.github.io/post/cf1312e-array-shrinking/">
        </link>
        <updated>2020-04-04T08:50:03.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1312E">题目链接</a></p>
<p>给定一个数组，若数组中连个相邻的数相同(都为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>)，则它们合并为一个数，其值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。求合并后的最小长度。</p>
<p>考虑区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">DP</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span>, 设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[l][r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 表示区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l, r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 合并后的最小长度，并设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">w[l][r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 表示区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l, r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 合并后的和。</p>
<p>状态转移方程：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>r</mi><mo>]</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>r</mi><mo>]</mo></mrow></mrow><annotation encoding="application/x-tex">dp[l][r] = min{dp[l][mid] + dp[mid + 1][r]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span></span></p>
<p>若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>r</mi><mo>]</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">dp[l][mid] = dp[mid + 1][r] = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> , 并且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>]</mo><mo>=</mo><mo>=</mo><mi>w</mi><mo>[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">w[l][mid] == w[mid + 1][r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> , 则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>r</mi><mo>]</mo><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi>w</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>r</mi><mo>]</mo><mo>=</mo><mi>w</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>]</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">dp[l][r] = 1, w[l][r] = w[l][mid] + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<p>Code:</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
//https://codeforces.ml/contest/1312/problem/E
#define boost std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)

using namespace std;
using LL = long long;

constexpr int MAXN = 505;
constexpr LL M = 998244353;

int n, a[MAXN], dp[MAXN][MAXN], w[MAXN][MAXN];

template &lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1; x = 0;
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}

int main() {
    boost;
    cin &gt;&gt; n;
    memset(dp, 0x3f, sizeof(dp));
    for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i], dp[i][i] = 1, w[i][i] = a[i];
    for (int len = 2; len &lt;= n; len++)
        for (int l = 1; l + len - 1 &lt;= n; l++) {
            int r = l + len - 1;
            for (int mid = l; mid &lt; r; mid++) {
                dp[l][r] = min(dp[l][r], dp[l][mid] + dp[mid + 1][r]);
                if (dp[l][mid] == 1 &amp;&amp; dp[mid + 1][r] == 1 &amp;&amp; w[l][mid] == w[mid + 1][r])
                    dp[l][r] = 1, w[l][r] = w[l][mid] + 1;
            }
        }
    cout &lt;&lt; dp[1][n] &lt;&lt; endl;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P2870 [USACO07DEC]Best Cow Line G]]></title>
        <id>https://shaun118294191.github.io/post/p2870-usaco07decbest-cow-line-g/</id>
        <link href="https://shaun118294191.github.io/post/p2870-usaco07decbest-cow-line-g/">
        </link>
        <updated>2020-04-01T12:31:47.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2870">题目链接</a><br>
给定长度为N的字符串<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>，构造一个长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span>使其字典序最小。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span>最初为空字符串，有以下操作：</p>
<ul>
<li>
<p>从S的头部删除一个字符，加到T的尾部</p>
</li>
<li>
<p>从S的尾部删除一个字符，加到T的尾部</p>
</li>
</ul>
<p>贪心：比较S与reverse(S)的字典序，如果S的字典序小则从S头部取出字符；否则从尾部取出。</p>
<p>本题数据加强，逐位比较会被卡。需hash + 二分或倍增求出最长相同前缀子串，比较下一个位置的大小。</p>
<p>注：字符串hash(%)不能直接用来比较字符串大小。</p>
<p>二分子串长度：</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
constexpr int MAXN = 5e5 + 5;
typedef unsigned long long uLL;
constexpr uLL base = 13331;
using namespace std;
int n;
uLL H1[MAXN], H2[MAXN], P[MAXN] = {1};
char s[MAXN], revs[MAXN];
string ans;
inline void Init() {
    for (int i = 1; i &lt;= n; i++) P[i] = P[i - 1] * base;
    for (int i = 1; i &lt;= n; i++) H1[i] = H1[i - 1] * base + s[i] - 'A' + 1;
    for (int i = 1; i &lt;= n; i++) H2[i] = H2[i - 1] * base + revs[i] - 'A' + 1;
}
inline uLL getHash(int l, int r, uLL * H) {
    return H[r] - H[l - 1] * P[r - l + 1];
}
inline bool compare(int l, int r) {
    int L = 0, R = r - l, len = -1;
    while (L &lt;= R) {
        int mid = (L + R) &gt;&gt; 1;
        if (getHash(l, l + mid, H1) == getHash(n - r + 1, n - r + 1 + mid, H2)) 
            len = mid, L = mid + 1;
        else R = mid - 1;
    }
    return s[l + len + 1] &lt; s[r - len - 1];
}
int main(){
    // freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
    // freopen(&quot;test.out&quot;,&quot;w&quot;,stdout);
    cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; i++) 
        getchar(), s[i] = getchar(), revs[n - i + 1] = s[i];
    Init();
    int l = 1, r = n;
    while (l &lt;= r) {
        if (compare(l, r)) ans += s[l], l++;
        else ans += s[r], r--;
    }
    for (int i = 0; i &lt; n; i++) {
        if (i &amp;&amp; i % 80 == 0) putchar('\n');
        putchar(ans[i]);
    }
	return 0;
}
</code></pre>
<p>倍增：</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
constexpr int MAXN = 5e5 + 5;
typedef unsigned long long uLL;
constexpr uLL base = 13331;
using namespace std;
int n;
uLL H1[MAXN], H2[MAXN], P[MAXN] = {1};
char s[MAXN], revs[MAXN];
string ans;
inline void Init() {
    for (int i = 1; i &lt;= n; i++) P[i] = P[i - 1] * base;
    for (int i = 1; i &lt;= n; i++) H1[i] = H1[i - 1] * base + s[i] - 'A' + 1;
    for (int i = 1; i &lt;= n; i++) H2[i] = H2[i - 1] * base + revs[i] - 'A' + 1;
}
inline uLL getHash(int l, int r, uLL * H) {
    return H[r] - H[l - 1] * P[r - l + 1];
}
inline bool compare(int l, int r) {
    int len = 1, Lst = l - 1, Rst = n - r;
    while (len) {
		if (Lst + len &lt;= r &amp;&amp; getHash(l, Lst + len, H1) == getHash(n - r + 1, Rst + len, H2)) {
			Lst += len, Rst += len, len &lt;&lt;= 1;
		} else len &gt;&gt;= 1;
	}
    return s[Lst + 1] &lt; revs[Rst + 1];
}
int main(){
    //freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
    //freopen(&quot;test.out&quot;,&quot;w&quot;,stdout);
    cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; i++) 
        getchar(), s[i] = getchar(), revs[n - i + 1] = s[i];
    Init();
    int l = 1, r = n;
    while (l &lt;= r) {
        if (compare(l, r)) ans += s[l], l++;
        else ans += s[r], r--;
    }
    for (int i = 0; i &lt; n; i++) {
        if (i &amp;&amp; i % 80 == 0) putchar('\n');
        putchar(ans[i]);
    }
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P1494 [国家集训队]小Z的袜子 /【模板】莫队]]></title>
        <id>https://shaun118294191.github.io/post/p1494-guo-jia-ji-xun-dui-xiao-z-de-wa-zi-mo-ban-mo-dui/</id>
        <link href="https://shaun118294191.github.io/post/p1494-guo-jia-ji-xun-dui-xiao-z-de-wa-zi-mo-ban-mo-dui/">
        </link>
        <updated>2020-04-01T12:29:54.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1494">题目链接</a><br>
多组询问求给定区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mi>i</mi><mo separator="true">,</mo><mi>r</mi><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[li, ri]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>中取出相同两个数的概率。</p>
<p>设区间内某种颜色的数目为cnt[color]。</p>
<p>则概率为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi mathvariant="normal">Σ</mi><mrow></mrow><mi>c</mi><mi>n</mi><mi>t</mi><mo>[</mo><mi>c</mi><mi>o</mi><mi>l</mi><mi>o</mi><mi>r</mi><mo>]</mo><mo>∗</mo><mo>(</mo><mi>c</mi><mi>n</mi><mi>t</mi><mo>[</mo><mi>c</mi><mi>o</mi><mi>l</mi><mi>o</mi><mi>r</mi><mo>]</mo><mo>−</mo><mn>1</mn><mo>)</mo></mrow><mrow><mo>(</mo><mi>r</mi><mo>−</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo>∗</mo><mo>(</mo><mi>r</mi><mo>−</mo><mi>l</mi><mo>)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Sigma{}cnt[color] * (cnt[color] - 1)}{(r - l + 1) * (r - l)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mbin mtight">∗</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Σ</span><span class="mord mtight"></span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span><span class="mopen mtight">[</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mclose mtight">]</span><span class="mbin mtight">∗</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span><span class="mopen mtight">[</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mclose mtight">]</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。</p>
<ul>
<li>将询问分块，一般取块的长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>q</mi><mi>r</mi><mi>t</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">sqrt(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 或<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mi>s</mi><mi>q</mi><mi>r</mi><mi>t</mi><mo>(</mo><mi>m</mi><mo>∗</mo><mn>2</mn><mo>÷</mo><mn>3</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">n / sqrt(m * 2 \div 3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mclose">)</span></span></span></span>。询问所在的块由询问左端点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">li</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span></span></span></span>决定。</li>
</ul>
<pre><code class="language-cpp">read(n), read(m), Len = n / sqrt(m * 2.0 / 3);
for (int i = 1; i &lt;= n; i++) cin &gt;&gt; c[i];
for (int i = 1; i &lt;= m; i++) 
    read(Q[i].l), read(Q[i].r), Q[i].id = i, Q[i].block = Q[i].l / Len;
sort(Q + 1, Q + m + 1, cmp1);
</code></pre>
<ul>
<li>排序：询问<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>q</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>q</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">q_i, q_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>所在块相同则其右端点排序，否则块的编号升序排序。</li>
</ul>
<pre><code class="language-cpp">struct query {
    int l, r, id, block, x/*记录询问分子*/, y/*记录询问分母*/;
}Q[MAXN];
inline bool cmp1 (const query &amp;a, const query &amp;b) {
    return (a.block== b.block) ? a.r &lt; b.r : a.block &lt; b.block;
}
inline bool cmp2 (const query &amp;a, const query &amp;b) { //按照原始顺序排序
    return a.id &lt; b.id;
}
</code></pre>
<ul>
<li>询问时，用指针<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo separator="true">,</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">l, r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>记录上一次询问的位置(初始均为1)，不断加减扩展即可(求的是delta)。</li>
</ul>
<p>Code:</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
constexpr int MAXN = 5e4 + 4;
using namespace std;
template &lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1; x = 0; 
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
int n, m, Len, l, r, ans;
int c[MAXN], cnt[MAXN];
struct query {
    int l, r, id, block, x/*记录询问分子*/, y/*记录询问分母*/;
}Q[MAXN];
inline bool cmp1 (const query &amp;a, const query &amp;b) {
    return (a.block== b.block) ? a.r &lt; b.r : a.block &lt; b.block;
}
inline bool cmp2 (const query &amp;a, const query &amp;b) { //按照原始顺序排序
    return a.id &lt; b.id;
}
inline int gcd(int x, int y) {
    return !y ? x : gcd(y, x % y);
}
signed main(){
    read(n), read(m), Len = n / sqrt(m * 2.0 / 3);
    for (int i = 1; i &lt;= n; i++) read(c[i]);
    for (int i = 1; i &lt;= m; i++) 
        read(Q[i].l), read(Q[i].r), Q[i].id = i, Q[i].block = Q[i].l / Len;
    sort(Q + 1, Q + m + 1, cmp1);
    l = 1, r = 0;
    for (int i = 1; i &lt;= m; i++) {
        while (r &lt; Q[i].r) {
            r++;
            ans -= cnt[c[r]] * (cnt[c[r]] - 1);
            cnt[c[r]]++;
            ans += cnt[c[r]] * (cnt[c[r]] - 1);
        }
        while (r &gt; Q[i].r) {
            ans -= cnt[c[r]] * (cnt[c[r]] - 1);
            cnt[c[r]]--;
            ans += cnt[c[r]] * (cnt[c[r]] - 1);
            r--;
        }
        while (l &lt; Q[i].l) {
            ans -= cnt[c[l]] * (cnt[c[l]] - 1);
            cnt[c[l]]--;
            ans += cnt[c[l]] * (cnt[c[l]] - 1);
            l++;
        }
        while (l &gt; Q[i].l) {
            l--;
            ans -= cnt[c[l]] * (cnt[c[l]] - 1);
            cnt[c[l]]++;
            ans += cnt[c[l]] * (cnt[c[l]] - 1);
        }
        Q[i].x = ans, Q[i].y = (Q[i].r - Q[i].l + 1) * (Q[i].r - Q[i].l);
    }
    sort(Q + 1, Q + m + 1, cmp2);
    for (int i = 1; i &lt;= m; i++)
        if (Q[i].l == Q[i].r) puts(&quot;0/1&quot;);
        else printf(&quot;%lld/%lld\n&quot;, Q[i].x / gcd(Q[i].x, Q[i].y), Q[i].y / gcd(Q[i].x, Q[i].y));
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[God J and Ancient Tree]]></title>
        <id>https://shaun118294191.github.io/post/god-j-and-ancient-tree/</id>
        <link href="https://shaun118294191.github.io/post/god-j-and-ancient-tree/">
        </link>
        <updated>2020-03-27T12:36:03.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/T125991">题目链接</a></p>
<p>In The World of Code, there are three gods who keep the world running, and God J is one of them. In the garden of God J, an ancient tree grows. This tree can be represented as an undirected graph with nn nodes and n-1 edges. Nodes are numbered through 1 to n, where node 1 is called the root. Node i has <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> mysterious points.</p>
<p>As this ancient tree grows, God J is going to prone some parts of it. In particular, God J will choose two nodes x and y (probably the same). After that he will delete those nodes which are neither on the shortest path from the root to node x, nor on the shortest path from the root to node y. The remaining tree is &quot;Y&quot;-shaped, or even simpler. The final score is the bitwise xor sum of all mysterious points of the remaining nodes.</p>
<p>Your job is to help God J choose the two nodes, in order to maximize the final score.</p>
<p>Recall that the bitwise xor sum of a set of numbers a,b,c,… is a⊕b⊕c⊕…, where ⊕ stands for bitwise xor.</p>
<p>In the first sample down below if you choose node 4 and 5 the red nodes will remain and you will get the final score up to 128⊕48⊕4⊕8=188.<br>
<img src="https://shaun118294191.github.io/post-images/1585312803512.png" alt="" loading="lazy"></p>
<p>跟新中...<br>
Code:</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

template &lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1;
    x = 0;
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}

constexpr int MAXN = 1e5 + 5;
constexpr int BIT = 31;
struct Trie {
    Trie *son[2];
}Tree[MAXN * BIT &lt;&lt; 2], *root[MAXN];
using A = int [MAXN];
using Node = Trie *;
int n, ans;
A w, dis, sz, son, father;

inline Node newNode(Node &amp;root) {
    static int nptr;
    return root ? root : root = &amp;Tree[++nptr];
}

inline void insert(Node root, int x) {
    for (int i = BIT, tmp; ~i; i--) {
        tmp = (x &gt;&gt; i) &amp; 1;
        root = newNode(root-&gt;son[tmp]);
    }
}

inline void merge(Node pre, Node &amp;root) {
    if (root == NULL) {root = pre; return;}
    if (pre == NULL) return;
    merge(pre-&gt;son[0], root-&gt;son[0]);
    merge(pre-&gt;son[1], root-&gt;son[1]);
}

inline void search(Node root, int x, int fa) {
    int res = 0;
    for (int i = BIT, tmp; ~i; i--) {
        tmp = (x &gt;&gt; i) &amp; 1;
        if (root-&gt;son[tmp ^ 1]) root = root-&gt;son[tmp ^ 1], res |= (1 &lt;&lt; i);
        else root = root-&gt;son[tmp];
    }
    ans = max(ans, res);
}

vector&lt;int&gt; G[MAXN];
inline void dfs(int cur, int fa) {
    dis[cur] = (dis[fa] ^ w[cur]);
    father[cur] = fa, sz[cur] = 1, son[cur] = 0;
    for (auto &amp;to : G[cur]) {
        if (fa == to) continue;
        dfs(to, cur);
        sz[cur] += sz[to];
        if (!son[cur] || sz[son[cur]] &lt; sz[to]) son[cur] = to; //重儿子
    }
}

inline void dfs3(int fa, int cur) {
    search(root[fa], dis[cur] ^ dis[fa], fa);
    for (auto &amp;to : G[cur]) {
        if (to == father[cur]) continue;
        dfs3(fa, to);
    }
    merge(root[cur], root[fa]);
}

inline void dfs2(int cur) {
    for (auto &amp;to : G[cur]) {
        if (to == father[cur]) continue;
        if (son[cur] == to) dfs2(to), merge(root[to], root[cur]);
    }
    for (auto &amp;to : G[cur]) {
        if (to == father[cur] || to == son[cur]) continue;
        dfs3(cur, to);
        dfs2(to);
    }
}

int main() {
    read(n);
    for (int i = 1; i &lt;= n; i++) read(w[i]);
    for (int i = 1, u, v; i &lt; n; i++) {
        read(u), read(v);
        G[u].emplace_back(v), G[v].emplace_back(u);
    }
    dfs(1, 0);
    for (int i = 1; i &lt;= n; i++)
        ans = max(ans, dis[i]), newNode(root[i]), insert(root[i], dis[i]);
    dfs2(1);
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF600E Lomsat gelral]]></title>
        <id>https://shaun118294191.github.io/post/cf600e-lomsat-gelral/</id>
        <link href="https://shaun118294191.github.io/post/cf600e-lomsat-gelral/">
        </link>
        <updated>2020-03-27T11:45:05.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF600E">题目链接</a></p>
<p>一棵树有n个结点，每个结点都是一种颜色，每个颜色有一个编号，求树中每个子树的最多的颜色编号的和。</p>
<p><a href="https://codeforces.ml/blog/entry/44351">Dsu on tree</a></p>
<pre><code class="language-cpp">inline void Init(int cur, int fa) {
    father[cur] = fa, son[cur] = 0, sz[cur] = 1;
    for (auto &amp;to : G[cur]) {
        if (to == fa) continue;
        Init(to, cur);
        sz[cur] += sz[to];
        if (!son[cur] || sz[son[cur]] &lt; sz[to])
            son[cur] = to;
    }
}
</code></pre>
<p>先预处理出每个节点的 father[node], 重儿子 son[node]。</p>
<p>dfs时，先dfs递归处理轻儿子，再dfs递归处理重儿子。</p>
<p>由于重儿子最后才递归处理，故其cnt[]可保留给父亲。而轻儿子的cnt[]会影响其它轻儿子的cnt[], 故递归结束后dfs2将cnt[]减去(轻儿子重儿子的cnt也要减去)。</p>
<pre><code class="language-cpp">
inline void add(int fa, int cur, int val) {
    cnt[color[cur]] += val, compare(fa, color[cur]);
    for (auto &amp;to : G[cur]) {
        if (to == father[cur] || to == son[fa]) continue; //to不是父亲节点且不是重儿子
        add(fa, to, val);
    }
}

inline void dfs(int cur, bool keep) {
    for (auto &amp;to : G[cur]) {
        if (to == father[cur] || to == son[cur]) continue;
        dfs(to, false); //递归处理轻儿子
    }
    if (son[cur]) dfs(son[cur], true); //递归处理重儿子
    res[cur] = res[son[cur]], maxCnt[cur] = maxCnt[son[cur]]; //保存重儿子已统计的信息
    add(cur, cur, 1);
    if (keep == false) son[cur] = 0, add(cur, cur, -1);
                    //为将轻儿子子树(包括重儿子)清空, son[cur] 赋为0;
}
</code></pre>
<p>Code:</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
template &lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1; x = 0;
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
 
constexpr int MAXN = 1e5 + 5;
using A = long long [MAXN];
 
int n;
A son, father, sz, cnt, color, res, maxCnt;
vector&lt;int&gt; G[MAXN];
 
inline void Init(int cur, int fa) {
    father[cur] = fa, son[cur] = 0, sz[cur] = 1;
    for (auto &amp;to : G[cur]) {
        if (to == fa) continue;
        Init(to, cur);
        sz[cur] += sz[to];
        if (!son[cur] || sz[son[cur]] &lt; sz[to])
            son[cur] = to;
    }
}
 
inline void compare(int cur, int col) {
    if (cnt[col] &gt; maxCnt[cur]) {
        res[cur] = col;
        maxCnt[cur] = cnt[col];
    } else if (cnt[col] == maxCnt[cur]) res[cur] += col;
}
 
inline void add(int fa, int cur, int val) {
    cnt[color[cur]] += val, compare(fa, color[cur]);
    for (auto &amp;to : G[cur]) {
        if (to == father[cur] || to == son[fa]) continue; //to不是父亲节点且不是重儿子
        add(fa, to, val);
    }
}

inline void dfs(int cur, bool keep) {
    for (auto &amp;to : G[cur]) {
        if (to == father[cur] || to == son[cur]) continue;
        dfs(to, false); //递归处理轻儿子
    }
    if (son[cur]) dfs(son[cur], true); //递归处理重儿子
    res[cur] = res[son[cur]], maxCnt[cur] = maxCnt[son[cur]]; //保存重儿子已统计的信息
    add(cur, cur, 1);
    if (keep == false) son[cur] = 0, add(cur, cur, -1);
                    //为将轻儿子子树(包括重儿子)清空, son[cur] 赋为0;
}

int main() {
    read(n);
    for (int i = 1; i &lt;= n; i++) read(color[i]);
    for (int i = 1, u, v; i &lt; n; i++) {
        read(u), read(v);
        G[u].emplace_back(v), G[v].emplace_back(u);
    }
    Init(1, 0);
    dfs(1, true);
    for (int i = 1; i &lt;= n; i++) printf(&quot;%lld &quot;, res[i]);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P4735 最大异或和]]></title>
        <id>https://shaun118294191.github.io/post/p4735-zui-da-yi-huo-he/</id>
        <link href="https://shaun118294191.github.io/post/p4735-zui-da-yi-huo-he/">
        </link>
        <updated>2020-03-22T07:42:21.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4735">题目链接</a><br>
先求出异或前缀和 preXor[i], 则询问操作变为 preXor[p - 1] ^ preXor[N] ^ x，即求一个位置 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo>−</mo><mn>1</mn><mo>≤</mo><mi>P</mi><mo>≤</mo><mi>r</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">l - 1 \le P \le r - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 使得 preXor[P] ^ (preXor[N] ^ x)。</p>
<p>可以以在插入时间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo>−</mo><mn>1</mn><mo>≤</mo><mi>l</mi><mi>s</mi><mi>t</mi><mo>≤</mo><mi>r</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">l - 1 \le lst \le r - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的trie树节点中优先查找与 (preXor[N] ^ x) 相反的指针即可。</p>
<p>可持久化trie树插入（类似可持久化线段树）：</p>
<pre><code class="language-cpp">inline Node newNode(Node &amp;root) {
    static int nptr;
    return root = &amp;Tree[++nptr];
}
inline void insert(Node pre, Node root, int x, int Index) {
    for (int i = BIT - 1, tmp; ~i; i--) {
        tmp = (x &gt;&gt; i) &amp; 1;
        if (pre) root-&gt;son[tmp ^ 1] = pre-&gt;son[tmp ^ 1];
        root-&gt;lst = max(root-&gt;lst, Index);
        root = newNode(root-&gt;son[tmp]), pre = pre ? pre-&gt;son[tmp] : NULL;
    }
    root-&gt;lst = max(root-&gt;lst, Index);
}
</code></pre>
<p>查找操作：</p>
<pre><code class="language-cpp">inline int search(Node root, int x, int limit) {
    int res = 0;
    for (int i = BIT - 1, tmp; ~i; i--) {
        tmp = (x &gt;&gt; i) &amp; 1;
        if (root-&gt;son[tmp ^ 1] &amp;&amp; root-&gt;son[tmp ^ 1]-&gt;lst &gt;= limit) 
            root = root-&gt;son[tmp ^ 1];
        else root = root-&gt;son[tmp]; 
    }
    return preXor[root-&gt;lst] ^ x;
}
</code></pre>
<p>Code:</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
constexpr int MAXN = 3e5 + 5;
constexpr int BIT = 24;
using namespace std;
template &lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1;
    x = 0;
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
struct Trie {
    Trie *son[2];
    int lst;
} Tree[MAXN * BIT &lt;&lt; 2], *root[MAXN &lt;&lt; 1];
using Node = Trie *;
int n, m, preXor[MAXN &lt;&lt; 1];
inline Node newNode(Node &amp;root) {
    static int nptr;
    return root = &amp;Tree[++nptr];
}
inline void insert(Node pre, Node root, int x, int Index) {
    for (int i = BIT - 1, tmp; ~i; i--) {
        tmp = (x &gt;&gt; i) &amp; 1;
        if (pre) root-&gt;son[tmp ^ 1] = pre-&gt;son[tmp ^ 1];
        root-&gt;lst = max(root-&gt;lst, Index);
        root = newNode(root-&gt;son[tmp]), pre = pre ? pre-&gt;son[tmp] : NULL;
    }
    root-&gt;lst = max(root-&gt;lst, Index);
}
inline int search(Node root, int x, int limit) {
    int res = 0;
    for (int i = BIT - 1, tmp; ~i; i--) {
        tmp = (x &gt;&gt; i) &amp; 1;
        if (root-&gt;son[tmp ^ 1] &amp;&amp; root-&gt;son[tmp ^ 1]-&gt;lst &gt;= limit) 
            root = root-&gt;son[tmp ^ 1];
        else root = root-&gt;son[tmp];
    }
    return preXor[root-&gt;lst] ^ x;
}
int main() {
    read(n), read(m);
    insert(Tree, newNode(root[0]), 0, 0);
    for (int i = 1, tmp; i &lt;= n; i++) {
        read(tmp);
        preXor[i] = preXor[i - 1] ^ tmp;
        insert(root[i - 1], newNode(root[i]), preXor[i], i);
    }
    char type[2];
    for (int i = 1; i &lt;= m; i++) {
        int l, r, x;
        scanf(&quot;%s&quot;, type);
        if (type[0] == 'A') {
            read(x), n++;
            preXor[n] = preXor[n - 1] ^ x;
            insert(root[n - 1], newNode(root[n]), preXor[n], n);
        } else {
            read(l), read(r), read(x);
            printf(&quot;%d\n&quot;, search(root[r - 1], preXor[n] ^ x, l - 1));
        }
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P4551 最长异或路径]]></title>
        <id>https://shaun118294191.github.io/post/p4551-zui-chang-yi-huo-lu-jing/</id>
        <link href="https://shaun118294191.github.io/post/p4551-zui-chang-yi-huo-lu-jing/">
        </link>
        <updated>2020-03-22T06:04:50.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4551">题目链接</a><br>
给定一颗N个节点的树，树上每条边有一个权值；从树中选择两个点x和y,把从x到y路径上的所有边权xor,求最大异或值。</p>
<p>1.先进行一次深度优先遍历，求出Xor[x] = Xor[fa[x]] xor Weight</p>
<p>从x到y路径上的所有边权异或后的值为Xor[x] ^ Xor[y]</p>
<p>(同一条边异或两次结果不变, x到根和y到根的重叠部分抵消掉)</p>
<p>于是问题化为求max(Xor[i] ^ Xor[j]), i, j ∈[1,n], 可以trie树解决<a href="https://ac.nowcoder.com/acm/contest/1010/B">The xor largest pair</a></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
constexpr int MAXN = 1e5 + 5;
using namespace std;
template &lt;typename T&gt; inline void read(T &amp;x) {
    int f = 1; x = 0;
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? - 1: 1, ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f;
}
vector&lt; pair&lt;int, int&gt; &gt; G[MAXN];
struct Trie {
    Trie * son[2];
}Tree[MAXN &lt;&lt; 5];
using Node = Trie *;
int n, ans, dis[MAXN];
inline Node newNode(Node &amp;root) {
    static int nptr;
    if (root == NULL) root = &amp;Tree[++nptr];
    return root;
}
inline void insert(Node root, int x) {
    for (int i = 31, tmp; ~i; i--) {
        tmp = (x &gt;&gt; i) &amp; 1;
        root = newNode(root-&gt;son[tmp]);
    }
}
inline void search(Node root, int x) {
    int res = 0;
    for (int i = 31, tmp; ~i; i--) {
        tmp = (x &gt;&gt; i) &amp; 1;
        if (root-&gt;son[tmp ^ 1]) root = root-&gt;son[tmp ^ 1], res |= (1 &lt;&lt; i);
        else root = root-&gt;son[tmp];
    }
    ans = max(ans, res);
}
inline void dfs(int cur, int fa) {
    for (auto &amp;e : G[cur]) {
        int to = e.first, w = e.second;
        if (to == fa) continue;
        dis[to] = dis[cur] ^ w;
        dfs(to, cur);
    }
}
int main() {
    read(n);
    for (int i = 1, u, v, w; i &lt; n; i++) {
        read(u), read(v), read(w);
        G[u].emplace_back(make_pair(v, w));
        G[v].emplace_back(make_pair(u, w));
    }
    dfs(1, 0);
    for (int i = 1; i &lt;= n; i++)
        insert(Tree, dis[i]), search(Tree, dis[i]);
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>